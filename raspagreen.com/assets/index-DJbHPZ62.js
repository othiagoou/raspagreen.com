const __vite__mapDeps = (i, m=__vite__mapDeps, d=(m.f || (m.f = ["assets/GameHistory-nsTNtFhK.js", "assets/PopoverItem.vue_vue_type_script_setup_true_lang-6D509ooZ.js", "assets/Transactions-BCcXX4AG.js", "assets/Deliveries-CGT7eCcn.js"]))) => i.map(i => d[i]);
var e = Object.defineProperty
  , t = e => {
    throw TypeError(e)
}
  , n = (t, n, o) => ( (t, n, o) => n in t ? e(t, n, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: o
}) : t[n] = o)(t, "symbol" != typeof n ? n + "" : n, o)
  , o = (e, n, o) => (( (e, n, o) => {
    n.has(e) || t("Cannot " + o)
}
)(e, n, "read from private field"),
o ? o.call(e) : n.get(e));
/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
function a(e) {
    const t = Object.create(null);
    for (const n of e.split(","))
        t[n] = 1;
    return e => e in t
}
!function() {
    const e = document.createElement("link").relList;
    if (!(e && e.supports && e.supports("modulepreload"))) {
        for (const e of document.querySelectorAll('link[rel="modulepreload"]'))
            t(e);
        new MutationObserver(e => {
            for (const n of e)
                if ("childList" === n.type)
                    for (const e of n.addedNodes)
                        "LINK" === e.tagName && "modulepreload" === e.rel && t(e)
        }
        ).observe(document, {
            childList: !0,
            subtree: !0
        })
    }
    function t(e) {
        if (e.ep)
            return;
        e.ep = !0;
        const t = function(e) {
            const t = {};
            return e.integrity && (t.integrity = e.integrity),
            e.referrerPolicy && (t.referrerPolicy = e.referrerPolicy),
            "use-credentials" === e.crossOrigin ? t.credentials = "include" : "anonymous" === e.crossOrigin ? t.credentials = "omit" : t.credentials = "same-origin",
            t
        }(e);
        fetch(e.href, t)
    }
}();
const r = {}
  , s = []
  , i = () => {}
  , l = () => !1
  , u = e => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97)
  , c = e => e.startsWith("onUpdate:")
  , d = Object.assign
  , p = (e, t) => {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}
  , f = Object.prototype.hasOwnProperty
  , h = (e, t) => f.call(e, t)
  , v = Array.isArray
  , m = e => "[object Map]" === C(e)
  , g = e => "[object Set]" === C(e)
  , y = e => "[object Date]" === C(e)
  , b = e => "function" == typeof e
  , w = e => "string" == typeof e
  , _ = e => "symbol" == typeof e
  , x = e => null !== e && "object" == typeof e
  , k = e => (x(e) || b(e)) && b(e.then) && b(e.catch)
  , S = Object.prototype.toString
  , C = e => S.call(e)
  , E = e => "[object Object]" === C(e)
  , T = e => w(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e
  , A = a(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
  , O = e => {
    const t = Object.create(null);
    return n => t[n] || (t[n] = e(n))
}
  , M = /-(\w)/g
  , P = O(e => e.replace(M, (e, t) => t ? t.toUpperCase() : ""))
  , B = /\B([A-Z])/g
  , I = O(e => e.replace(B, "-$1").toLowerCase())
  , L = O(e => e.charAt(0).toUpperCase() + e.slice(1))
  , R = O(e => e ? `on${L(e)}` : "")
  , z = (e, t) => !Object.is(e, t)
  , N = (e, ...t) => {
    for (let n = 0; n < e.length; n++)
        e[n](...t)
}
  , D = (e, t, n, o=!1) => {
    Object.defineProperty(e, t, {
        configurable: !0,
        enumerable: !1,
        writable: o,
        value: n
    })
}
  , j = e => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t
}
  , F = e => {
    const t = w(e) ? Number(e) : NaN;
    return isNaN(t) ? e : t
}
;
let $;
const V = () => $ || ($ = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {})
  , H = a("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol");
function U(e) {
    if (v(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const o = e[n]
              , a = w(o) ? G(o) : U(o);
            if (a)
                for (const e in a)
                    t[e] = a[e]
        }
        return t
    }
    if (w(e) || x(e))
        return e
}
const Z = /;(?![^(]*\))/g
  , q = /:([^]+)/
  , W = /\/\*[^]*?\*\//g;
function G(e) {
    const t = {};
    return e.replace(W, "").split(Z).forEach(e => {
        if (e) {
            const n = e.split(q);
            n.length > 1 && (t[n[0].trim()] = n[1].trim())
        }
    }
    ),
    t
}
function K(e) {
    let t = "";
    if (w(e))
        t = e;
    else if (v(e))
        for (let n = 0; n < e.length; n++) {
            const o = K(e[n]);
            o && (t += o + " ")
        }
    else if (x(e))
        for (const n in e)
            e[n] && (t += n + " ");
    return t.trim()
}
function Y(e) {
    if (!e)
        return null;
    let {class: t, style: n} = e;
    return t && !w(t) && (e.class = K(t)),
    n && (e.style = U(n)),
    e
}
const X = a("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly");
function J(e) {
    return !!e || "" === e
}
function Q(e, t) {
    if (e === t)
        return !0;
    let n = y(e)
      , o = y(t);
    if (n || o)
        return !(!n || !o) && e.getTime() === t.getTime();
    if (n = _(e),
    o = _(t),
    n || o)
        return e === t;
    if (n = v(e),
    o = v(t),
    n || o)
        return !(!n || !o) && function(e, t) {
            if (e.length !== t.length)
                return !1;
            let n = !0;
            for (let o = 0; n && o < e.length; o++)
                n = Q(e[o], t[o]);
            return n
        }(e, t);
    if (n = x(e),
    o = x(t),
    n || o) {
        if (!n || !o)
            return !1;
        if (Object.keys(e).length !== Object.keys(t).length)
            return !1;
        for (const n in e) {
            const o = e.hasOwnProperty(n)
              , a = t.hasOwnProperty(n);
            if (o && !a || !o && a || !Q(e[n], t[n]))
                return !1
        }
    }
    return String(e) === String(t)
}
function ee(e, t) {
    return e.findIndex(e => Q(e, t))
}
const te = e => !(!e || !0 !== e.__v_isRef)
  , ne = e => w(e) ? e : null == e ? "" : v(e) || x(e) && (e.toString === S || !b(e.toString)) ? te(e) ? ne(e.value) : JSON.stringify(e, oe, 2) : String(e)
  , oe = (e, t) => te(t) ? oe(e, t.value) : m(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce( (e, [t,n], o) => (e[ae(t, o) + " =>"] = n,
    e), {})
} : g(t) ? {
    [`Set(${t.size})`]: [...t.values()].map(e => ae(e))
} : _(t) ? ae(t) : !x(t) || v(t) || E(t) ? t : String(t)
  , ae = (e, t="") => {
    var n;
    return _(e) ? `Symbol(${null != (n = e.description) ? n : t})` : e
}
;
/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let re, se;
class ie {
    constructor(e=!1) {
        this.detached = e,
        this._active = !0,
        this._on = 0,
        this.effects = [],
        this.cleanups = [],
        this._isPaused = !1,
        this.parent = re,
        !e && re && (this.index = (re.scopes || (re.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    pause() {
        if (this._active) {
            let e, t;
            if (this._isPaused = !0,
            this.scopes)
                for (e = 0,
                t = this.scopes.length; e < t; e++)
                    this.scopes[e].pause();
            for (e = 0,
            t = this.effects.length; e < t; e++)
                this.effects[e].pause()
        }
    }
    resume() {
        if (this._active && this._isPaused) {
            let e, t;
            if (this._isPaused = !1,
            this.scopes)
                for (e = 0,
                t = this.scopes.length; e < t; e++)
                    this.scopes[e].resume();
            for (e = 0,
            t = this.effects.length; e < t; e++)
                this.effects[e].resume()
        }
    }
    run(e) {
        if (this._active) {
            const t = re;
            try {
                return re = this,
                e()
            } finally {
                re = t
            }
        }
    }
    on() {
        1 === ++this._on && (this.prevScope = re,
        re = this)
    }
    off() {
        this._on > 0 && 0 === --this._on && (re = this.prevScope,
        this.prevScope = void 0)
    }
    stop(e) {
        if (this._active) {
            let t, n;
            for (this._active = !1,
            t = 0,
            n = this.effects.length; t < n; t++)
                this.effects[t].stop();
            for (this.effects.length = 0,
            t = 0,
            n = this.cleanups.length; t < n; t++)
                this.cleanups[t]();
            if (this.cleanups.length = 0,
            this.scopes) {
                for (t = 0,
                n = this.scopes.length; t < n; t++)
                    this.scopes[t].stop(!0);
                this.scopes.length = 0
            }
            if (!this.detached && this.parent && !e) {
                const e = this.parent.scopes.pop();
                e && e !== this && (this.parent.scopes[this.index] = e,
                e.index = this.index)
            }
            this.parent = void 0
        }
    }
}
function le(e) {
    return new ie(e)
}
function ue() {
    return re
}
function ce(e, t=!1) {
    re && re.cleanups.push(e)
}
const de = new WeakSet;
class pe {
    constructor(e) {
        this.fn = e,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 5,
        this.next = void 0,
        this.cleanup = void 0,
        this.scheduler = void 0,
        re && re.active && re.effects.push(this)
    }
    pause() {
        this.flags |= 64
    }
    resume() {
        64 & this.flags && (this.flags &= -65,
        de.has(this) && (de.delete(this),
        this.trigger()))
    }
    notify() {
        2 & this.flags && !(32 & this.flags) || 8 & this.flags || me(this)
    }
    run() {
        if (!(1 & this.flags))
            return this.fn();
        this.flags |= 2,
        Oe(this),
        be(this);
        const e = se
          , t = Ce;
        se = this,
        Ce = !0;
        try {
            return this.fn()
        } finally {
            we(this),
            se = e,
            Ce = t,
            this.flags &= -3
        }
    }
    stop() {
        if (1 & this.flags) {
            for (let e = this.deps; e; e = e.nextDep)
                ke(e);
            this.deps = this.depsTail = void 0,
            Oe(this),
            this.onStop && this.onStop(),
            this.flags &= -2
        }
    }
    trigger() {
        64 & this.flags ? de.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
    }
    runIfDirty() {
        _e(this) && this.run()
    }
    get dirty() {
        return _e(this)
    }
}
let fe, he, ve = 0;
function me(e, t=!1) {
    if (e.flags |= 8,
    t)
        return e.next = he,
        void (he = e);
    e.next = fe,
    fe = e
}
function ge() {
    ve++
}
function ye() {
    if (--ve > 0)
        return;
    if (he) {
        let e = he;
        for (he = void 0; e; ) {
            const t = e.next;
            e.next = void 0,
            e.flags &= -9,
            e = t
        }
    }
    let e;
    for (; fe; ) {
        let n = fe;
        for (fe = void 0; n; ) {
            const o = n.next;
            if (n.next = void 0,
            n.flags &= -9,
            1 & n.flags)
                try {
                    n.trigger()
                } catch (t) {
                    e || (e = t)
                }
            n = o
        }
    }
    if (e)
        throw e
}
function be(e) {
    for (let t = e.deps; t; t = t.nextDep)
        t.version = -1,
        t.prevActiveLink = t.dep.activeLink,
        t.dep.activeLink = t
}
function we(e) {
    let t, n = e.depsTail, o = n;
    for (; o; ) {
        const e = o.prevDep;
        -1 === o.version ? (o === n && (n = e),
        ke(o),
        Se(o)) : t = o,
        o.dep.activeLink = o.prevActiveLink,
        o.prevActiveLink = void 0,
        o = e
    }
    e.deps = t,
    e.depsTail = n
}
function _e(e) {
    for (let t = e.deps; t; t = t.nextDep)
        if (t.dep.version !== t.version || t.dep.computed && (xe(t.dep.computed) || t.dep.version !== t.version))
            return !0;
    return !!e._dirty
}
function xe(e) {
    if (4 & e.flags && !(16 & e.flags))
        return;
    if (e.flags &= -17,
    e.globalVersion === Me)
        return;
    if (e.globalVersion = Me,
    !e.isSSR && 128 & e.flags && (!e.deps && !e._dirty || !_e(e)))
        return;
    e.flags |= 2;
    const t = e.dep
      , n = se
      , o = Ce;
    se = e,
    Ce = !0;
    try {
        be(e);
        const n = e.fn(e._value);
        (0 === t.version || z(n, e._value)) && (e.flags |= 128,
        e._value = n,
        t.version++)
    } catch (a) {
        throw t.version++,
        a
    } finally {
        se = n,
        Ce = o,
        we(e),
        e.flags &= -3
    }
}
function ke(e, t=!1) {
    const {dep: n, prevSub: o, nextSub: a} = e;
    if (o && (o.nextSub = a,
    e.prevSub = void 0),
    a && (a.prevSub = o,
    e.nextSub = void 0),
    n.subs === e && (n.subs = o,
    !o && n.computed)) {
        n.computed.flags &= -5;
        for (let e = n.computed.deps; e; e = e.nextDep)
            ke(e, !0)
    }
    t || --n.sc || !n.map || n.map.delete(n.key)
}
function Se(e) {
    const {prevDep: t, nextDep: n} = e;
    t && (t.nextDep = n,
    e.prevDep = void 0),
    n && (n.prevDep = t,
    e.nextDep = void 0)
}
let Ce = !0;
const Ee = [];
function Te() {
    Ee.push(Ce),
    Ce = !1
}
function Ae() {
    const e = Ee.pop();
    Ce = void 0 === e || e
}
function Oe(e) {
    const {cleanup: t} = e;
    if (e.cleanup = void 0,
    t) {
        const e = se;
        se = void 0;
        try {
            t()
        } finally {
            se = e
        }
    }
}
let Me = 0;
class Pe {
    constructor(e, t) {
        this.sub = e,
        this.dep = t,
        this.version = t.version,
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
    }
}
class Be {
    constructor(e) {
        this.computed = e,
        this.version = 0,
        this.activeLink = void 0,
        this.subs = void 0,
        this.map = void 0,
        this.key = void 0,
        this.sc = 0,
        this.__v_skip = !0
    }
    track(e) {
        if (!se || !Ce || se === this.computed)
            return;
        let t = this.activeLink;
        if (void 0 === t || t.sub !== se)
            t = this.activeLink = new Pe(se,this),
            se.deps ? (t.prevDep = se.depsTail,
            se.depsTail.nextDep = t,
            se.depsTail = t) : se.deps = se.depsTail = t,
            Ie(t);
        else if (-1 === t.version && (t.version = this.version,
        t.nextDep)) {
            const e = t.nextDep;
            e.prevDep = t.prevDep,
            t.prevDep && (t.prevDep.nextDep = e),
            t.prevDep = se.depsTail,
            t.nextDep = void 0,
            se.depsTail.nextDep = t,
            se.depsTail = t,
            se.deps === t && (se.deps = e)
        }
        return t
    }
    trigger(e) {
        this.version++,
        Me++,
        this.notify(e)
    }
    notify(e) {
        ge();
        try {
            0;
            for (let e = this.subs; e; e = e.prevSub)
                e.sub.notify() && e.sub.dep.notify()
        } finally {
            ye()
        }
    }
}
function Ie(e) {
    if (e.dep.sc++,
    4 & e.sub.flags) {
        const t = e.dep.computed;
        if (t && !e.dep.subs) {
            t.flags |= 20;
            for (let e = t.deps; e; e = e.nextDep)
                Ie(e)
        }
        const n = e.dep.subs;
        n !== e && (e.prevSub = n,
        n && (n.nextSub = e)),
        e.dep.subs = e
    }
}
const Le = new WeakMap
  , Re = Symbol("")
  , ze = Symbol("")
  , Ne = Symbol("");
function De(e, t, n) {
    if (Ce && se) {
        let t = Le.get(e);
        t || Le.set(e, t = new Map);
        let o = t.get(n);
        o || (t.set(n, o = new Be),
        o.map = t,
        o.key = n),
        o.track()
    }
}
function je(e, t, n, o, a, r) {
    const s = Le.get(e);
    if (!s)
        return void Me++;
    const i = e => {
        e && e.trigger()
    }
    ;
    if (ge(),
    "clear" === t)
        s.forEach(i);
    else {
        const a = v(e)
          , r = a && T(n);
        if (a && "length" === n) {
            const e = Number(o);
            s.forEach( (t, n) => {
                ("length" === n || n === Ne || !_(n) && n >= e) && i(t)
            }
            )
        } else
            switch ((void 0 !== n || s.has(void 0)) && i(s.get(n)),
            r && i(s.get(Ne)),
            t) {
            case "add":
                a ? r && i(s.get("length")) : (i(s.get(Re)),
                m(e) && i(s.get(ze)));
                break;
            case "delete":
                a || (i(s.get(Re)),
                m(e) && i(s.get(ze)));
                break;
            case "set":
                m(e) && i(s.get(Re))
            }
    }
    ye()
}
function Fe(e) {
    const t = At(e);
    return t === e ? t : (De(t, 0, Ne),
    Et(e) ? t : t.map(Mt))
}
function $e(e) {
    return De(e = At(e), 0, Ne),
    e
}
const Ve = {
    __proto__: null,
    [Symbol.iterator]() {
        return He(this, Symbol.iterator, Mt)
    },
    concat(...e) {
        return Fe(this).concat(...e.map(e => v(e) ? Fe(e) : e))
    },
    entries() {
        return He(this, "entries", e => (e[1] = Mt(e[1]),
        e))
    },
    every(e, t) {
        return Ze(this, "every", e, t, void 0, arguments)
    },
    filter(e, t) {
        return Ze(this, "filter", e, t, e => e.map(Mt), arguments)
    },
    find(e, t) {
        return Ze(this, "find", e, t, Mt, arguments)
    },
    findIndex(e, t) {
        return Ze(this, "findIndex", e, t, void 0, arguments)
    },
    findLast(e, t) {
        return Ze(this, "findLast", e, t, Mt, arguments)
    },
    findLastIndex(e, t) {
        return Ze(this, "findLastIndex", e, t, void 0, arguments)
    },
    forEach(e, t) {
        return Ze(this, "forEach", e, t, void 0, arguments)
    },
    includes(...e) {
        return We(this, "includes", e)
    },
    indexOf(...e) {
        return We(this, "indexOf", e)
    },
    join(e) {
        return Fe(this).join(e)
    },
    lastIndexOf(...e) {
        return We(this, "lastIndexOf", e)
    },
    map(e, t) {
        return Ze(this, "map", e, t, void 0, arguments)
    },
    pop() {
        return Ge(this, "pop")
    },
    push(...e) {
        return Ge(this, "push", e)
    },
    reduce(e, ...t) {
        return qe(this, "reduce", e, t)
    },
    reduceRight(e, ...t) {
        return qe(this, "reduceRight", e, t)
    },
    shift() {
        return Ge(this, "shift")
    },
    some(e, t) {
        return Ze(this, "some", e, t, void 0, arguments)
    },
    splice(...e) {
        return Ge(this, "splice", e)
    },
    toReversed() {
        return Fe(this).toReversed()
    },
    toSorted(e) {
        return Fe(this).toSorted(e)
    },
    toSpliced(...e) {
        return Fe(this).toSpliced(...e)
    },
    unshift(...e) {
        return Ge(this, "unshift", e)
    },
    values() {
        return He(this, "values", Mt)
    }
};
function He(e, t, n) {
    const o = $e(e)
      , a = o[t]();
    return o === e || Et(e) || (a._next = a.next,
    a.next = () => {
        const e = a._next();
        return e.value && (e.value = n(e.value)),
        e
    }
    ),
    a
}
const Ue = Array.prototype;
function Ze(e, t, n, o, a, r) {
    const s = $e(e)
      , i = s !== e && !Et(e)
      , l = s[t];
    if (l !== Ue[t]) {
        const t = l.apply(e, r);
        return i ? Mt(t) : t
    }
    let u = n;
    s !== e && (i ? u = function(t, o) {
        return n.call(this, Mt(t), o, e)
    }
    : n.length > 2 && (u = function(t, o) {
        return n.call(this, t, o, e)
    }
    ));
    const c = l.call(s, u, o);
    return i && a ? a(c) : c
}
function qe(e, t, n, o) {
    const a = $e(e);
    let r = n;
    return a !== e && (Et(e) ? n.length > 3 && (r = function(t, o, a) {
        return n.call(this, t, o, a, e)
    }
    ) : r = function(t, o, a) {
        return n.call(this, t, Mt(o), a, e)
    }
    ),
    a[t](r, ...o)
}
function We(e, t, n) {
    const o = At(e);
    De(o, 0, Ne);
    const a = o[t](...n);
    return -1 !== a && !1 !== a || !Tt(n[0]) ? a : (n[0] = At(n[0]),
    o[t](...n))
}
function Ge(e, t, n=[]) {
    Te(),
    ge();
    const o = At(e)[t].apply(e, n);
    return ye(),
    Ae(),
    o
}
const Ke = a("__proto__,__v_isRef,__isVue")
  , Ye = new Set(Object.getOwnPropertyNames(Symbol).filter(e => "arguments" !== e && "caller" !== e).map(e => Symbol[e]).filter(_));
function Xe(e) {
    _(e) || (e = String(e));
    const t = At(this);
    return De(t, 0, e),
    t.hasOwnProperty(e)
}
class Je {
    constructor(e=!1, t=!1) {
        this._isReadonly = e,
        this._isShallow = t
    }
    get(e, t, n) {
        if ("__v_skip" === t)
            return e.__v_skip;
        const o = this._isReadonly
          , a = this._isShallow;
        if ("__v_isReactive" === t)
            return !o;
        if ("__v_isReadonly" === t)
            return o;
        if ("__v_isShallow" === t)
            return a;
        if ("__v_raw" === t)
            return n === (o ? a ? gt : mt : a ? vt : ht).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
        const r = v(e);
        if (!o) {
            let e;
            if (r && (e = Ve[t]))
                return e;
            if ("hasOwnProperty" === t)
                return Xe
        }
        const s = Reflect.get(e, t, Bt(e) ? e : n);
        return (_(t) ? Ye.has(t) : Ke(t)) ? s : (o || De(e, 0, t),
        a ? s : Bt(s) ? r && T(t) ? s : s.value : x(s) ? o ? _t(s) : bt(s) : s)
    }
}
class Qe extends Je {
    constructor(e=!1) {
        super(!1, e)
    }
    set(e, t, n, o) {
        let a = e[t];
        if (!this._isShallow) {
            const t = Ct(a);
            if (Et(n) || Ct(n) || (a = At(a),
            n = At(n)),
            !v(e) && Bt(a) && !Bt(n))
                return !t && (a.value = n,
                !0)
        }
        const r = v(e) && T(t) ? Number(t) < e.length : h(e, t)
          , s = Reflect.set(e, t, n, Bt(e) ? e : o);
        return e === At(o) && (r ? z(n, a) && je(e, "set", t, n) : je(e, "add", t, n)),
        s
    }
    deleteProperty(e, t) {
        const n = h(e, t);
        e[t];
        const o = Reflect.deleteProperty(e, t);
        return o && n && je(e, "delete", t, void 0),
        o
    }
    has(e, t) {
        const n = Reflect.has(e, t);
        return _(t) && Ye.has(t) || De(e, 0, t),
        n
    }
    ownKeys(e) {
        return De(e, 0, v(e) ? "length" : Re),
        Reflect.ownKeys(e)
    }
}
class et extends Je {
    constructor(e=!1) {
        super(!0, e)
    }
    set(e, t) {
        return !0
    }
    deleteProperty(e, t) {
        return !0
    }
}
const tt = new Qe
  , nt = new et
  , ot = new Qe(!0)
  , at = new et(!0)
  , rt = e => e
  , st = e => Reflect.getPrototypeOf(e);
function it(e) {
    return function(...t) {
        return "delete" !== e && ("clear" === e ? void 0 : this)
    }
}
function lt(e, t) {
    const n = {
        get(n) {
            const o = this.__v_raw
              , a = At(o)
              , r = At(n);
            e || (z(n, r) && De(a, 0, n),
            De(a, 0, r));
            const {has: s} = st(a)
              , i = t ? rt : e ? Pt : Mt;
            return s.call(a, n) ? i(o.get(n)) : s.call(a, r) ? i(o.get(r)) : void (o !== a && o.get(n))
        },
        get size() {
            const t = this.__v_raw;
            return !e && De(At(t), 0, Re),
            Reflect.get(t, "size", t)
        },
        has(t) {
            const n = this.__v_raw
              , o = At(n)
              , a = At(t);
            return e || (z(t, a) && De(o, 0, t),
            De(o, 0, a)),
            t === a ? n.has(t) : n.has(t) || n.has(a)
        },
        forEach(n, o) {
            const a = this
              , r = a.__v_raw
              , s = At(r)
              , i = t ? rt : e ? Pt : Mt;
            return !e && De(s, 0, Re),
            r.forEach( (e, t) => n.call(o, i(e), i(t), a))
        }
    };
    d(n, e ? {
        add: it("add"),
        set: it("set"),
        delete: it("delete"),
        clear: it("clear")
    } : {
        add(e) {
            t || Et(e) || Ct(e) || (e = At(e));
            const n = At(this);
            return st(n).has.call(n, e) || (n.add(e),
            je(n, "add", e, e)),
            this
        },
        set(e, n) {
            t || Et(n) || Ct(n) || (n = At(n));
            const o = At(this)
              , {has: a, get: r} = st(o);
            let s = a.call(o, e);
            s || (e = At(e),
            s = a.call(o, e));
            const i = r.call(o, e);
            return o.set(e, n),
            s ? z(n, i) && je(o, "set", e, n) : je(o, "add", e, n),
            this
        },
        delete(e) {
            const t = At(this)
              , {has: n, get: o} = st(t);
            let a = n.call(t, e);
            a || (e = At(e),
            a = n.call(t, e)),
            o && o.call(t, e);
            const r = t.delete(e);
            return a && je(t, "delete", e, void 0),
            r
        },
        clear() {
            const e = At(this)
              , t = 0 !== e.size
              , n = e.clear();
            return t && je(e, "clear", void 0, void 0),
            n
        }
    });
    return ["keys", "values", "entries", Symbol.iterator].forEach(o => {
        n[o] = function(e, t, n) {
            return function(...o) {
                const a = this.__v_raw
                  , r = At(a)
                  , s = m(r)
                  , i = "entries" === e || e === Symbol.iterator && s
                  , l = "keys" === e && s
                  , u = a[e](...o)
                  , c = n ? rt : t ? Pt : Mt;
                return !t && De(r, 0, l ? ze : Re),
                {
                    next() {
                        const {value: e, done: t} = u.next();
                        return t ? {
                            value: e,
                            done: t
                        } : {
                            value: i ? [c(e[0]), c(e[1])] : c(e),
                            done: t
                        }
                    },
                    [Symbol.iterator]() {
                        return this
                    }
                }
            }
        }(o, e, t)
    }
    ),
    n
}
function ut(e, t) {
    const n = lt(e, t);
    return (t, o, a) => "__v_isReactive" === o ? !e : "__v_isReadonly" === o ? e : "__v_raw" === o ? t : Reflect.get(h(n, o) && o in t ? n : t, o, a)
}
const ct = {
    get: ut(!1, !1)
}
  , dt = {
    get: ut(!1, !0)
}
  , pt = {
    get: ut(!0, !1)
}
  , ft = {
    get: ut(!0, !0)
}
  , ht = new WeakMap
  , vt = new WeakMap
  , mt = new WeakMap
  , gt = new WeakMap;
function yt(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : function(e) {
        switch (e) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
        }
    }((e => C(e).slice(8, -1))(e))
}
function bt(e) {
    return Ct(e) ? e : kt(e, !1, tt, ct, ht)
}
function wt(e) {
    return kt(e, !1, ot, dt, vt)
}
function _t(e) {
    return kt(e, !0, nt, pt, mt)
}
function xt(e) {
    return kt(e, !0, at, ft, gt)
}
function kt(e, t, n, o, a) {
    if (!x(e))
        return e;
    if (e.__v_raw && (!t || !e.__v_isReactive))
        return e;
    const r = yt(e);
    if (0 === r)
        return e;
    const s = a.get(e);
    if (s)
        return s;
    const i = new Proxy(e,2 === r ? o : n);
    return a.set(e, i),
    i
}
function St(e) {
    return Ct(e) ? St(e.__v_raw) : !(!e || !e.__v_isReactive)
}
function Ct(e) {
    return !(!e || !e.__v_isReadonly)
}
function Et(e) {
    return !(!e || !e.__v_isShallow)
}
function Tt(e) {
    return !!e && !!e.__v_raw
}
function At(e) {
    const t = e && e.__v_raw;
    return t ? At(t) : e
}
function Ot(e) {
    return !h(e, "__v_skip") && Object.isExtensible(e) && D(e, "__v_skip", !0),
    e
}
const Mt = e => x(e) ? bt(e) : e
  , Pt = e => x(e) ? _t(e) : e;
function Bt(e) {
    return !!e && !0 === e.__v_isRef
}
function It(e) {
    return Rt(e, !1)
}
function Lt(e) {
    return Rt(e, !0)
}
function Rt(e, t) {
    return Bt(e) ? e : new zt(e,t)
}
class zt {
    constructor(e, t) {
        this.dep = new Be,
        this.__v_isRef = !0,
        this.__v_isShallow = !1,
        this._rawValue = t ? e : At(e),
        this._value = t ? e : Mt(e),
        this.__v_isShallow = t
    }
    get value() {
        return this.dep.track(),
        this._value
    }
    set value(e) {
        const t = this._rawValue
          , n = this.__v_isShallow || Et(e) || Ct(e);
        e = n ? e : At(e),
        z(e, t) && (this._rawValue = e,
        this._value = n ? e : Mt(e),
        this.dep.trigger())
    }
}
function Nt(e) {
    return Bt(e) ? e.value : e
}
function Dt(e) {
    return b(e) ? e() : Nt(e)
}
const jt = {
    get: (e, t, n) => "__v_raw" === t ? e : Nt(Reflect.get(e, t, n)),
    set: (e, t, n, o) => {
        const a = e[t];
        return Bt(a) && !Bt(n) ? (a.value = n,
        !0) : Reflect.set(e, t, n, o)
    }
};
function Ft(e) {
    return St(e) ? e : new Proxy(e,jt)
}
class $t {
    constructor(e) {
        this.__v_isRef = !0,
        this._value = void 0;
        const t = this.dep = new Be
          , {get: n, set: o} = e(t.track.bind(t), t.trigger.bind(t));
        this._get = n,
        this._set = o
    }
    get value() {
        return this._value = this._get()
    }
    set value(e) {
        this._set(e)
    }
}
function Vt(e) {
    return new $t(e)
}
function Ht(e) {
    const t = v(e) ? new Array(e.length) : {};
    for (const n in e)
        t[n] = Wt(e, n);
    return t
}
class Ut {
    constructor(e, t, n) {
        this._object = e,
        this._key = t,
        this._defaultValue = n,
        this.__v_isRef = !0,
        this._value = void 0
    }
    get value() {
        const e = this._object[this._key];
        return this._value = void 0 === e ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
    get dep() {
        return function(e, t) {
            const n = Le.get(e);
            return n && n.get(t)
        }(At(this._object), this._key)
    }
}
class Zt {
    constructor(e) {
        this._getter = e,
        this.__v_isRef = !0,
        this.__v_isReadonly = !0,
        this._value = void 0
    }
    get value() {
        return this._value = this._getter()
    }
}
function qt(e, t, n) {
    return Bt(e) ? e : b(e) ? new Zt(e) : x(e) && arguments.length > 1 ? Wt(e, t, n) : It(e)
}
function Wt(e, t, n) {
    const o = e[t];
    return Bt(o) ? o : new Ut(e,t,n)
}
class Gt {
    constructor(e, t, n) {
        this.fn = e,
        this.setter = t,
        this._value = void 0,
        this.dep = new Be(this),
        this.__v_isRef = !0,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 16,
        this.globalVersion = Me - 1,
        this.next = void 0,
        this.effect = this,
        this.__v_isReadonly = !t,
        this.isSSR = n
    }
    notify() {
        if (this.flags |= 16,
        !(8 & this.flags) && se !== this)
            return me(this, !0),
            !0
    }
    get value() {
        const e = this.dep.track();
        return xe(this),
        e && (e.version = this.dep.version),
        this._value
    }
    set value(e) {
        this.setter && this.setter(e)
    }
}
const Kt = {}
  , Yt = new WeakMap;
let Xt;
function Jt(e, t=!1, n=Xt) {
    if (n) {
        let t = Yt.get(n);
        t || Yt.set(n, t = []),
        t.push(e)
    }
}
function Qt(e, t=1 / 0, n) {
    if (t <= 0 || !x(e) || e.__v_skip)
        return e;
    if ((n = n || new Set).has(e))
        return e;
    if (n.add(e),
    t--,
    Bt(e))
        Qt(e.value, t, n);
    else if (v(e))
        for (let o = 0; o < e.length; o++)
            Qt(e[o], t, n);
    else if (g(e) || m(e))
        e.forEach(e => {
            Qt(e, t, n)
        }
        );
    else if (E(e)) {
        for (const o in e)
            Qt(e[o], t, n);
        for (const o of Object.getOwnPropertySymbols(e))
            Object.prototype.propertyIsEnumerable.call(e, o) && Qt(e[o], t, n)
    }
    return e
}
/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const en = [];
const tn = {
    sp: "serverPrefetch hook",
    bc: "beforeCreate hook",
    c: "created hook",
    bm: "beforeMount hook",
    m: "mounted hook",
    bu: "beforeUpdate hook",
    u: "updated",
    bum: "beforeUnmount hook",
    um: "unmounted hook",
    a: "activated hook",
    da: "deactivated hook",
    ec: "errorCaptured hook",
    rtc: "renderTracked hook",
    rtg: "renderTriggered hook",
    0: "setup function",
    1: "render function",
    2: "watcher getter",
    3: "watcher callback",
    4: "watcher cleanup function",
    5: "native event handler",
    6: "component event handler",
    7: "vnode hook",
    8: "directive hook",
    9: "transition hook",
    10: "app errorHandler",
    11: "app warnHandler",
    12: "ref function",
    13: "async component loader",
    14: "scheduler flush",
    15: "component update",
    16: "app unmount cleanup function"
};
function nn(e, t, n, o) {
    try {
        return o ? e(...o) : e()
    } catch (a) {
        an(a, t, n)
    }
}
function on(e, t, n, o) {
    if (b(e)) {
        const a = nn(e, t, n, o);
        return a && k(a) && a.catch(e => {
            an(e, t, n)
        }
        ),
        a
    }
    if (v(e)) {
        const a = [];
        for (let r = 0; r < e.length; r++)
            a.push(on(e[r], t, n, o));
        return a
    }
}
function an(e, t, n, o=!0) {
    t && t.vnode;
    const {errorHandler: a, throwUnhandledErrorInProduction: s} = t && t.appContext.config || r;
    if (t) {
        let o = t.parent;
        const r = t.proxy
          , s = `https://vuejs.org/error-reference/#runtime-${n}`;
        for (; o; ) {
            const t = o.ec;
            if (t)
                for (let n = 0; n < t.length; n++)
                    if (!1 === t[n](e, r, s))
                        return;
            o = o.parent
        }
        if (a)
            return Te(),
            nn(a, null, 10, [e, r, s]),
            void Ae()
    }
    !function(e, t, n, o=!0, a=!1) {
        if (a)
            throw e
    }(e, 0, 0, o, s)
}
const rn = [];
let sn = -1;
const ln = [];
let un = null
  , cn = 0;
const dn = Promise.resolve();
let pn = null;
function fn(e) {
    const t = pn || dn;
    return e ? t.then(this ? e.bind(this) : e) : t
}
function hn(e) {
    if (!(1 & e.flags)) {
        const t = bn(e)
          , n = rn[rn.length - 1];
        !n || !(2 & e.flags) && t >= bn(n) ? rn.push(e) : rn.splice(function(e) {
            let t = sn + 1
              , n = rn.length;
            for (; t < n; ) {
                const o = t + n >>> 1
                  , a = rn[o]
                  , r = bn(a);
                r < e || r === e && 2 & a.flags ? t = o + 1 : n = o
            }
            return t
        }(t), 0, e),
        e.flags |= 1,
        vn()
    }
}
function vn() {
    pn || (pn = dn.then(wn))
}
function mn(e) {
    v(e) ? ln.push(...e) : un && -1 === e.id ? un.splice(cn + 1, 0, e) : 1 & e.flags || (ln.push(e),
    e.flags |= 1),
    vn()
}
function gn(e, t, n=sn + 1) {
    for (; n < rn.length; n++) {
        const t = rn[n];
        if (t && 2 & t.flags) {
            if (e && t.id !== e.uid)
                continue;
            rn.splice(n, 1),
            n--,
            4 & t.flags && (t.flags &= -2),
            t(),
            4 & t.flags || (t.flags &= -2)
        }
    }
}
function yn(e) {
    if (ln.length) {
        const e = [...new Set(ln)].sort( (e, t) => bn(e) - bn(t));
        if (ln.length = 0,
        un)
            return void un.push(...e);
        for (un = e,
        cn = 0; cn < un.length; cn++) {
            const e = un[cn];
            4 & e.flags && (e.flags &= -2),
            8 & e.flags || e(),
            e.flags &= -2
        }
        un = null,
        cn = 0
    }
}
const bn = e => null == e.id ? 2 & e.flags ? -1 : 1 / 0 : e.id;
function wn(e) {
    try {
        for (sn = 0; sn < rn.length; sn++) {
            const e = rn[sn];
            !e || 8 & e.flags || (4 & e.flags && (e.flags &= -2),
            nn(e, e.i, e.i ? 15 : 14),
            4 & e.flags || (e.flags &= -2))
        }
    } finally {
        for (; sn < rn.length; sn++) {
            const e = rn[sn];
            e && (e.flags &= -2)
        }
        sn = -1,
        rn.length = 0,
        yn(),
        pn = null,
        (rn.length || ln.length) && wn()
    }
}
let _n, xn = [];
let kn = null
  , Sn = null;
function Cn(e) {
    const t = kn;
    return kn = e,
    Sn = e && e.type.__scopeId || null,
    t
}
function En(e, t=kn, n) {
    if (!t)
        return e;
    if (e._n)
        return e;
    const o = (...n) => {
        o._d && Mr(-1);
        const a = Cn(t);
        let r;
        try {
            r = e(...n)
        } finally {
            Cn(a),
            o._d && Mr(1)
        }
        return r
    }
    ;
    return o._n = !0,
    o._c = !0,
    o._d = !0,
    o
}
function Tn(e, t) {
    if (null === kn)
        return e;
    const n = hs(kn)
      , o = e.dirs || (e.dirs = []);
    for (let a = 0; a < t.length; a++) {
        let[e,s,i,l=r] = t[a];
        e && (b(e) && (e = {
            mounted: e,
            updated: e
        }),
        e.deep && Qt(s),
        o.push({
            dir: e,
            instance: n,
            value: s,
            oldValue: void 0,
            arg: i,
            modifiers: l
        }))
    }
    return e
}
function An(e, t, n, o) {
    const a = e.dirs
      , r = t && t.dirs;
    for (let s = 0; s < a.length; s++) {
        const i = a[s];
        r && (i.oldValue = r[s].value);
        let l = i.dir[o];
        l && (Te(),
        on(l, n, 8, [e.el, i, e, t]),
        Ae())
    }
}
const On = Symbol("_vte")
  , Mn = e => e.__isTeleport
  , Pn = e => e && (e.disabled || "" === e.disabled)
  , Bn = e => e && (e.defer || "" === e.defer)
  , In = e => "undefined" != typeof SVGElement && e instanceof SVGElement
  , Ln = e => "function" == typeof MathMLElement && e instanceof MathMLElement
  , Rn = (e, t) => {
    const n = e && e.to;
    if (w(n)) {
        if (t) {
            return t(n)
        }
        return null
    }
    return n
}
  , zn = {
    name: "Teleport",
    __isTeleport: !0,
    process(e, t, n, o, a, r, s, i, l, u) {
        const {mc: c, pc: d, pbc: p, o: {insert: f, querySelector: h, createText: v, createComment: m}} = u
          , g = Pn(t.props);
        let {shapeFlag: y, children: b, dynamicChildren: w} = t;
        if (null == e) {
            const e = t.el = v("")
              , u = t.anchor = v("");
            f(e, n, o),
            f(u, n, o);
            const d = (e, t) => {
                16 & y && (a && a.isCE && (a.ce._teleportTarget = e),
                c(b, e, t, a, r, s, i, l))
            }
              , p = () => {
                const e = t.target = Rn(t.props, h)
                  , n = Fn(e, t, v, f);
                e && ("svg" !== s && In(e) ? s = "svg" : "mathml" !== s && Ln(e) && (s = "mathml"),
                g || (d(e, n),
                jn(t, !1)))
            }
            ;
            g && (d(n, u),
            jn(t, !0)),
            Bn(t.props) ? (t.el.__isMounted = !1,
            Da( () => {
                p(),
                delete t.el.__isMounted
            }
            , r)) : p()
        } else {
            if (Bn(t.props) && !1 === e.el.__isMounted)
                return void Da( () => {
                    zn.process(e, t, n, o, a, r, s, i, l, u)
                }
                , r);
            t.el = e.el,
            t.targetStart = e.targetStart;
            const c = t.anchor = e.anchor
              , f = t.target = e.target
              , v = t.targetAnchor = e.targetAnchor
              , m = Pn(e.props)
              , y = m ? n : f
              , b = m ? c : v;
            if ("svg" === s || In(f) ? s = "svg" : ("mathml" === s || Ln(f)) && (s = "mathml"),
            w ? (p(e.dynamicChildren, w, y, a, r, s, i),
            Za(e, t, !0)) : l || d(e, t, y, b, a, r, s, i, !1),
            g)
                m ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : Nn(t, n, c, u, 1);
            else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                const e = t.target = Rn(t.props, h);
                e && Nn(t, e, null, u, 0)
            } else
                m && Nn(t, f, v, u, 1);
            jn(t, g)
        }
    },
    remove(e, t, n, {um: o, o: {remove: a}}, r) {
        const {shapeFlag: s, children: i, anchor: l, targetStart: u, targetAnchor: c, target: d, props: p} = e;
        if (d && (a(u),
        a(c)),
        r && a(l),
        16 & s) {
            const e = r || !Pn(p);
            for (let a = 0; a < i.length; a++) {
                const r = i[a];
                o(r, t, n, e, !!r.dynamicChildren)
            }
        }
    },
    move: Nn,
    hydrate: function(e, t, n, o, a, r, {o: {nextSibling: s, parentNode: i, querySelector: l, insert: u, createText: c}}, d) {
        const p = t.target = Rn(t.props, l);
        if (p) {
            const l = Pn(t.props)
              , f = p._lpa || p.firstChild;
            if (16 & t.shapeFlag)
                if (l)
                    t.anchor = d(s(e), t, i(e), n, o, a, r),
                    t.targetStart = f,
                    t.targetAnchor = f && s(f);
                else {
                    t.anchor = s(e);
                    let i = f;
                    for (; i; ) {
                        if (i && 8 === i.nodeType)
                            if ("teleport start anchor" === i.data)
                                t.targetStart = i;
                            else if ("teleport anchor" === i.data) {
                                t.targetAnchor = i,
                                p._lpa = t.targetAnchor && s(t.targetAnchor);
                                break
                            }
                        i = s(i)
                    }
                    t.targetAnchor || Fn(p, t, c, u),
                    d(f && s(f), t, p, n, o, a, r)
                }
            jn(t, l)
        }
        return t.anchor && s(t.anchor)
    }
};
function Nn(e, t, n, {o: {insert: o}, m: a}, r=2) {
    0 === r && o(e.targetAnchor, t, n);
    const {el: s, anchor: i, shapeFlag: l, children: u, props: c} = e
      , d = 2 === r;
    if (d && o(s, t, n),
    (!d || Pn(c)) && 16 & l)
        for (let p = 0; p < u.length; p++)
            a(u[p], t, n, 2);
    d && o(i, t, n)
}
const Dn = zn;
function jn(e, t) {
    const n = e.ctx;
    if (n && n.ut) {
        let o, a;
        for (t ? (o = e.el,
        a = e.anchor) : (o = e.targetStart,
        a = e.targetAnchor); o && o !== a; )
            1 === o.nodeType && o.setAttribute("data-v-owner", n.uid),
            o = o.nextSibling;
        n.ut()
    }
}
function Fn(e, t, n, o) {
    const a = t.targetStart = n("")
      , r = t.targetAnchor = n("");
    return a[On] = r,
    e && (o(a, e),
    o(r, e)),
    r
}
const $n = Symbol("_leaveCb")
  , Vn = Symbol("_enterCb");
function Hn() {
    const e = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return Mo( () => {
        e.isMounted = !0
    }
    ),
    Io( () => {
        e.isUnmounting = !0
    }
    ),
    e
}
const Un = [Function, Array]
  , Zn = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Un,
    onEnter: Un,
    onAfterEnter: Un,
    onEnterCancelled: Un,
    onBeforeLeave: Un,
    onLeave: Un,
    onAfterLeave: Un,
    onLeaveCancelled: Un,
    onBeforeAppear: Un,
    onAppear: Un,
    onAfterAppear: Un,
    onAppearCancelled: Un
}
  , qn = e => {
    const t = e.subTree;
    return t.component ? qn(t.component) : t
}
;
function Wn(e) {
    let t = e[0];
    if (e.length > 1)
        for (const n of e)
            if (n.type !== kr) {
                t = n;
                break
            }
    return t
}
const Gn = {
    name: "BaseTransition",
    props: Zn,
    setup(e, {slots: t}) {
        const n = es()
          , o = Hn();
        return () => {
            const a = t.default && eo(t.default(), !0);
            if (!a || !a.length)
                return;
            const r = Wn(a)
              , s = At(e)
              , {mode: i} = s;
            if (o.isLeaving)
                return Xn(r);
            const l = Jn(r);
            if (!l)
                return Xn(r);
            let u = Yn(l, s, o, n, e => u = e);
            l.type !== kr && Qn(l, u);
            let c = n.subTree && Jn(n.subTree);
            if (c && c.type !== kr && !Rr(l, c) && qn(n).type !== kr) {
                let e = Yn(c, s, o, n);
                if (Qn(c, e),
                "out-in" === i && l.type !== kr)
                    return o.isLeaving = !0,
                    e.afterLeave = () => {
                        o.isLeaving = !1,
                        8 & n.job.flags || n.update(),
                        delete e.afterLeave,
                        c = void 0
                    }
                    ,
                    Xn(r);
                "in-out" === i && l.type !== kr ? e.delayLeave = (e, t, n) => {
                    Kn(o, c)[String(c.key)] = c,
                    e[$n] = () => {
                        t(),
                        e[$n] = void 0,
                        delete u.delayedLeave,
                        c = void 0
                    }
                    ,
                    u.delayedLeave = () => {
                        n(),
                        delete u.delayedLeave,
                        c = void 0
                    }
                }
                : c = void 0
            } else
                c && (c = void 0);
            return r
        }
    }
};
function Kn(e, t) {
    const {leavingVNodes: n} = e;
    let o = n.get(t.type);
    return o || (o = Object.create(null),
    n.set(t.type, o)),
    o
}
function Yn(e, t, n, o, a) {
    const {appear: r, mode: s, persisted: i=!1, onBeforeEnter: l, onEnter: u, onAfterEnter: c, onEnterCancelled: d, onBeforeLeave: p, onLeave: f, onAfterLeave: h, onLeaveCancelled: m, onBeforeAppear: g, onAppear: y, onAfterAppear: b, onAppearCancelled: w} = t
      , _ = String(e.key)
      , x = Kn(n, e)
      , k = (e, t) => {
        e && on(e, o, 9, t)
    }
      , S = (e, t) => {
        const n = t[1];
        k(e, t),
        v(e) ? e.every(e => e.length <= 1) && n() : e.length <= 1 && n()
    }
      , C = {
        mode: s,
        persisted: i,
        beforeEnter(t) {
            let o = l;
            if (!n.isMounted) {
                if (!r)
                    return;
                o = g || l
            }
            t[$n] && t[$n](!0);
            const a = x[_];
            a && Rr(e, a) && a.el[$n] && a.el[$n](),
            k(o, [t])
        },
        enter(e) {
            let t = u
              , o = c
              , a = d;
            if (!n.isMounted) {
                if (!r)
                    return;
                t = y || u,
                o = b || c,
                a = w || d
            }
            let s = !1;
            const i = e[Vn] = t => {
                s || (s = !0,
                k(t ? a : o, [e]),
                C.delayedLeave && C.delayedLeave(),
                e[Vn] = void 0)
            }
            ;
            t ? S(t, [e, i]) : i()
        },
        leave(t, o) {
            const a = String(e.key);
            if (t[Vn] && t[Vn](!0),
            n.isUnmounting)
                return o();
            k(p, [t]);
            let r = !1;
            const s = t[$n] = n => {
                r || (r = !0,
                o(),
                k(n ? m : h, [t]),
                t[$n] = void 0,
                x[a] === e && delete x[a])
            }
            ;
            x[a] = e,
            f ? S(f, [t, s]) : s()
        },
        clone(e) {
            const r = Yn(e, t, n, o, a);
            return a && a(r),
            r
        }
    };
    return C
}
function Xn(e) {
    if (yo(e))
        return (e = $r(e)).children = null,
        e
}
function Jn(e) {
    if (!yo(e))
        return Mn(e.type) && e.children ? Wn(e.children) : e;
    if (e.component)
        return e.component.subTree;
    const {shapeFlag: t, children: n} = e;
    if (n) {
        if (16 & t)
            return n[0];
        if (32 & t && b(n.default))
            return n.default()
    }
}
function Qn(e, t) {
    6 & e.shapeFlag && e.component ? (e.transition = t,
    Qn(e.component.subTree, t)) : 128 & e.shapeFlag ? (e.ssContent.transition = t.clone(e.ssContent),
    e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}
function eo(e, t=!1, n) {
    let o = []
      , a = 0;
    for (let r = 0; r < e.length; r++) {
        let s = e[r];
        const i = null == n ? s.key : String(n) + String(null != s.key ? s.key : r);
        s.type === _r ? (128 & s.patchFlag && a++,
        o = o.concat(eo(s.children, t, i))) : (t || s.type !== kr) && o.push(null != i ? $r(s, {
            key: i
        }) : s)
    }
    if (a > 1)
        for (let r = 0; r < o.length; r++)
            o[r].patchFlag = -2;
    return o
}
/*! #__NO_SIDE_EFFECTS__ */
function to(e, t) {
    return b(e) ? ( () => d({
        name: e.name
    }, t, {
        setup: e
    }))() : e
}
function no() {
    const e = es();
    return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : ""
}
function oo(e) {
    e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0]
}
function ao(e, t, n, o, a=!1) {
    if (v(e))
        return void e.forEach( (e, r) => ao(e, t && (v(t) ? t[r] : t), n, o, a));
    if (mo(o) && !a)
        return void (512 & o.shapeFlag && o.type.__asyncResolved && o.component.subTree.component && ao(e, t, n, o.component.subTree));
    const s = 4 & o.shapeFlag ? hs(o.component) : o.el
      , i = a ? null : s
      , {i: l, r: u} = e
      , c = t && t.r
      , d = l.refs === r ? l.refs = {} : l.refs
      , f = l.setupState
      , m = At(f)
      , g = f === r ? () => !1 : e => h(m, e);
    if (null != c && c !== u && (w(c) ? (d[c] = null,
    g(c) && (f[c] = null)) : Bt(c) && (c.value = null)),
    b(u))
        nn(u, l, 12, [i, d]);
    else {
        const t = w(u)
          , o = Bt(u);
        if (t || o) {
            const r = () => {
                if (e.f) {
                    const n = t ? g(u) ? f[u] : d[u] : u.value;
                    a ? v(n) && p(n, s) : v(n) ? n.includes(s) || n.push(s) : t ? (d[u] = [s],
                    g(u) && (f[u] = d[u])) : (u.value = [s],
                    e.k && (d[e.k] = u.value))
                } else
                    t ? (d[u] = i,
                    g(u) && (f[u] = i)) : o && (u.value = i,
                    e.k && (d[e.k] = i))
            }
            ;
            i ? (r.id = -1,
            Da(r, n)) : r()
        }
    }
}
let ro = !1;
const so = () => {
    ro || (ro = !0)
}
  , io = e => {
    if (1 === e.nodeType)
        return (e => e.namespaceURI.includes("svg") && "foreignObject" !== e.tagName)(e) ? "svg" : (e => e.namespaceURI.includes("MathML"))(e) ? "mathml" : void 0
}
  , lo = e => 8 === e.nodeType;
function uo(e) {
    const {mt: t, p: n, o: {patchProp: o, createText: a, nextSibling: r, parentNode: s, remove: i, insert: l, createComment: c}} = e
      , d = (n, o, i, u, c, b=!1) => {
        b = b || !!o.dynamicChildren;
        const w = lo(n) && "[" === n.data
          , _ = () => v(n, o, i, u, c, w)
          , {type: x, ref: k, shapeFlag: S, patchFlag: C} = o;
        let E = n.nodeType;
        o.el = n,
        -2 === C && (b = !1,
        o.dynamicChildren = null);
        let T = null;
        switch (x) {
        case xr:
            3 !== E ? "" === o.children ? (l(o.el = a(""), s(n), n),
            T = n) : T = _() : (n.data !== o.children && (so(),
            n.data = o.children),
            T = r(n));
            break;
        case kr:
            y(n) ? (T = r(n),
            g(o.el = n.content.firstChild, n, i)) : T = 8 !== E || w ? _() : r(n);
            break;
        case Sr:
            if (w && (E = (n = r(n)).nodeType),
            1 === E || 3 === E) {
                T = n;
                const e = !o.children.length;
                for (let t = 0; t < o.staticCount; t++)
                    e && (o.children += 1 === T.nodeType ? T.outerHTML : T.data),
                    t === o.staticCount - 1 && (o.anchor = T),
                    T = r(T);
                return w ? r(T) : T
            }
            _();
            break;
        case _r:
            T = w ? h(n, o, i, u, c, b) : _();
            break;
        default:
            if (1 & S)
                T = 1 === E && o.type.toLowerCase() === n.tagName.toLowerCase() || y(n) ? p(n, o, i, u, c, b) : _();
            else if (6 & S) {
                o.slotScopeIds = c;
                const e = s(n);
                if (T = w ? m(n) : lo(n) && "teleport start" === n.data ? m(n, n.data, "teleport end") : r(n),
                t(o, e, null, i, u, io(e), b),
                mo(o) && !o.type.__asyncResolved) {
                    let t;
                    w ? (t = jr(_r),
                    t.anchor = T ? T.previousSibling : e.lastChild) : t = 3 === n.nodeType ? Vr("") : jr("div"),
                    t.el = n,
                    o.component.subTree = t
                }
            } else
                64 & S ? T = 8 !== E ? _() : o.type.hydrate(n, o, i, u, c, b, e, f) : 128 & S && (T = o.type.hydrate(n, o, i, u, io(s(n)), c, b, e, d))
        }
        return null != k && ao(k, null, u, o),
        T
    }
      , p = (e, t, n, a, r, s) => {
        s = s || !!t.dynamicChildren;
        const {type: l, props: c, patchFlag: d, shapeFlag: p, dirs: h, transition: v} = t
          , m = "input" === l || "option" === l;
        if (m || -1 !== d) {
            h && An(t, null, n, "created");
            let l, b = !1;
            if (y(e)) {
                b = Ua(null, v) && n && n.vnode.props && n.vnode.props.appear;
                const o = e.content.firstChild;
                if (b) {
                    const e = o.getAttribute("class");
                    e && (o.$cls = e),
                    v.beforeEnter(o)
                }
                g(o, e, n),
                t.el = e = o
            }
            if (16 & p && (!c || !c.innerHTML && !c.textContent)) {
                let o = f(e.firstChild, t, e, n, a, r, s);
                for (; o; ) {
                    fo(e, 1) || so();
                    const t = o;
                    o = o.nextSibling,
                    i(t)
                }
            } else if (8 & p) {
                let n = t.children;
                "\n" !== n[0] || "PRE" !== e.tagName && "TEXTAREA" !== e.tagName || (n = n.slice(1)),
                e.textContent !== n && (fo(e, 0) || so(),
                e.textContent = t.children)
            }
            if (c)
                if (m || !s || 48 & d) {
                    const t = e.tagName.includes("-");
                    for (const a in c)
                        (m && (a.endsWith("value") || "indeterminate" === a) || u(a) && !A(a) || "." === a[0] || t) && o(e, a, null, c[a], void 0, n)
                } else if (c.onClick)
                    o(e, "onClick", null, c.onClick, void 0, n);
                else if (4 & d && St(c.style))
                    for (const e in c.style)
                        c.style[e];
            (l = c && c.onVnodeBeforeMount) && Kr(l, n, t),
            h && An(t, null, n, "beforeMount"),
            ((l = c && c.onVnodeMounted) || h || b) && br( () => {
                l && Kr(l, n, t),
                b && v.enter(e),
                h && An(t, null, n, "mounted")
            }
            , a)
        }
        return e.nextSibling
    }
      , f = (e, t, o, s, i, u, c) => {
        c = c || !!t.dynamicChildren;
        const p = t.children
          , f = p.length;
        for (let h = 0; h < f; h++) {
            const t = c ? p[h] : p[h] = Zr(p[h])
              , v = t.type === xr;
            e ? (v && !c && h + 1 < f && Zr(p[h + 1]).type === xr && (l(a(e.data.slice(t.children.length)), o, r(e)),
            e.data = t.children),
            e = d(e, t, s, i, u, c)) : v && !t.children ? l(t.el = a(""), o) : (fo(o, 1) || so(),
            n(null, t, o, null, s, i, io(o), u))
        }
        return e
    }
      , h = (e, t, n, o, a, i) => {
        const {slotScopeIds: u} = t;
        u && (a = a ? a.concat(u) : u);
        const d = s(e)
          , p = f(r(e), t, d, n, o, a, i);
        return p && lo(p) && "]" === p.data ? r(t.anchor = p) : (so(),
        l(t.anchor = c("]"), d, p),
        p)
    }
      , v = (e, t, o, a, l, u) => {
        if (fo(e.parentElement, 1) || so(),
        t.el = null,
        u) {
            const t = m(e);
            for (; ; ) {
                const n = r(e);
                if (!n || n === t)
                    break;
                i(n)
            }
        }
        const c = r(e)
          , d = s(e);
        return i(e),
        n(null, t, d, c, o, a, io(d), l),
        o && (o.vnode.el = t.el,
        pr(o, t.el)),
        c
    }
      , m = (e, t="[", n="]") => {
        let o = 0;
        for (; e; )
            if ((e = r(e)) && lo(e) && (e.data === t && o++,
            e.data === n)) {
                if (0 === o)
                    return r(e);
                o--
            }
        return e
    }
      , g = (e, t, n) => {
        const o = t.parentNode;
        o && o.replaceChild(e, t);
        let a = n;
        for (; a; )
            a.vnode.el === t && (a.vnode.el = a.subTree.el = e),
            a = a.parent
    }
      , y = e => 1 === e.nodeType && "TEMPLATE" === e.tagName;
    return [ (e, t) => {
        if (!t.hasChildNodes())
            return n(null, e, t),
            yn(),
            void (t._vnode = e);
        d(t.firstChild, e, null, null, null),
        yn(),
        t._vnode = e
    }
    , d]
}
const co = "data-allow-mismatch"
  , po = {
    0: "text",
    1: "children",
    2: "class",
    3: "style",
    4: "attribute"
};
function fo(e, t) {
    if (0 === t || 1 === t)
        for (; e && !e.hasAttribute(co); )
            e = e.parentElement;
    const n = e && e.getAttribute(co);
    if (null == n)
        return !1;
    if ("" === n)
        return !0;
    {
        const e = n.split(",");
        return !(0 !== t || !e.includes("children")) || e.includes(po[t])
    }
}
const ho = V().requestIdleCallback || (e => setTimeout(e, 1))
  , vo = V().cancelIdleCallback || (e => clearTimeout(e));
const mo = e => !!e.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
function go(e, t) {
    const {ref: n, props: o, children: a, ce: r} = t.vnode
      , s = jr(e, o, a);
    return s.ref = n,
    s.ce = r,
    delete t.vnode.ce,
    s
}
const yo = e => e.type.__isKeepAlive
  , bo = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(e, {slots: t}) {
        const n = es()
          , o = n.ctx;
        if (!o.renderer)
            return () => {
                const e = t.default && t.default();
                return e && 1 === e.length ? e[0] : e
            }
            ;
        const a = new Map
          , r = new Set;
        let s = null;
        const i = n.suspense
          , {renderer: {p: l, m: u, um: c, o: {createElement: d}}} = o
          , p = d("div");
        function f(e) {
            Co(e),
            c(e, n, i, !0)
        }
        function h(e) {
            a.forEach( (t, n) => {
                const o = vs(t.type);
                o && !e(o) && v(n)
            }
            )
        }
        function v(e) {
            const t = a.get(e);
            !t || s && Rr(t, s) ? s && Co(s) : f(t),
            a.delete(e),
            r.delete(e)
        }
        o.activate = (e, t, n, o, a) => {
            const r = e.component;
            u(e, t, n, 0, i),
            l(r.vnode, e, t, n, r, i, o, e.slotScopeIds, a),
            Da( () => {
                r.isDeactivated = !1,
                r.a && N(r.a);
                const t = e.props && e.props.onVnodeMounted;
                t && Kr(t, r.parent, e)
            }
            , i)
        }
        ,
        o.deactivate = e => {
            const t = e.component;
            Wa(t.m),
            Wa(t.a),
            u(e, p, null, 1, i),
            Da( () => {
                t.da && N(t.da);
                const n = e.props && e.props.onVnodeUnmounted;
                n && Kr(n, t.parent, e),
                t.isDeactivated = !0
            }
            , i)
        }
        ,
        Qa( () => [e.include, e.exclude], ([e,t]) => {
            e && h(t => wo(e, t)),
            t && h(e => !wo(t, e))
        }
        , {
            flush: "post",
            deep: !0
        });
        let m = null;
        const g = () => {
            null != m && (fr(n.subTree.type) ? Da( () => {
                a.set(m, Eo(n.subTree))
            }
            , n.subTree.suspense) : a.set(m, Eo(n.subTree)))
        }
        ;
        return Mo(g),
        Bo(g),
        Io( () => {
            a.forEach(e => {
                const {subTree: t, suspense: o} = n
                  , a = Eo(t);
                if (e.type === a.type && e.key === a.key) {
                    Co(a);
                    const e = a.component.da;
                    return void (e && Da(e, o))
                }
                f(e)
            }
            )
        }
        ),
        () => {
            if (m = null,
            !t.default)
                return s = null;
            const n = t.default()
              , o = n[0];
            if (n.length > 1)
                return s = null,
                n;
            if (!(Lr(o) && (4 & o.shapeFlag || 128 & o.shapeFlag)))
                return s = null,
                o;
            let i = Eo(o);
            if (i.type === kr)
                return s = null,
                i;
            const l = i.type
              , u = vs(mo(i) ? i.type.__asyncResolved || {} : l)
              , {include: c, exclude: d, max: p} = e;
            if (c && (!u || !wo(c, u)) || d && u && wo(d, u))
                return i.shapeFlag &= -257,
                s = i,
                o;
            const f = null == i.key ? l : i.key
              , h = a.get(f);
            return i.el && (i = $r(i),
            128 & o.shapeFlag && (o.ssContent = i)),
            m = f,
            h ? (i.el = h.el,
            i.component = h.component,
            i.transition && Qn(i, i.transition),
            i.shapeFlag |= 512,
            r.delete(f),
            r.add(f)) : (r.add(f),
            p && r.size > parseInt(p, 10) && v(r.values().next().value)),
            i.shapeFlag |= 256,
            s = i,
            fr(o.type) ? o : i
        }
    }
};
function wo(e, t) {
    return v(e) ? e.some(e => wo(e, t)) : w(e) ? e.split(",").includes(t) : "[object RegExp]" === C(e) && (e.lastIndex = 0,
    e.test(t))
}
function _o(e, t) {
    ko(e, "a", t)
}
function xo(e, t) {
    ko(e, "da", t)
}
function ko(e, t, n=Qr) {
    const o = e.__wdc || (e.__wdc = () => {
        let t = n;
        for (; t; ) {
            if (t.isDeactivated)
                return;
            t = t.parent
        }
        return e()
    }
    );
    if (To(t, o, n),
    n) {
        let e = n.parent;
        for (; e && e.parent; )
            yo(e.parent.vnode) && So(o, t, n, e),
            e = e.parent
    }
}
function So(e, t, n, o) {
    const a = To(t, e, o, !0);
    Lo( () => {
        p(o[t], a)
    }
    , n)
}
function Co(e) {
    e.shapeFlag &= -257,
    e.shapeFlag &= -513
}
function Eo(e) {
    return 128 & e.shapeFlag ? e.ssContent : e
}
function To(e, t, n=Qr, o=!1) {
    if (n) {
        const a = n[e] || (n[e] = [])
          , r = t.__weh || (t.__weh = (...o) => {
            Te();
            const a = os(n)
              , r = on(t, n, e, o);
            return a(),
            Ae(),
            r
        }
        );
        return o ? a.unshift(r) : a.push(r),
        r
    }
}
const Ao = e => (t, n=Qr) => {
    ls && "sp" !== e || To(e, (...e) => t(...e), n)
}
  , Oo = Ao("bm")
  , Mo = Ao("m")
  , Po = Ao("bu")
  , Bo = Ao("u")
  , Io = Ao("bum")
  , Lo = Ao("um")
  , Ro = Ao("sp")
  , zo = Ao("rtg")
  , No = Ao("rtc");
function Do(e, t=Qr) {
    To("ec", e, t)
}
const jo = "components";
function Fo(e, t) {
    return Uo(jo, e, !0, t) || e
}
const $o = Symbol.for("v-ndc");
function Vo(e) {
    return w(e) ? Uo(jo, e, !1) || e : e || $o
}
function Ho(e) {
    return Uo("directives", e)
}
function Uo(e, t, n=!0, o=!1) {
    const a = kn || Qr;
    if (a) {
        const n = a.type;
        if (e === jo) {
            const e = vs(n, !1);
            if (e && (e === t || e === P(t) || e === L(P(t))))
                return n
        }
        const r = Zo(a[e] || n[e], t) || Zo(a.appContext[e], t);
        return !r && o ? n : r
    }
}
function Zo(e, t) {
    return e && (e[t] || e[P(t)] || e[L(P(t))])
}
function qo(e, t, n, o) {
    let a;
    const r = n && n[o]
      , s = v(e);
    if (s || w(e)) {
        let n = !1
          , o = !1;
        s && St(e) && (n = !Et(e),
        o = Ct(e),
        e = $e(e)),
        a = new Array(e.length);
        for (let s = 0, i = e.length; s < i; s++)
            a[s] = t(n ? o ? Pt(Mt(e[s])) : Mt(e[s]) : e[s], s, void 0, r && r[s])
    } else if ("number" == typeof e) {
        a = new Array(e);
        for (let n = 0; n < e; n++)
            a[n] = t(n + 1, n, void 0, r && r[n])
    } else if (x(e))
        if (e[Symbol.iterator])
            a = Array.from(e, (e, n) => t(e, n, void 0, r && r[n]));
        else {
            const n = Object.keys(e);
            a = new Array(n.length);
            for (let o = 0, s = n.length; o < s; o++) {
                const s = n[o];
                a[o] = t(e[s], s, o, r && r[o])
            }
        }
    else
        a = [];
    return n && (n[o] = a),
    a
}
function Wo(e, t, n={}, o, a) {
    if (kn.ce || kn.parent && mo(kn.parent) && kn.parent.ce)
        return "default" !== t && (n.name = t),
        Tr(),
        Ir(_r, null, [jr("slot", n, o && o())], 64);
    let r = e[t];
    r && r._c && (r._d = !1),
    Tr();
    const s = r && Go(r(n))
      , i = n.key || s && s.key
      , l = Ir(_r, {
        key: (i && !_(i) ? i : `_${t}`) + (!s && o ? "_fb" : "")
    }, s || (o ? o() : []), s && 1 === e._ ? 64 : -2);
    return !a && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]),
    r && r._c && (r._d = !0),
    l
}
function Go(e) {
    return e.some(e => !Lr(e) || e.type !== kr && !(e.type === _r && !Go(e.children))) ? e : null
}
const Ko = e => e ? rs(e) ? hs(e) : Ko(e.parent) : null
  , Yo = d(Object.create(null), {
    $: e => e,
    $el: e => e.vnode.el,
    $data: e => e.data,
    $props: e => e.props,
    $attrs: e => e.attrs,
    $slots: e => e.slots,
    $refs: e => e.refs,
    $parent: e => Ko(e.parent),
    $root: e => Ko(e.root),
    $host: e => e.ce,
    $emit: e => e.emit,
    $options: e => ua(e),
    $forceUpdate: e => e.f || (e.f = () => {
        hn(e.update)
    }
    ),
    $nextTick: e => e.n || (e.n = fn.bind(e.proxy)),
    $watch: e => tr.bind(e)
})
  , Xo = (e, t) => e !== r && !e.__isScriptSetup && h(e, t)
  , Jo = {
    get({_: e}, t) {
        if ("__v_skip" === t)
            return !0;
        const {ctx: n, setupState: o, data: a, props: s, accessCache: i, type: l, appContext: u} = e;
        let c;
        if ("$" !== t[0]) {
            const l = i[t];
            if (void 0 !== l)
                switch (l) {
                case 1:
                    return o[t];
                case 2:
                    return a[t];
                case 4:
                    return n[t];
                case 3:
                    return s[t]
                }
            else {
                if (Xo(o, t))
                    return i[t] = 1,
                    o[t];
                if (a !== r && h(a, t))
                    return i[t] = 2,
                    a[t];
                if ((c = e.propsOptions[0]) && h(c, t))
                    return i[t] = 3,
                    s[t];
                if (n !== r && h(n, t))
                    return i[t] = 4,
                    n[t];
                ra && (i[t] = 0)
            }
        }
        const d = Yo[t];
        let p, f;
        return d ? ("$attrs" === t && De(e.attrs, 0, ""),
        d(e)) : (p = l.__cssModules) && (p = p[t]) ? p : n !== r && h(n, t) ? (i[t] = 4,
        n[t]) : (f = u.config.globalProperties,
        h(f, t) ? f[t] : void 0)
    },
    set({_: e}, t, n) {
        const {data: o, setupState: a, ctx: s} = e;
        return Xo(a, t) ? (a[t] = n,
        !0) : o !== r && h(o, t) ? (o[t] = n,
        !0) : !h(e.props, t) && (("$" !== t[0] || !(t.slice(1)in e)) && (s[t] = n,
        !0))
    },
    has({_: {data: e, setupState: t, accessCache: n, ctx: o, appContext: a, propsOptions: s}}, i) {
        let l;
        return !!n[i] || e !== r && h(e, i) || Xo(t, i) || (l = s[0]) && h(l, i) || h(o, i) || h(Yo, i) || h(a.config.globalProperties, i)
    },
    defineProperty(e, t, n) {
        return null != n.get ? e._.accessCache[t] = 0 : h(n, "value") && this.set(e, t, n.value, null),
        Reflect.defineProperty(e, t, n)
    }
}
  , Qo = d({}, Jo, {
    get(e, t) {
        if (t !== Symbol.unscopables)
            return Jo.get(e, t, e)
    },
    has: (e, t) => "_" !== t[0] && !H(t)
});
function ea() {
    return na().slots
}
function ta() {
    return na().attrs
}
function na() {
    const e = es();
    return e.setupContext || (e.setupContext = fs(e))
}
function oa(e) {
    return v(e) ? e.reduce( (e, t) => (e[t] = null,
    e), {}) : e
}
function aa(e, t) {
    const n = oa(e);
    for (const o in t) {
        if (o.startsWith("__skip"))
            continue;
        let e = n[o];
        e ? v(e) || b(e) ? e = n[o] = {
            type: e,
            default: t[o]
        } : e.default = t[o] : null === e && (e = n[o] = {
            default: t[o]
        }),
        e && t[`__skip_${o}`] && (e.skipFactory = !0)
    }
    return n
}
let ra = !0;
function sa(e) {
    const t = ua(e)
      , n = e.proxy
      , o = e.ctx;
    ra = !1,
    t.beforeCreate && ia(t.beforeCreate, e, "bc");
    const {data: a, computed: r, methods: s, watch: l, provide: u, inject: c, created: d, beforeMount: p, mounted: f, beforeUpdate: h, updated: m, activated: g, deactivated: y, beforeDestroy: w, beforeUnmount: _, destroyed: k, unmounted: S, render: C, renderTracked: E, renderTriggered: T, errorCaptured: A, serverPrefetch: O, expose: M, inheritAttrs: P, components: B, directives: I, filters: L} = t;
    if (c && function(e, t) {
        v(e) && (e = fa(e));
        for (const n in e) {
            const o = e[n];
            let a;
            a = x(o) ? "default"in o ? xa(o.from || n, o.default, !0) : xa(o.from || n) : xa(o),
            Bt(a) ? Object.defineProperty(t, n, {
                enumerable: !0,
                configurable: !0,
                get: () => a.value,
                set: e => a.value = e
            }) : t[n] = a
        }
    }(c, o, null),
    s)
        for (const i in s) {
            const e = s[i];
            b(e) && (o[i] = e.bind(n))
        }
    if (a) {
        const t = a.call(n, n);
        x(t) && (e.data = bt(t))
    }
    if (ra = !0,
    r)
        for (const v in r) {
            const e = r[v]
              , t = b(e) ? e.bind(n, n) : b(e.get) ? e.get.bind(n, n) : i
              , a = !b(e) && b(e.set) ? e.set.bind(n) : i
              , s = ms({
                get: t,
                set: a
            });
            Object.defineProperty(o, v, {
                enumerable: !0,
                configurable: !0,
                get: () => s.value,
                set: e => s.value = e
            })
        }
    if (l)
        for (const i in l)
            la(l[i], o, n, i);
    if (u) {
        const e = b(u) ? u.call(n) : u;
        Reflect.ownKeys(e).forEach(t => {
            _a(t, e[t])
        }
        )
    }
    function R(e, t) {
        v(t) ? t.forEach(t => e(t.bind(n))) : t && e(t.bind(n))
    }
    if (d && ia(d, e, "c"),
    R(Oo, p),
    R(Mo, f),
    R(Po, h),
    R(Bo, m),
    R(_o, g),
    R(xo, y),
    R(Do, A),
    R(No, E),
    R(zo, T),
    R(Io, _),
    R(Lo, S),
    R(Ro, O),
    v(M))
        if (M.length) {
            const t = e.exposed || (e.exposed = {});
            M.forEach(e => {
                Object.defineProperty(t, e, {
                    get: () => n[e],
                    set: t => n[e] = t
                })
            }
            )
        } else
            e.exposed || (e.exposed = {});
    C && e.render === i && (e.render = C),
    null != P && (e.inheritAttrs = P),
    B && (e.components = B),
    I && (e.directives = I),
    O && oo(e)
}
function ia(e, t, n) {
    on(v(e) ? e.map(e => e.bind(t.proxy)) : e.bind(t.proxy), t, n)
}
function la(e, t, n, o) {
    let a = o.includes(".") ? nr(n, o) : () => n[o];
    if (w(e)) {
        const n = t[e];
        b(n) && Qa(a, n)
    } else if (b(e))
        Qa(a, e.bind(n));
    else if (x(e))
        if (v(e))
            e.forEach(e => la(e, t, n, o));
        else {
            const o = b(e.handler) ? e.handler.bind(n) : t[e.handler];
            b(o) && Qa(a, o, e)
        }
}
function ua(e) {
    const t = e.type
      , {mixins: n, extends: o} = t
      , {mixins: a, optionsCache: r, config: {optionMergeStrategies: s}} = e.appContext
      , i = r.get(t);
    let l;
    return i ? l = i : a.length || n || o ? (l = {},
    a.length && a.forEach(e => ca(l, e, s, !0)),
    ca(l, t, s)) : l = t,
    x(t) && r.set(t, l),
    l
}
function ca(e, t, n, o=!1) {
    const {mixins: a, extends: r} = t;
    r && ca(e, r, n, !0),
    a && a.forEach(t => ca(e, t, n, !0));
    for (const s in t)
        if (o && "expose" === s)
            ;
        else {
            const o = da[s] || n && n[s];
            e[s] = o ? o(e[s], t[s]) : t[s]
        }
    return e
}
const da = {
    data: pa,
    props: ma,
    emits: ma,
    methods: va,
    computed: va,
    beforeCreate: ha,
    created: ha,
    beforeMount: ha,
    mounted: ha,
    beforeUpdate: ha,
    updated: ha,
    beforeDestroy: ha,
    beforeUnmount: ha,
    destroyed: ha,
    unmounted: ha,
    activated: ha,
    deactivated: ha,
    errorCaptured: ha,
    serverPrefetch: ha,
    components: va,
    directives: va,
    watch: function(e, t) {
        if (!e)
            return t;
        if (!t)
            return e;
        const n = d(Object.create(null), e);
        for (const o in t)
            n[o] = ha(e[o], t[o]);
        return n
    },
    provide: pa,
    inject: function(e, t) {
        return va(fa(e), fa(t))
    }
};
function pa(e, t) {
    return t ? e ? function() {
        return d(b(e) ? e.call(this, this) : e, b(t) ? t.call(this, this) : t)
    }
    : t : e
}
function fa(e) {
    if (v(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++)
            t[e[n]] = e[n];
        return t
    }
    return e
}
function ha(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}
function va(e, t) {
    return e ? d(Object.create(null), e, t) : t
}
function ma(e, t) {
    return e ? v(e) && v(t) ? [...new Set([...e, ...t])] : d(Object.create(null), oa(e), oa(null != t ? t : {})) : t
}
function ga() {
    return {
        app: null,
        config: {
            isNativeTag: l,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let ya = 0;
function ba(e, t) {
    return function(n, o=null) {
        b(n) || (n = d({}, n)),
        null == o || x(o) || (o = null);
        const a = ga()
          , r = new WeakSet
          , s = [];
        let i = !1;
        const l = a.app = {
            _uid: ya++,
            _component: n,
            _props: o,
            _container: null,
            _context: a,
            _instance: null,
            version: bs,
            get config() {
                return a.config
            },
            set config(e) {},
            use: (e, ...t) => (r.has(e) || (e && b(e.install) ? (r.add(e),
            e.install(l, ...t)) : b(e) && (r.add(e),
            e(l, ...t))),
            l),
            mixin: e => (a.mixins.includes(e) || a.mixins.push(e),
            l),
            component: (e, t) => t ? (a.components[e] = t,
            l) : a.components[e],
            directive: (e, t) => t ? (a.directives[e] = t,
            l) : a.directives[e],
            mount(r, s, u) {
                if (!i) {
                    const c = l._ceVNode || jr(n, o);
                    return c.appContext = a,
                    !0 === u ? u = "svg" : !1 === u && (u = void 0),
                    s && t ? t(c, r) : e(c, r, u),
                    i = !0,
                    l._container = r,
                    r.__vue_app__ = l,
                    hs(c.component)
                }
            },
            onUnmount(e) {
                s.push(e)
            },
            unmount() {
                i && (on(s, l._instance, 16),
                e(null, l._container),
                delete l._container.__vue_app__)
            },
            provide: (e, t) => (a.provides[e] = t,
            l),
            runWithContext(e) {
                const t = wa;
                wa = l;
                try {
                    return e()
                } finally {
                    wa = t
                }
            }
        };
        return l
    }
}
let wa = null;
function _a(e, t) {
    if (Qr) {
        let n = Qr.provides;
        const o = Qr.parent && Qr.parent.provides;
        o === n && (n = Qr.provides = Object.create(o)),
        n[e] = t
    } else
        ;
}
function xa(e, t, n=!1) {
    const o = Qr || kn;
    if (o || wa) {
        let a = wa ? wa._context.provides : o ? null == o.parent || o.ce ? o.vnode.appContext && o.vnode.appContext.provides : o.parent.provides : void 0;
        if (a && e in a)
            return a[e];
        if (arguments.length > 1)
            return n && b(t) ? t.call(o && o.proxy) : t
    }
}
function ka() {
    return !!(Qr || kn || wa)
}
const Sa = {}
  , Ca = () => Object.create(Sa)
  , Ea = e => Object.getPrototypeOf(e) === Sa;
function Ta(e, t, n, o) {
    const [a,s] = e.propsOptions;
    let i, l = !1;
    if (t)
        for (let r in t) {
            if (A(r))
                continue;
            const u = t[r];
            let c;
            a && h(a, c = P(r)) ? s && s.includes(c) ? (i || (i = {}))[c] = u : n[c] = u : ir(e.emitsOptions, r) || r in o && u === o[r] || (o[r] = u,
            l = !0)
        }
    if (s) {
        const t = At(n)
          , o = i || r;
        for (let r = 0; r < s.length; r++) {
            const i = s[r];
            n[i] = Aa(a, t, i, o[i], e, !h(o, i))
        }
    }
    return l
}
function Aa(e, t, n, o, a, r) {
    const s = e[n];
    if (null != s) {
        const e = h(s, "default");
        if (e && void 0 === o) {
            const e = s.default;
            if (s.type !== Function && !s.skipFactory && b(e)) {
                const {propsDefaults: r} = a;
                if (n in r)
                    o = r[n];
                else {
                    const s = os(a);
                    o = r[n] = e.call(null, t),
                    s()
                }
            } else
                o = e;
            a.ce && a.ce._setProp(n, o)
        }
        s[0] && (r && !e ? o = !1 : !s[1] || "" !== o && o !== I(n) || (o = !0))
    }
    return o
}
const Oa = new WeakMap;
function Ma(e, t, n=!1) {
    const o = n ? Oa : t.propsCache
      , a = o.get(e);
    if (a)
        return a;
    const i = e.props
      , l = {}
      , u = [];
    let c = !1;
    if (!b(e)) {
        const o = e => {
            c = !0;
            const [n,o] = Ma(e, t, !0);
            d(l, n),
            o && u.push(...o)
        }
        ;
        !n && t.mixins.length && t.mixins.forEach(o),
        e.extends && o(e.extends),
        e.mixins && e.mixins.forEach(o)
    }
    if (!i && !c)
        return x(e) && o.set(e, s),
        s;
    if (v(i))
        for (let s = 0; s < i.length; s++) {
            const e = P(i[s]);
            Pa(e) && (l[e] = r)
        }
    else if (i)
        for (const r in i) {
            const e = P(r);
            if (Pa(e)) {
                const t = i[r]
                  , n = l[e] = v(t) || b(t) ? {
                    type: t
                } : d({}, t)
                  , o = n.type;
                let a = !1
                  , s = !0;
                if (v(o))
                    for (let e = 0; e < o.length; ++e) {
                        const t = o[e]
                          , n = b(t) && t.name;
                        if ("Boolean" === n) {
                            a = !0;
                            break
                        }
                        "String" === n && (s = !1)
                    }
                else
                    a = b(o) && "Boolean" === o.name;
                n[0] = a,
                n[1] = s,
                (a || h(n, "default")) && u.push(e)
            }
        }
    const p = [l, u];
    return x(e) && o.set(e, p),
    p
}
function Pa(e) {
    return "$" !== e[0] && !A(e)
}
const Ba = e => "_" === e[0] || "$stable" === e
  , Ia = e => v(e) ? e.map(Zr) : [Zr(e)]
  , La = (e, t, n) => {
    if (t._n)
        return t;
    const o = En( (...e) => Ia(t(...e)), n);
    return o._c = !1,
    o
}
  , Ra = (e, t, n) => {
    const o = e._ctx;
    for (const a in e) {
        if (Ba(a))
            continue;
        const n = e[a];
        if (b(n))
            t[a] = La(0, n, o);
        else if (null != n) {
            const e = Ia(n);
            t[a] = () => e
        }
    }
}
  , za = (e, t) => {
    const n = Ia(t);
    e.slots.default = () => n
}
  , Na = (e, t, n) => {
    for (const o in t)
        !n && Ba(o) || (e[o] = t[o])
}
  , Da = br;
function ja(e) {
    return $a(e)
}
function Fa(e) {
    return $a(e, uo)
}
function $a(e, t) {
    V().__VUE__ = !0;
    const {insert: n, remove: o, patchProp: a, createElement: l, createText: u, createComment: c, setText: d, setElementText: p, parentNode: f, nextSibling: m, setScopeId: g=i, insertStaticContent: y} = e
      , b = (e, t, n, o=null, a=null, r=null, s=void 0, i=null, l=!!t.dynamicChildren) => {
        if (e === t)
            return;
        e && !Rr(e, t) && (o = Y(e),
        Z(e, a, r, !0),
        e = null),
        -2 === t.patchFlag && (l = !1,
        t.dynamicChildren = null);
        const {type: u, ref: c, shapeFlag: d} = t;
        switch (u) {
        case xr:
            w(e, t, n, o);
            break;
        case kr:
            _(e, t, n, o);
            break;
        case Sr:
            null == e && x(t, n, o, s);
            break;
        case _r:
            B(e, t, n, o, a, r, s, i, l);
            break;
        default:
            1 & d ? k(e, t, n, o, a, r, s, i, l) : 6 & d ? L(e, t, n, o, a, r, s, i, l) : (64 & d || 128 & d) && u.process(e, t, n, o, a, r, s, i, l, Q)
        }
        null != c && a ? ao(c, e && e.ref, r, t || e, !t) : null == c && e && null != e.ref && ao(e.ref, null, r, e, !0)
    }
      , w = (e, t, o, a) => {
        if (null == e)
            n(t.el = u(t.children), o, a);
        else {
            const n = t.el = e.el;
            t.children !== e.children && d(n, t.children)
        }
    }
      , _ = (e, t, o, a) => {
        null == e ? n(t.el = c(t.children || ""), o, a) : t.el = e.el
    }
      , x = (e, t, n, o) => {
        [e.el,e.anchor] = y(e.children, t, n, o, e.el, e.anchor)
    }
      , k = (e, t, n, o, a, r, s, i, l) => {
        "svg" === t.type ? s = "svg" : "math" === t.type && (s = "mathml"),
        null == e ? S(t, n, o, a, r, s, i, l) : T(e, t, a, r, s, i, l)
    }
      , S = (e, t, o, r, s, i, u, c) => {
        let d, f;
        const {props: h, shapeFlag: v, transition: m, dirs: g} = e;
        if (d = e.el = l(e.type, i, h && h.is, h),
        8 & v ? p(d, e.children) : 16 & v && E(e.children, d, null, r, s, Va(e, i), u, c),
        g && An(e, null, r, "created"),
        C(d, e, e.scopeId, u, r),
        h) {
            for (const e in h)
                "value" === e || A(e) || a(d, e, null, h[e], i, r);
            "value"in h && a(d, "value", null, h.value, i),
            (f = h.onVnodeBeforeMount) && Kr(f, r, e)
        }
        g && An(e, null, r, "beforeMount");
        const y = Ua(s, m);
        y && m.beforeEnter(d),
        n(d, t, o),
        ((f = h && h.onVnodeMounted) || y || g) && Da( () => {
            f && Kr(f, r, e),
            y && m.enter(d),
            g && An(e, null, r, "mounted")
        }
        , s)
    }
      , C = (e, t, n, o, a) => {
        if (n && g(e, n),
        o)
            for (let r = 0; r < o.length; r++)
                g(e, o[r]);
        if (a) {
            let n = a.subTree;
            if (t === n || fr(n.type) && (n.ssContent === t || n.ssFallback === t)) {
                const t = a.vnode;
                C(e, t, t.scopeId, t.slotScopeIds, a.parent)
            }
        }
    }
      , E = (e, t, n, o, a, r, s, i, l=0) => {
        for (let u = l; u < e.length; u++) {
            const l = e[u] = i ? qr(e[u]) : Zr(e[u]);
            b(null, l, t, n, o, a, r, s, i)
        }
    }
      , T = (e, t, n, o, s, i, l) => {
        const u = t.el = e.el;
        let {patchFlag: c, dynamicChildren: d, dirs: f} = t;
        c |= 16 & e.patchFlag;
        const h = e.props || r
          , v = t.props || r;
        let m;
        if (n && Ha(n, !1),
        (m = v.onVnodeBeforeUpdate) && Kr(m, n, t, e),
        f && An(t, e, n, "beforeUpdate"),
        n && Ha(n, !0),
        (h.innerHTML && null == v.innerHTML || h.textContent && null == v.textContent) && p(u, ""),
        d ? O(e.dynamicChildren, d, u, n, o, Va(t, s), i) : l || F(e, t, u, null, n, o, Va(t, s), i, !1),
        c > 0) {
            if (16 & c)
                M(u, h, v, n, s);
            else if (2 & c && h.class !== v.class && a(u, "class", null, v.class, s),
            4 & c && a(u, "style", h.style, v.style, s),
            8 & c) {
                const e = t.dynamicProps;
                for (let t = 0; t < e.length; t++) {
                    const o = e[t]
                      , r = h[o]
                      , i = v[o];
                    i === r && "value" !== o || a(u, o, r, i, s, n)
                }
            }
            1 & c && e.children !== t.children && p(u, t.children)
        } else
            l || null != d || M(u, h, v, n, s);
        ((m = v.onVnodeUpdated) || f) && Da( () => {
            m && Kr(m, n, t, e),
            f && An(t, e, n, "updated")
        }
        , o)
    }
      , O = (e, t, n, o, a, r, s) => {
        for (let i = 0; i < t.length; i++) {
            const l = e[i]
              , u = t[i]
              , c = l.el && (l.type === _r || !Rr(l, u) || 198 & l.shapeFlag) ? f(l.el) : n;
            b(l, u, c, null, o, a, r, s, !0)
        }
    }
      , M = (e, t, n, o, s) => {
        if (t !== n) {
            if (t !== r)
                for (const r in t)
                    A(r) || r in n || a(e, r, t[r], null, s, o);
            for (const r in n) {
                if (A(r))
                    continue;
                const i = n[r]
                  , l = t[r];
                i !== l && "value" !== r && a(e, r, l, i, s, o)
            }
            "value"in n && a(e, "value", t.value, n.value, s)
        }
    }
      , B = (e, t, o, a, r, s, i, l, c) => {
        const d = t.el = e ? e.el : u("")
          , p = t.anchor = e ? e.anchor : u("");
        let {patchFlag: f, dynamicChildren: h, slotScopeIds: v} = t;
        v && (l = l ? l.concat(v) : v),
        null == e ? (n(d, o, a),
        n(p, o, a),
        E(t.children || [], o, p, r, s, i, l, c)) : f > 0 && 64 & f && h && e.dynamicChildren ? (O(e.dynamicChildren, h, o, r, s, i, l),
        (null != t.key || r && t === r.subTree) && Za(e, t, !0)) : F(e, t, o, p, r, s, i, l, c)
    }
      , L = (e, t, n, o, a, r, s, i, l) => {
        t.slotScopeIds = i,
        null == e ? 512 & t.shapeFlag ? a.ctx.activate(t, n, o, s, l) : R(t, n, o, a, r, s, l) : z(e, t, l)
    }
      , R = (e, t, n, o, a, r, s) => {
        const i = e.component = Jr(e, o, a);
        if (yo(e) && (i.ctx.renderer = Q),
        us(i, !1, s),
        i.asyncDep) {
            if (a && a.registerDep(i, D, s),
            !e.el) {
                const e = i.subTree = jr(kr);
                _(null, e, t, n)
            }
        } else
            D(i, e, t, n, a, r, s)
    }
      , z = (e, t, n) => {
        const o = t.component = e.component;
        if (function(e, t, n) {
            const {props: o, children: a, component: r} = e
              , {props: s, children: i, patchFlag: l} = t
              , u = r.emitsOptions;
            if (t.dirs || t.transition)
                return !0;
            if (!(n && l >= 0))
                return !(!a && !i || i && i.$stable) || o !== s && (o ? !s || dr(o, s, u) : !!s);
            if (1024 & l)
                return !0;
            if (16 & l)
                return o ? dr(o, s, u) : !!s;
            if (8 & l) {
                const e = t.dynamicProps;
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    if (s[n] !== o[n] && !ir(u, n))
                        return !0
                }
            }
            return !1
        }(e, t, n)) {
            if (o.asyncDep && !o.asyncResolved)
                return void j(o, t, n);
            o.next = t,
            o.update()
        } else
            t.el = e.el,
            o.vnode = t
    }
      , D = (e, t, n, o, a, r, s) => {
        const i = () => {
            if (e.isMounted) {
                let {next: t, bu: n, u: o, parent: l, vnode: u} = e;
                {
                    const n = qa(e);
                    if (n)
                        return t && (t.el = u.el,
                        j(e, t, s)),
                        void n.asyncDep.then( () => {
                            e.isUnmounted || i()
                        }
                        )
                }
                let c, d = t;
                Ha(e, !1),
                t ? (t.el = u.el,
                j(e, t, s)) : t = u,
                n && N(n),
                (c = t.props && t.props.onVnodeBeforeUpdate) && Kr(c, l, t, u),
                Ha(e, !0);
                const p = lr(e)
                  , h = e.subTree;
                e.subTree = p,
                b(h, p, f(h.el), Y(h), e, a, r),
                t.el = p.el,
                null === d && pr(e, p.el),
                o && Da(o, a),
                (c = t.props && t.props.onVnodeUpdated) && Da( () => Kr(c, l, t, u), a)
            } else {
                let s;
                const {el: i, props: l} = t
                  , {bm: u, m: c, parent: d, root: p, type: f} = e
                  , h = mo(t);
                if (Ha(e, !1),
                u && N(u),
                !h && (s = l && l.onVnodeBeforeMount) && Kr(s, d, t),
                Ha(e, !0),
                i && te) {
                    const t = () => {
                        e.subTree = lr(e),
                        te(i, e.subTree, e, a, null)
                    }
                    ;
                    h && f.__asyncHydrate ? f.__asyncHydrate(i, e, t) : t()
                } else {
                    p.ce && !1 !== p.ce._def.shadowRoot && p.ce._injectChildStyle(f);
                    const s = e.subTree = lr(e);
                    b(null, s, n, o, e, a, r),
                    t.el = s.el
                }
                if (c && Da(c, a),
                !h && (s = l && l.onVnodeMounted)) {
                    const e = t;
                    Da( () => Kr(s, d, e), a)
                }
                (256 & t.shapeFlag || d && mo(d.vnode) && 256 & d.vnode.shapeFlag) && e.a && Da(e.a, a),
                e.isMounted = !0,
                t = n = o = null
            }
        }
        ;
        e.scope.on();
        const l = e.effect = new pe(i);
        e.scope.off();
        const u = e.update = l.run.bind(l)
          , c = e.job = l.runIfDirty.bind(l);
        c.i = e,
        c.id = e.uid,
        l.scheduler = () => hn(c),
        Ha(e, !0),
        u()
    }
      , j = (e, t, n) => {
        t.component = e;
        const o = e.vnode.props;
        e.vnode = t,
        e.next = null,
        function(e, t, n, o) {
            const {props: a, attrs: r, vnode: {patchFlag: s}} = e
              , i = At(a)
              , [l] = e.propsOptions;
            let u = !1;
            if (!(o || s > 0) || 16 & s) {
                let o;
                Ta(e, t, a, r) && (u = !0);
                for (const r in i)
                    t && (h(t, r) || (o = I(r)) !== r && h(t, o)) || (l ? !n || void 0 === n[r] && void 0 === n[o] || (a[r] = Aa(l, i, r, void 0, e, !0)) : delete a[r]);
                if (r !== i)
                    for (const e in r)
                        t && h(t, e) || (delete r[e],
                        u = !0)
            } else if (8 & s) {
                const n = e.vnode.dynamicProps;
                for (let o = 0; o < n.length; o++) {
                    let s = n[o];
                    if (ir(e.emitsOptions, s))
                        continue;
                    const c = t[s];
                    if (l)
                        if (h(r, s))
                            c !== r[s] && (r[s] = c,
                            u = !0);
                        else {
                            const t = P(s);
                            a[t] = Aa(l, i, t, c, e, !1)
                        }
                    else
                        c !== r[s] && (r[s] = c,
                        u = !0)
                }
            }
            u && je(e.attrs, "set", "")
        }(e, t.props, o, n),
        ( (e, t, n) => {
            const {vnode: o, slots: a} = e;
            let s = !0
              , i = r;
            if (32 & o.shapeFlag) {
                const e = t._;
                e ? n && 1 === e ? s = !1 : Na(a, t, n) : (s = !t.$stable,
                Ra(t, a)),
                i = t
            } else
                t && (za(e, t),
                i = {
                    default: 1
                });
            if (s)
                for (const r in a)
                    Ba(r) || null != i[r] || delete a[r]
        }
        )(e, t.children, n),
        Te(),
        gn(e),
        Ae()
    }
      , F = (e, t, n, o, a, r, s, i, l=!1) => {
        const u = e && e.children
          , c = e ? e.shapeFlag : 0
          , d = t.children
          , {patchFlag: f, shapeFlag: h} = t;
        if (f > 0) {
            if (128 & f)
                return void H(u, d, n, o, a, r, s, i, l);
            if (256 & f)
                return void $(u, d, n, o, a, r, s, i, l)
        }
        8 & h ? (16 & c && K(u, a, r),
        d !== u && p(n, d)) : 16 & c ? 16 & h ? H(u, d, n, o, a, r, s, i, l) : K(u, a, r, !0) : (8 & c && p(n, ""),
        16 & h && E(d, n, o, a, r, s, i, l))
    }
      , $ = (e, t, n, o, a, r, i, l, u) => {
        t = t || s;
        const c = (e = e || s).length
          , d = t.length
          , p = Math.min(c, d);
        let f;
        for (f = 0; f < p; f++) {
            const o = t[f] = u ? qr(t[f]) : Zr(t[f]);
            b(e[f], o, n, null, a, r, i, l, u)
        }
        c > d ? K(e, a, r, !0, !1, p) : E(t, n, o, a, r, i, l, u, p)
    }
      , H = (e, t, n, o, a, r, i, l, u) => {
        let c = 0;
        const d = t.length;
        let p = e.length - 1
          , f = d - 1;
        for (; c <= p && c <= f; ) {
            const o = e[c]
              , s = t[c] = u ? qr(t[c]) : Zr(t[c]);
            if (!Rr(o, s))
                break;
            b(o, s, n, null, a, r, i, l, u),
            c++
        }
        for (; c <= p && c <= f; ) {
            const o = e[p]
              , s = t[f] = u ? qr(t[f]) : Zr(t[f]);
            if (!Rr(o, s))
                break;
            b(o, s, n, null, a, r, i, l, u),
            p--,
            f--
        }
        if (c > p) {
            if (c <= f) {
                const e = f + 1
                  , s = e < d ? t[e].el : o;
                for (; c <= f; )
                    b(null, t[c] = u ? qr(t[c]) : Zr(t[c]), n, s, a, r, i, l, u),
                    c++
            }
        } else if (c > f)
            for (; c <= p; )
                Z(e[c], a, r, !0),
                c++;
        else {
            const h = c
              , v = c
              , m = new Map;
            for (c = v; c <= f; c++) {
                const e = t[c] = u ? qr(t[c]) : Zr(t[c]);
                null != e.key && m.set(e.key, c)
            }
            let g, y = 0;
            const w = f - v + 1;
            let _ = !1
              , x = 0;
            const k = new Array(w);
            for (c = 0; c < w; c++)
                k[c] = 0;
            for (c = h; c <= p; c++) {
                const o = e[c];
                if (y >= w) {
                    Z(o, a, r, !0);
                    continue
                }
                let s;
                if (null != o.key)
                    s = m.get(o.key);
                else
                    for (g = v; g <= f; g++)
                        if (0 === k[g - v] && Rr(o, t[g])) {
                            s = g;
                            break
                        }
                void 0 === s ? Z(o, a, r, !0) : (k[s - v] = c + 1,
                s >= x ? x = s : _ = !0,
                b(o, t[s], n, null, a, r, i, l, u),
                y++)
            }
            const S = _ ? function(e) {
                const t = e.slice()
                  , n = [0];
                let o, a, r, s, i;
                const l = e.length;
                for (o = 0; o < l; o++) {
                    const l = e[o];
                    if (0 !== l) {
                        if (a = n[n.length - 1],
                        e[a] < l) {
                            t[o] = a,
                            n.push(o);
                            continue
                        }
                        for (r = 0,
                        s = n.length - 1; r < s; )
                            i = r + s >> 1,
                            e[n[i]] < l ? r = i + 1 : s = i;
                        l < e[n[r]] && (r > 0 && (t[o] = n[r - 1]),
                        n[r] = o)
                    }
                }
                r = n.length,
                s = n[r - 1];
                for (; r-- > 0; )
                    n[r] = s,
                    s = t[s];
                return n
            }(k) : s;
            for (g = S.length - 1,
            c = w - 1; c >= 0; c--) {
                const e = v + c
                  , s = t[e]
                  , p = e + 1 < d ? t[e + 1].el : o;
                0 === k[c] ? b(null, s, n, p, a, r, i, l, u) : _ && (g < 0 || c !== S[g] ? U(s, n, p, 2) : g--)
            }
        }
    }
      , U = (e, t, a, r, s=null) => {
        const {el: i, type: l, transition: u, children: c, shapeFlag: d} = e;
        if (6 & d)
            return void U(e.component.subTree, t, a, r);
        if (128 & d)
            return void e.suspense.move(t, a, r);
        if (64 & d)
            return void l.move(e, t, a, Q);
        if (l === _r) {
            n(i, t, a);
            for (let e = 0; e < c.length; e++)
                U(c[e], t, a, r);
            return void n(e.anchor, t, a)
        }
        if (l === Sr)
            return void ( ({el: e, anchor: t}, o, a) => {
                let r;
                for (; e && e !== t; )
                    r = m(e),
                    n(e, o, a),
                    e = r;
                n(t, o, a)
            }
            )(e, t, a);
        if (2 !== r && 1 & d && u)
            if (0 === r)
                u.beforeEnter(i),
                n(i, t, a),
                Da( () => u.enter(i), s);
            else {
                const {leave: r, delayLeave: s, afterLeave: l} = u
                  , c = () => {
                    e.ctx.isUnmounted ? o(i) : n(i, t, a)
                }
                  , d = () => {
                    r(i, () => {
                        c(),
                        l && l()
                    }
                    )
                }
                ;
                s ? s(i, c, d) : d()
            }
        else
            n(i, t, a)
    }
      , Z = (e, t, n, o=!1, a=!1) => {
        const {type: r, props: s, ref: i, children: l, dynamicChildren: u, shapeFlag: c, patchFlag: d, dirs: p, cacheIndex: f} = e;
        if (-2 === d && (a = !1),
        null != i && (Te(),
        ao(i, null, n, e, !0),
        Ae()),
        null != f && (t.renderCache[f] = void 0),
        256 & c)
            return void t.ctx.deactivate(e);
        const h = 1 & c && p
          , v = !mo(e);
        let m;
        if (v && (m = s && s.onVnodeBeforeUnmount) && Kr(m, t, e),
        6 & c)
            G(e.component, n, o);
        else {
            if (128 & c)
                return void e.suspense.unmount(n, o);
            h && An(e, null, t, "beforeUnmount"),
            64 & c ? e.type.remove(e, t, n, Q, o) : u && !u.hasOnce && (r !== _r || d > 0 && 64 & d) ? K(u, t, n, !1, !0) : (r === _r && 384 & d || !a && 16 & c) && K(l, t, n),
            o && q(e)
        }
        (v && (m = s && s.onVnodeUnmounted) || h) && Da( () => {
            m && Kr(m, t, e),
            h && An(e, null, t, "unmounted")
        }
        , n)
    }
      , q = e => {
        const {type: t, el: n, anchor: a, transition: r} = e;
        if (t === _r)
            return void W(n, a);
        if (t === Sr)
            return void ( ({el: e, anchor: t}) => {
                let n;
                for (; e && e !== t; )
                    n = m(e),
                    o(e),
                    e = n;
                o(t)
            }
            )(e);
        const s = () => {
            o(n),
            r && !r.persisted && r.afterLeave && r.afterLeave()
        }
        ;
        if (1 & e.shapeFlag && r && !r.persisted) {
            const {leave: t, delayLeave: o} = r
              , a = () => t(n, s);
            o ? o(e.el, s, a) : a()
        } else
            s()
    }
      , W = (e, t) => {
        let n;
        for (; e !== t; )
            n = m(e),
            o(e),
            e = n;
        o(t)
    }
      , G = (e, t, n) => {
        const {bum: o, scope: a, job: r, subTree: s, um: i, m: l, a: u, parent: c, slots: {__: d}} = e;
        Wa(l),
        Wa(u),
        o && N(o),
        c && v(d) && d.forEach(e => {
            c.renderCache[e] = void 0
        }
        ),
        a.stop(),
        r && (r.flags |= 8,
        Z(s, e, t, n)),
        i && Da(i, t),
        Da( () => {
            e.isUnmounted = !0
        }
        , t),
        t && t.pendingBranch && !t.isUnmounted && e.asyncDep && !e.asyncResolved && e.suspenseId === t.pendingId && (t.deps--,
        0 === t.deps && t.resolve())
    }
      , K = (e, t, n, o=!1, a=!1, r=0) => {
        for (let s = r; s < e.length; s++)
            Z(e[s], t, n, o, a)
    }
      , Y = e => {
        if (6 & e.shapeFlag)
            return Y(e.component.subTree);
        if (128 & e.shapeFlag)
            return e.suspense.next();
        const t = m(e.anchor || e.el)
          , n = t && t[On];
        return n ? m(n) : t
    }
    ;
    let X = !1;
    const J = (e, t, n) => {
        null == e ? t._vnode && Z(t._vnode, null, null, !0) : b(t._vnode || null, e, t, null, null, null, n),
        t._vnode = e,
        X || (X = !0,
        gn(),
        yn(),
        X = !1)
    }
      , Q = {
        p: b,
        um: Z,
        m: U,
        r: q,
        mt: R,
        mc: E,
        pc: F,
        pbc: O,
        n: Y,
        o: e
    };
    let ee, te;
    return t && ([ee,te] = t(Q)),
    {
        render: J,
        hydrate: ee,
        createApp: ba(J, ee)
    }
}
function Va({type: e, props: t}, n) {
    return "svg" === n && "foreignObject" === e || "mathml" === n && "annotation-xml" === e && t && t.encoding && t.encoding.includes("html") ? void 0 : n
}
function Ha({effect: e, job: t}, n) {
    n ? (e.flags |= 32,
    t.flags |= 4) : (e.flags &= -33,
    t.flags &= -5)
}
function Ua(e, t) {
    return (!e || e && !e.pendingBranch) && t && !t.persisted
}
function Za(e, t, n=!1) {
    const o = e.children
      , a = t.children;
    if (v(o) && v(a))
        for (let r = 0; r < o.length; r++) {
            const e = o[r];
            let t = a[r];
            1 & t.shapeFlag && !t.dynamicChildren && ((t.patchFlag <= 0 || 32 === t.patchFlag) && (t = a[r] = qr(a[r]),
            t.el = e.el),
            n || -2 === t.patchFlag || Za(e, t)),
            t.type === xr && (t.el = e.el),
            t.type !== kr || t.el || (t.el = e.el)
        }
}
function qa(e) {
    const t = e.subTree.component;
    if (t)
        return t.asyncDep && !t.asyncResolved ? t : qa(t)
}
function Wa(e) {
    if (e)
        for (let t = 0; t < e.length; t++)
            e[t].flags |= 8
}
const Ga = Symbol.for("v-scx")
  , Ka = () => xa(Ga);
function Ya(e, t) {
    return er(e, null, t)
}
function Xa(e, t) {
    return er(e, null, {
        flush: "post"
    })
}
function Ja(e, t) {
    return er(e, null, {
        flush: "sync"
    })
}
function Qa(e, t, n) {
    return er(e, t, n)
}
function er(e, t, n=r) {
    const {immediate: o, deep: a, flush: s, once: l} = n
      , u = d({}, n)
      , c = t && o || !t && "post" !== s;
    let f;
    if (ls)
        if ("sync" === s) {
            const e = Ka();
            f = e.__watcherHandles || (e.__watcherHandles = [])
        } else if (!c) {
            const e = () => {}
            ;
            return e.stop = i,
            e.resume = i,
            e.pause = i,
            e
        }
    const h = Qr;
    u.call = (e, t, n) => on(e, h, t, n);
    let m = !1;
    "post" === s ? u.scheduler = e => {
        Da(e, h && h.suspense)
    }
    : "sync" !== s && (m = !0,
    u.scheduler = (e, t) => {
        t ? e() : hn(e)
    }
    ),
    u.augmentJob = e => {
        t && (e.flags |= 4),
        m && (e.flags |= 2,
        h && (e.id = h.uid,
        e.i = h))
    }
    ;
    const g = function(e, t, n=r) {
        const {immediate: o, deep: a, once: s, scheduler: l, augmentJob: u, call: c} = n
          , d = e => a ? e : Et(e) || !1 === a || 0 === a ? Qt(e, 1) : Qt(e);
        let f, h, m, g, y = !1, w = !1;
        if (Bt(e) ? (h = () => e.value,
        y = Et(e)) : St(e) ? (h = () => d(e),
        y = !0) : v(e) ? (w = !0,
        y = e.some(e => St(e) || Et(e)),
        h = () => e.map(e => Bt(e) ? e.value : St(e) ? d(e) : b(e) ? c ? c(e, 2) : e() : void 0)) : h = b(e) ? t ? c ? () => c(e, 2) : e : () => {
            if (m) {
                Te();
                try {
                    m()
                } finally {
                    Ae()
                }
            }
            const t = Xt;
            Xt = f;
            try {
                return c ? c(e, 3, [g]) : e(g)
            } finally {
                Xt = t
            }
        }
        : i,
        t && a) {
            const e = h
              , t = !0 === a ? 1 / 0 : a;
            h = () => Qt(e(), t)
        }
        const _ = ue()
          , x = () => {
            f.stop(),
            _ && _.active && p(_.effects, f)
        }
        ;
        if (s && t) {
            const e = t;
            t = (...t) => {
                e(...t),
                x()
            }
        }
        let k = w ? new Array(e.length).fill(Kt) : Kt;
        const S = e => {
            if (1 & f.flags && (f.dirty || e))
                if (t) {
                    const e = f.run();
                    if (a || y || (w ? e.some( (e, t) => z(e, k[t])) : z(e, k))) {
                        m && m();
                        const n = Xt;
                        Xt = f;
                        try {
                            const n = [e, k === Kt ? void 0 : w && k[0] === Kt ? [] : k, g];
                            k = e,
                            c ? c(t, 3, n) : t(...n)
                        } finally {
                            Xt = n
                        }
                    }
                } else
                    f.run()
        }
        ;
        return u && u(S),
        f = new pe(h),
        f.scheduler = l ? () => l(S, !1) : S,
        g = e => Jt(e, !1, f),
        m = f.onStop = () => {
            const e = Yt.get(f);
            if (e) {
                if (c)
                    c(e, 4);
                else
                    for (const t of e)
                        t();
                Yt.delete(f)
            }
        }
        ,
        t ? o ? S(!0) : k = f.run() : l ? l(S.bind(null, !0), !0) : f.run(),
        x.pause = f.pause.bind(f),
        x.resume = f.resume.bind(f),
        x.stop = x,
        x
    }(e, t, u);
    return ls && (f ? f.push(g) : c && g()),
    g
}
function tr(e, t, n) {
    const o = this.proxy
      , a = w(e) ? e.includes(".") ? nr(o, e) : () => o[e] : e.bind(o, o);
    let r;
    b(t) ? r = t : (r = t.handler,
    n = t);
    const s = os(this)
      , i = er(a, r.bind(o), n);
    return s(),
    i
}
function nr(e, t) {
    const n = t.split(".");
    return () => {
        let t = e;
        for (let e = 0; e < n.length && t; e++)
            t = t[n[e]];
        return t
    }
}
function or(e, t, n=r) {
    const o = es()
      , a = P(t)
      , s = I(t)
      , i = ar(e, a)
      , l = Vt( (i, l) => {
        let u, c, d = r;
        return Ja( () => {
            const t = e[a];
            z(u, t) && (u = t,
            l())
        }
        ),
        {
            get: () => (i(),
            n.get ? n.get(u) : u),
            set(e) {
                const i = n.set ? n.set(e) : e;
                if (!(z(i, u) || d !== r && z(e, d)))
                    return;
                const p = o.vnode.props;
                p && (t in p || a in p || s in p) && (`onUpdate:${t}`in p || `onUpdate:${a}`in p || `onUpdate:${s}`in p) || (u = e,
                l()),
                o.emit(`update:${t}`, i),
                z(e, i) && z(e, d) && !z(i, c) && l(),
                d = e,
                c = i
            }
        }
    }
    );
    return l[Symbol.iterator] = () => {
        let e = 0;
        return {
            next: () => e < 2 ? {
                value: e++ ? i || r : l,
                done: !1
            } : {
                done: !0
            }
        }
    }
    ,
    l
}
const ar = (e, t) => "modelValue" === t || "model-value" === t ? e.modelModifiers : e[`${t}Modifiers`] || e[`${P(t)}Modifiers`] || e[`${I(t)}Modifiers`];
function rr(e, t, ...n) {
    if (e.isUnmounted)
        return;
    const o = e.vnode.props || r;
    let a = n;
    const s = t.startsWith("update:")
      , i = s && ar(o, t.slice(7));
    let l;
    i && (i.trim && (a = n.map(e => w(e) ? e.trim() : e)),
    i.number && (a = n.map(j)));
    let u = o[l = R(t)] || o[l = R(P(t))];
    !u && s && (u = o[l = R(I(t))]),
    u && on(u, e, 6, a);
    const c = o[l + "Once"];
    if (c) {
        if (e.emitted) {
            if (e.emitted[l])
                return
        } else
            e.emitted = {};
        e.emitted[l] = !0,
        on(c, e, 6, a)
    }
}
function sr(e, t, n=!1) {
    const o = t.emitsCache
      , a = o.get(e);
    if (void 0 !== a)
        return a;
    const r = e.emits;
    let s = {}
      , i = !1;
    if (!b(e)) {
        const o = e => {
            const n = sr(e, t, !0);
            n && (i = !0,
            d(s, n))
        }
        ;
        !n && t.mixins.length && t.mixins.forEach(o),
        e.extends && o(e.extends),
        e.mixins && e.mixins.forEach(o)
    }
    return r || i ? (v(r) ? r.forEach(e => s[e] = null) : d(s, r),
    x(e) && o.set(e, s),
    s) : (x(e) && o.set(e, null),
    null)
}
function ir(e, t) {
    return !(!e || !u(t)) && (t = t.slice(2).replace(/Once$/, ""),
    h(e, t[0].toLowerCase() + t.slice(1)) || h(e, I(t)) || h(e, t))
}
function lr(e) {
    const {type: t, vnode: n, proxy: o, withProxy: a, propsOptions: [r], slots: s, attrs: i, emit: l, render: u, renderCache: d, props: p, data: f, setupState: h, ctx: v, inheritAttrs: m} = e
      , g = Cn(e);
    let y, b;
    try {
        if (4 & n.shapeFlag) {
            const e = a || o
              , t = e;
            y = Zr(u.call(t, e, d, p, h, f, v)),
            b = i
        } else {
            const e = t;
            0,
            y = Zr(e.length > 1 ? e(p, {
                attrs: i,
                slots: s,
                emit: l
            }) : e(p, null)),
            b = t.props ? i : ur(i)
        }
    } catch (_) {
        Cr.length = 0,
        an(_, e, 1),
        y = jr(kr)
    }
    let w = y;
    if (b && !1 !== m) {
        const e = Object.keys(b)
          , {shapeFlag: t} = w;
        e.length && 7 & t && (r && e.some(c) && (b = cr(b, r)),
        w = $r(w, b, !1, !0))
    }
    return n.dirs && (w = $r(w, null, !1, !0),
    w.dirs = w.dirs ? w.dirs.concat(n.dirs) : n.dirs),
    n.transition && Qn(w, n.transition),
    y = w,
    Cn(g),
    y
}
const ur = e => {
    let t;
    for (const n in e)
        ("class" === n || "style" === n || u(n)) && ((t || (t = {}))[n] = e[n]);
    return t
}
  , cr = (e, t) => {
    const n = {};
    for (const o in e)
        c(o) && o.slice(9)in t || (n[o] = e[o]);
    return n
}
;
function dr(e, t, n) {
    const o = Object.keys(t);
    if (o.length !== Object.keys(e).length)
        return !0;
    for (let a = 0; a < o.length; a++) {
        const r = o[a];
        if (t[r] !== e[r] && !ir(n, r))
            return !0
    }
    return !1
}
function pr({vnode: e, parent: t}, n) {
    for (; t; ) {
        const o = t.subTree;
        if (o.suspense && o.suspense.activeBranch === e && (o.el = e.el),
        o !== e)
            break;
        (e = t.vnode).el = n,
        t = t.parent
    }
}
const fr = e => e.__isSuspense;
let hr = 0;
const vr = {
    name: "Suspense",
    __isSuspense: !0,
    process(e, t, n, o, a, r, s, i, l, u) {
        if (null == e)
            !function(e, t, n, o, a, r, s, i, l) {
                const {p: u, o: {createElement: c}} = l
                  , d = c("div")
                  , p = e.suspense = gr(e, a, o, t, d, n, r, s, i, l);
                u(null, p.pendingBranch = e.ssContent, d, null, o, p, r, s),
                p.deps > 0 ? (mr(e, "onPending"),
                mr(e, "onFallback"),
                u(null, e.ssFallback, t, n, o, null, r, s),
                wr(p, e.ssFallback)) : p.resolve(!1, !0)
            }(t, n, o, a, r, s, i, l, u);
        else {
            if (r && r.deps > 0 && !e.suspense.isInFallback)
                return t.suspense = e.suspense,
                t.suspense.vnode = t,
                void (t.el = e.el);
            !function(e, t, n, o, a, r, s, i, {p: l, um: u, o: {createElement: c}}) {
                const d = t.suspense = e.suspense;
                d.vnode = t,
                t.el = e.el;
                const p = t.ssContent
                  , f = t.ssFallback
                  , {activeBranch: h, pendingBranch: v, isInFallback: m, isHydrating: g} = d;
                if (v)
                    d.pendingBranch = p,
                    Rr(p, v) ? (l(v, p, d.hiddenContainer, null, a, d, r, s, i),
                    d.deps <= 0 ? d.resolve() : m && (g || (l(h, f, n, o, a, null, r, s, i),
                    wr(d, f)))) : (d.pendingId = hr++,
                    g ? (d.isHydrating = !1,
                    d.activeBranch = v) : u(v, a, d),
                    d.deps = 0,
                    d.effects.length = 0,
                    d.hiddenContainer = c("div"),
                    m ? (l(null, p, d.hiddenContainer, null, a, d, r, s, i),
                    d.deps <= 0 ? d.resolve() : (l(h, f, n, o, a, null, r, s, i),
                    wr(d, f))) : h && Rr(p, h) ? (l(h, p, n, o, a, d, r, s, i),
                    d.resolve(!0)) : (l(null, p, d.hiddenContainer, null, a, d, r, s, i),
                    d.deps <= 0 && d.resolve()));
                else if (h && Rr(p, h))
                    l(h, p, n, o, a, d, r, s, i),
                    wr(d, p);
                else if (mr(t, "onPending"),
                d.pendingBranch = p,
                512 & p.shapeFlag ? d.pendingId = p.component.suspenseId : d.pendingId = hr++,
                l(null, p, d.hiddenContainer, null, a, d, r, s, i),
                d.deps <= 0)
                    d.resolve();
                else {
                    const {timeout: e, pendingId: t} = d;
                    e > 0 ? setTimeout( () => {
                        d.pendingId === t && d.fallback(f)
                    }
                    , e) : 0 === e && d.fallback(f)
                }
            }(e, t, n, o, a, s, i, l, u)
        }
    },
    hydrate: function(e, t, n, o, a, r, s, i, l) {
        const u = t.suspense = gr(t, o, n, e.parentNode, document.createElement("div"), null, a, r, s, i, !0)
          , c = l(e, u.pendingBranch = t.ssContent, n, u, r, s);
        0 === u.deps && u.resolve(!1, !0);
        return c
    },
    normalize: function(e) {
        const {shapeFlag: t, children: n} = e
          , o = 32 & t;
        e.ssContent = yr(o ? n.default : n),
        e.ssFallback = o ? yr(n.fallback) : jr(kr)
    }
};
function mr(e, t) {
    const n = e.props && e.props[t];
    b(n) && n()
}
function gr(e, t, n, o, a, r, s, i, l, u, c=!1) {
    const {p: d, m: p, um: f, n: h, o: {parentNode: v, remove: m}} = u;
    let g;
    const y = function(e) {
        const t = e.props && e.props.suspensible;
        return null != t && !1 !== t
    }(e);
    y && t && t.pendingBranch && (g = t.pendingId,
    t.deps++);
    const b = e.props ? F(e.props.timeout) : void 0
      , w = r
      , _ = {
        vnode: e,
        parent: t,
        parentComponent: n,
        namespace: s,
        container: o,
        hiddenContainer: a,
        deps: 0,
        pendingId: hr++,
        timeout: "number" == typeof b ? b : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !c,
        isHydrating: c,
        isUnmounted: !1,
        effects: [],
        resolve(e=!1, n=!1) {
            const {vnode: o, activeBranch: a, pendingBranch: s, pendingId: i, effects: l, parentComponent: u, container: c} = _;
            let d = !1;
            _.isHydrating ? _.isHydrating = !1 : e || (d = a && s.transition && "out-in" === s.transition.mode,
            d && (a.transition.afterLeave = () => {
                i === _.pendingId && (p(s, c, r === w ? h(a) : r, 0),
                mn(l))
            }
            ),
            a && (v(a.el) === c && (r = h(a)),
            f(a, u, _, !0)),
            d || p(s, c, r, 0)),
            wr(_, s),
            _.pendingBranch = null,
            _.isInFallback = !1;
            let m = _.parent
              , b = !1;
            for (; m; ) {
                if (m.pendingBranch) {
                    m.effects.push(...l),
                    b = !0;
                    break
                }
                m = m.parent
            }
            b || d || mn(l),
            _.effects = [],
            y && t && t.pendingBranch && g === t.pendingId && (t.deps--,
            0 !== t.deps || n || t.resolve()),
            mr(o, "onResolve")
        },
        fallback(e) {
            if (!_.pendingBranch)
                return;
            const {vnode: t, activeBranch: n, parentComponent: o, container: a, namespace: r} = _;
            mr(t, "onFallback");
            const s = h(n)
              , u = () => {
                _.isInFallback && (d(null, e, a, s, o, null, r, i, l),
                wr(_, e))
            }
              , c = e.transition && "out-in" === e.transition.mode;
            c && (n.transition.afterLeave = u),
            _.isInFallback = !0,
            f(n, o, null, !0),
            c || u()
        },
        move(e, t, n) {
            _.activeBranch && p(_.activeBranch, e, t, n),
            _.container = e
        },
        next: () => _.activeBranch && h(_.activeBranch),
        registerDep(e, t, n) {
            const o = !!_.pendingBranch;
            o && _.deps++;
            const a = e.vnode.el;
            e.asyncDep.catch(t => {
                an(t, e, 0)
            }
            ).then(r => {
                if (e.isUnmounted || _.isUnmounted || _.pendingId !== e.suspenseId)
                    return;
                e.asyncResolved = !0;
                const {vnode: i} = e;
                cs(e, r, !1),
                a && (i.el = a);
                const l = !a && e.subTree.el;
                t(e, i, v(a || e.subTree.el), a ? null : h(e.subTree), _, s, n),
                l && m(l),
                pr(e, i.el),
                o && 0 === --_.deps && _.resolve()
            }
            )
        },
        unmount(e, t) {
            _.isUnmounted = !0,
            _.activeBranch && f(_.activeBranch, n, e, t),
            _.pendingBranch && f(_.pendingBranch, n, e, t)
        }
    };
    return _
}
function yr(e) {
    let t;
    if (b(e)) {
        const n = Or && e._c;
        n && (e._d = !1,
        Tr()),
        e = e(),
        n && (e._d = !0,
        t = Er,
        Ar())
    }
    if (v(e)) {
        const t = function(e) {
            let t;
            for (let n = 0; n < e.length; n++) {
                const o = e[n];
                if (!Lr(o))
                    return;
                if (o.type !== kr || "v-if" === o.children) {
                    if (t)
                        return;
                    t = o
                }
            }
            return t
        }(e);
        e = t
    }
    return e = Zr(e),
    t && !e.dynamicChildren && (e.dynamicChildren = t.filter(t => t !== e)),
    e
}
function br(e, t) {
    t && t.pendingBranch ? v(e) ? t.effects.push(...e) : t.effects.push(e) : mn(e)
}
function wr(e, t) {
    e.activeBranch = t;
    const {vnode: n, parentComponent: o} = e;
    let a = t.el;
    for (; !a && t.component; )
        a = (t = t.component.subTree).el;
    n.el = a,
    o && o.subTree === n && (o.vnode.el = a,
    pr(o, a))
}
const _r = Symbol.for("v-fgt")
  , xr = Symbol.for("v-txt")
  , kr = Symbol.for("v-cmt")
  , Sr = Symbol.for("v-stc")
  , Cr = [];
let Er = null;
function Tr(e=!1) {
    Cr.push(Er = e ? null : [])
}
function Ar() {
    Cr.pop(),
    Er = Cr[Cr.length - 1] || null
}
let Or = 1;
function Mr(e, t=!1) {
    Or += e,
    e < 0 && Er && t && (Er.hasOnce = !0)
}
function Pr(e) {
    return e.dynamicChildren = Or > 0 ? Er || s : null,
    Ar(),
    Or > 0 && Er && Er.push(e),
    e
}
function Br(e, t, n, o, a, r) {
    return Pr(Dr(e, t, n, o, a, r, !0))
}
function Ir(e, t, n, o, a) {
    return Pr(jr(e, t, n, o, a, !0))
}
function Lr(e) {
    return !!e && !0 === e.__v_isVNode
}
function Rr(e, t) {
    return e.type === t.type && e.key === t.key
}
const zr = ({key: e}) => null != e ? e : null
  , Nr = ({ref: e, ref_key: t, ref_for: n}) => ("number" == typeof e && (e = "" + e),
null != e ? w(e) || Bt(e) || b(e) ? {
    i: kn,
    r: e,
    k: t,
    f: !!n
} : e : null);
function Dr(e, t=null, n=null, o=0, a=null, r=(e === _r ? 0 : 1), s=!1, i=!1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && zr(t),
        ref: t && Nr(t),
        scopeId: Sn,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: r,
        patchFlag: o,
        dynamicProps: a,
        dynamicChildren: null,
        appContext: null,
        ctx: kn
    };
    return i ? (Wr(l, n),
    128 & r && e.normalize(l)) : n && (l.shapeFlag |= w(n) ? 8 : 16),
    Or > 0 && !s && Er && (l.patchFlag > 0 || 6 & r) && 32 !== l.patchFlag && Er.push(l),
    l
}
const jr = function(e, t=null, n=null, o=0, a=null, r=!1) {
    e && e !== $o || (e = kr);
    if (Lr(e)) {
        const o = $r(e, t, !0);
        return n && Wr(o, n),
        Or > 0 && !r && Er && (6 & o.shapeFlag ? Er[Er.indexOf(e)] = o : Er.push(o)),
        o.patchFlag = -2,
        o
    }
    s = e,
    b(s) && "__vccOpts"in s && (e = e.__vccOpts);
    var s;
    if (t) {
        t = Fr(t);
        let {class: e, style: n} = t;
        e && !w(e) && (t.class = K(e)),
        x(n) && (Tt(n) && !v(n) && (n = d({}, n)),
        t.style = U(n))
    }
    const i = w(e) ? 1 : fr(e) ? 128 : Mn(e) ? 64 : x(e) ? 4 : b(e) ? 2 : 0;
    return Dr(e, t, n, o, a, i, r, !0)
};
function Fr(e) {
    return e ? Tt(e) || Ea(e) ? d({}, e) : e : null
}
function $r(e, t, n=!1, o=!1) {
    const {props: a, ref: r, patchFlag: s, children: i, transition: l} = e
      , u = t ? Gr(a || {}, t) : a
      , c = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: u,
        key: u && zr(u),
        ref: t && t.ref ? n && r ? v(r) ? r.concat(Nr(t)) : [r, Nr(t)] : Nr(t) : r,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: i,
        target: e.target,
        targetStart: e.targetStart,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== _r ? -1 === s ? 16 : 16 | s : s,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: l,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && $r(e.ssContent),
        ssFallback: e.ssFallback && $r(e.ssFallback),
        el: e.el,
        anchor: e.anchor,
        ctx: e.ctx,
        ce: e.ce
    };
    return l && o && Qn(c, l.clone(c)),
    c
}
function Vr(e=" ", t=0) {
    return jr(xr, null, e, t)
}
function Hr(e, t) {
    const n = jr(Sr, null, e);
    return n.staticCount = t,
    n
}
function Ur(e="", t=!1) {
    return t ? (Tr(),
    Ir(kr, null, e)) : jr(kr, null, e)
}
function Zr(e) {
    return null == e || "boolean" == typeof e ? jr(kr) : v(e) ? jr(_r, null, e.slice()) : Lr(e) ? qr(e) : jr(xr, null, String(e))
}
function qr(e) {
    return null === e.el && -1 !== e.patchFlag || e.memo ? e : $r(e)
}
function Wr(e, t) {
    let n = 0;
    const {shapeFlag: o} = e;
    if (null == t)
        t = null;
    else if (v(t))
        n = 16;
    else if ("object" == typeof t) {
        if (65 & o) {
            const n = t.default;
            return void (n && (n._c && (n._d = !1),
            Wr(e, n()),
            n._c && (n._d = !0)))
        }
        {
            n = 32;
            const o = t._;
            o || Ea(t) ? 3 === o && kn && (1 === kn.slots._ ? t._ = 1 : (t._ = 2,
            e.patchFlag |= 1024)) : t._ctx = kn
        }
    } else
        b(t) ? (t = {
            default: t,
            _ctx: kn
        },
        n = 32) : (t = String(t),
        64 & o ? (n = 16,
        t = [Vr(t)]) : n = 8);
    e.children = t,
    e.shapeFlag |= n
}
function Gr(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const o = e[n];
        for (const e in o)
            if ("class" === e)
                t.class !== o.class && (t.class = K([t.class, o.class]));
            else if ("style" === e)
                t.style = U([t.style, o.style]);
            else if (u(e)) {
                const n = t[e]
                  , a = o[e];
                !a || n === a || v(n) && n.includes(a) || (t[e] = n ? [].concat(n, a) : a)
            } else
                "" !== e && (t[e] = o[e])
    }
    return t
}
function Kr(e, t, n, o=null) {
    on(e, t, 7, [n, o])
}
const Yr = ga();
let Xr = 0;
function Jr(e, t, n) {
    const o = e.type
      , a = (t ? t.appContext : e.appContext) || Yr
      , s = {
        uid: Xr++,
        vnode: e,
        type: o,
        parent: t,
        appContext: a,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        job: null,
        scope: new ie(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: t ? t.provides : Object.create(a.provides),
        ids: t ? t.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: Ma(o, a),
        emitsOptions: sr(o, a),
        emit: null,
        emitted: null,
        propsDefaults: r,
        inheritAttrs: o.inheritAttrs,
        ctx: r,
        data: r,
        props: r,
        attrs: r,
        slots: r,
        refs: r,
        setupState: r,
        setupContext: null,
        suspense: n,
        suspenseId: n ? n.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return s.ctx = {
        _: s
    },
    s.root = t ? t.root : s,
    s.emit = rr.bind(null, s),
    e.ce && e.ce(s),
    s
}
let Qr = null;
const es = () => Qr || kn;
let ts, ns;
{
    const e = V()
      , t = (t, n) => {
        let o;
        return (o = e[t]) || (o = e[t] = []),
        o.push(n),
        e => {
            o.length > 1 ? o.forEach(t => t(e)) : o[0](e)
        }
    }
    ;
    ts = t("__VUE_INSTANCE_SETTERS__", e => Qr = e),
    ns = t("__VUE_SSR_SETTERS__", e => ls = e)
}
const os = e => {
    const t = Qr;
    return ts(e),
    e.scope.on(),
    () => {
        e.scope.off(),
        ts(t)
    }
}
  , as = () => {
    Qr && Qr.scope.off(),
    ts(null)
}
;
function rs(e) {
    return 4 & e.vnode.shapeFlag
}
let ss, is, ls = !1;
function us(e, t=!1, n=!1) {
    t && ns(t);
    const {props: o, children: a} = e.vnode
      , r = rs(e);
    !function(e, t, n, o=!1) {
        const a = {}
          , r = Ca();
        e.propsDefaults = Object.create(null),
        Ta(e, t, a, r);
        for (const s in e.propsOptions[0])
            s in a || (a[s] = void 0);
        n ? e.props = o ? a : wt(a) : e.type.props ? e.props = a : e.props = r,
        e.attrs = r
    }(e, o, r, t),
    ( (e, t, n) => {
        const o = e.slots = Ca();
        if (32 & e.vnode.shapeFlag) {
            const e = t.__;
            e && D(o, "__", e, !0);
            const a = t._;
            a ? (Na(o, t, n),
            n && D(o, "_", a, !0)) : Ra(t, o)
        } else
            t && za(e, t)
    }
    )(e, a, n || t);
    const s = r ? function(e, t) {
        const n = e.type;
        e.accessCache = Object.create(null),
        e.proxy = new Proxy(e.ctx,Jo);
        const {setup: o} = n;
        if (o) {
            Te();
            const n = e.setupContext = o.length > 1 ? fs(e) : null
              , a = os(e)
              , r = nn(o, e, 0, [e.props, n])
              , s = k(r);
            if (Ae(),
            a(),
            !s && !e.sp || mo(e) || oo(e),
            s) {
                if (r.then(as, as),
                t)
                    return r.then(n => {
                        cs(e, n, t)
                    }
                    ).catch(t => {
                        an(t, e, 0)
                    }
                    );
                e.asyncDep = r
            } else
                cs(e, r, t)
        } else
            ds(e, t)
    }(e, t) : void 0;
    return t && ns(!1),
    s
}
function cs(e, t, n) {
    b(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : x(t) && (e.setupState = Ft(t)),
    ds(e, n)
}
function ds(e, t, n) {
    const o = e.type;
    if (!e.render) {
        if (!t && ss && !o.render) {
            const t = o.template || ua(e).template;
            if (t) {
                const {isCustomElement: n, compilerOptions: a} = e.appContext.config
                  , {delimiters: r, compilerOptions: s} = o
                  , i = d(d({
                    isCustomElement: n,
                    delimiters: r
                }, a), s);
                o.render = ss(t, i)
            }
        }
        e.render = o.render || i,
        is && is(e)
    }
    {
        const t = os(e);
        Te();
        try {
            sa(e)
        } finally {
            Ae(),
            t()
        }
    }
}
const ps = {
    get: (e, t) => (De(e, 0, ""),
    e[t])
};
function fs(e) {
    const t = t => {
        e.exposed = t || {}
    }
    ;
    return {
        attrs: new Proxy(e.attrs,ps),
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}
function hs(e) {
    return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Ft(Ot(e.exposed)),{
        get: (t, n) => n in t ? t[n] : n in Yo ? Yo[n](e) : void 0,
        has: (e, t) => t in e || t in Yo
    })) : e.proxy
}
function vs(e, t=!0) {
    return b(e) ? e.displayName || e.name : e.name || t && e.__name
}
const ms = (e, t) => {
    const n = function(e, t, n=!1) {
        let o, a;
        return b(e) ? o = e : (o = e.get,
        a = e.set),
        new Gt(o,a,n)
    }(e, 0, ls);
    return n
}
;
function gs(e, t, n) {
    const o = arguments.length;
    return 2 === o ? x(t) && !v(t) ? Lr(t) ? jr(e, null, [t]) : jr(e, t) : jr(e, null, t) : (o > 3 ? n = Array.prototype.slice.call(arguments, 2) : 3 === o && Lr(n) && (n = [n]),
    jr(e, t, n))
}
function ys(e, t) {
    const n = e.memo;
    if (n.length != t.length)
        return !1;
    for (let o = 0; o < n.length; o++)
        if (z(n[o], t[o]))
            return !1;
    return Or > 0 && Er && Er.push(e),
    !0
}
const bs = "3.5.17"
  , ws = i
  , _s = tn
  , xs = _n
  , ks = function e(t, n) {
    var o, a;
    if (_n = t,
    _n)
        _n.enabled = !0,
        xn.forEach( ({event: e, args: t}) => _n.emit(e, ...t)),
        xn = [];
    else if ("undefined" != typeof window && window.HTMLElement && !(null == (a = null == (o = window.navigator) ? void 0 : o.userAgent) ? void 0 : a.includes("jsdom"))) {
        (n.__VUE_DEVTOOLS_HOOK_REPLAY__ = n.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(t => {
            e(t, n)
        }
        ),
        setTimeout( () => {
            _n || (n.__VUE_DEVTOOLS_HOOK_REPLAY__ = null,
            xn = [])
        }
        , 3e3)
    } else
        xn = []
}
  , Ss = {
    createComponentInstance: Jr,
    setupComponent: us,
    renderComponentRoot: lr,
    setCurrentRenderingInstance: Cn,
    isVNode: Lr,
    normalizeVNode: Zr,
    getComponentPublicInstance: hs,
    ensureValidVNode: Go,
    pushWarningContext: function(e) {
        en.push(e)
    },
    popWarningContext: function() {
        en.pop()
    }
};
/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Cs;
const Es = "undefined" != typeof window && window.trustedTypes;
if (Es)
    try {
        Cs = Es.createPolicy("vue", {
            createHTML: e => e
        })
    } catch (pC) {}
const Ts = Cs ? e => Cs.createHTML(e) : e => e
  , As = "undefined" != typeof document ? document : null
  , Os = As && As.createElement("template")
  , Ms = {
    insert: (e, t, n) => {
        t.insertBefore(e, n || null)
    }
    ,
    remove: e => {
        const t = e.parentNode;
        t && t.removeChild(e)
    }
    ,
    createElement: (e, t, n, o) => {
        const a = "svg" === t ? As.createElementNS("http://www.w3.org/2000/svg", e) : "mathml" === t ? As.createElementNS("http://www.w3.org/1998/Math/MathML", e) : n ? As.createElement(e, {
            is: n
        }) : As.createElement(e);
        return "select" === e && o && null != o.multiple && a.setAttribute("multiple", o.multiple),
        a
    }
    ,
    createText: e => As.createTextNode(e),
    createComment: e => As.createComment(e),
    setText: (e, t) => {
        e.nodeValue = t
    }
    ,
    setElementText: (e, t) => {
        e.textContent = t
    }
    ,
    parentNode: e => e.parentNode,
    nextSibling: e => e.nextSibling,
    querySelector: e => As.querySelector(e),
    setScopeId(e, t) {
        e.setAttribute(t, "")
    },
    insertStaticContent(e, t, n, o, a, r) {
        const s = n ? n.previousSibling : t.lastChild;
        if (a && (a === r || a.nextSibling))
            for (; t.insertBefore(a.cloneNode(!0), n),
            a !== r && (a = a.nextSibling); )
                ;
        else {
            Os.innerHTML = Ts("svg" === o ? `<svg>${e}</svg>` : "mathml" === o ? `<math>${e}</math>` : e);
            const a = Os.content;
            if ("svg" === o || "mathml" === o) {
                const e = a.firstChild;
                for (; e.firstChild; )
                    a.appendChild(e.firstChild);
                a.removeChild(e)
            }
            t.insertBefore(a, n)
        }
        return [s ? s.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
    }
}
  , Ps = "transition"
  , Bs = "animation"
  , Is = Symbol("_vtc")
  , Ls = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
}
  , Rs = d({}, Zn, Ls)
  , zs = (e => (e.displayName = "Transition",
e.props = Rs,
e))( (e, {slots: t}) => gs(Gn, js(e), t))
  , Ns = (e, t=[]) => {
    v(e) ? e.forEach(e => e(...t)) : e && e(...t)
}
  , Ds = e => !!e && (v(e) ? e.some(e => e.length > 1) : e.length > 1);
function js(e) {
    const t = {};
    for (const d in e)
        d in Ls || (t[d] = e[d]);
    if (!1 === e.css)
        return t;
    const {name: n="v", type: o, duration: a, enterFromClass: r=`${n}-enter-from`, enterActiveClass: s=`${n}-enter-active`, enterToClass: i=`${n}-enter-to`, appearFromClass: l=r, appearActiveClass: u=s, appearToClass: c=i, leaveFromClass: p=`${n}-leave-from`, leaveActiveClass: f=`${n}-leave-active`, leaveToClass: h=`${n}-leave-to`} = e
      , v = function(e) {
        if (null == e)
            return null;
        if (x(e))
            return [Fs(e.enter), Fs(e.leave)];
        {
            const t = Fs(e);
            return [t, t]
        }
    }(a)
      , m = v && v[0]
      , g = v && v[1]
      , {onBeforeEnter: y, onEnter: b, onEnterCancelled: w, onLeave: _, onLeaveCancelled: k, onBeforeAppear: S=y, onAppear: C=b, onAppearCancelled: E=w} = t
      , T = (e, t, n, o) => {
        e._enterCancelled = o,
        Vs(e, t ? c : i),
        Vs(e, t ? u : s),
        n && n()
    }
      , A = (e, t) => {
        e._isLeaving = !1,
        Vs(e, p),
        Vs(e, h),
        Vs(e, f),
        t && t()
    }
      , O = e => (t, n) => {
        const a = e ? C : b
          , s = () => T(t, e, n);
        Ns(a, [t, s]),
        Hs( () => {
            Vs(t, e ? l : r),
            $s(t, e ? c : i),
            Ds(a) || Zs(t, o, m, s)
        }
        )
    }
    ;
    return d(t, {
        onBeforeEnter(e) {
            Ns(y, [e]),
            $s(e, r),
            $s(e, s)
        },
        onBeforeAppear(e) {
            Ns(S, [e]),
            $s(e, l),
            $s(e, u)
        },
        onEnter: O(!1),
        onAppear: O(!0),
        onLeave(e, t) {
            e._isLeaving = !0;
            const n = () => A(e, t);
            $s(e, p),
            e._enterCancelled ? ($s(e, f),
            Ks()) : (Ks(),
            $s(e, f)),
            Hs( () => {
                e._isLeaving && (Vs(e, p),
                $s(e, h),
                Ds(_) || Zs(e, o, g, n))
            }
            ),
            Ns(_, [e, n])
        },
        onEnterCancelled(e) {
            T(e, !1, void 0, !0),
            Ns(w, [e])
        },
        onAppearCancelled(e) {
            T(e, !0, void 0, !0),
            Ns(E, [e])
        },
        onLeaveCancelled(e) {
            A(e),
            Ns(k, [e])
        }
    })
}
function Fs(e) {
    return F(e)
}
function $s(e, t) {
    t.split(/\s+/).forEach(t => t && e.classList.add(t)),
    (e[Is] || (e[Is] = new Set)).add(t)
}
function Vs(e, t) {
    t.split(/\s+/).forEach(t => t && e.classList.remove(t));
    const n = e[Is];
    n && (n.delete(t),
    n.size || (e[Is] = void 0))
}
function Hs(e) {
    requestAnimationFrame( () => {
        requestAnimationFrame(e)
    }
    )
}
let Us = 0;
function Zs(e, t, n, o) {
    const a = e._endId = ++Us
      , r = () => {
        a === e._endId && o()
    }
    ;
    if (null != n)
        return setTimeout(r, n);
    const {type: s, timeout: i, propCount: l} = qs(e, t);
    if (!s)
        return o();
    const u = s + "end";
    let c = 0;
    const d = () => {
        e.removeEventListener(u, p),
        r()
    }
      , p = t => {
        t.target === e && ++c >= l && d()
    }
    ;
    setTimeout( () => {
        c < l && d()
    }
    , i + 1),
    e.addEventListener(u, p)
}
function qs(e, t) {
    const n = window.getComputedStyle(e)
      , o = e => (n[e] || "").split(", ")
      , a = o(`${Ps}Delay`)
      , r = o(`${Ps}Duration`)
      , s = Ws(a, r)
      , i = o(`${Bs}Delay`)
      , l = o(`${Bs}Duration`)
      , u = Ws(i, l);
    let c = null
      , d = 0
      , p = 0;
    t === Ps ? s > 0 && (c = Ps,
    d = s,
    p = r.length) : t === Bs ? u > 0 && (c = Bs,
    d = u,
    p = l.length) : (d = Math.max(s, u),
    c = d > 0 ? s > u ? Ps : Bs : null,
    p = c ? c === Ps ? r.length : l.length : 0);
    return {
        type: c,
        timeout: d,
        propCount: p,
        hasTransform: c === Ps && /\b(transform|all)(,|$)/.test(o(`${Ps}Property`).toString())
    }
}
function Ws(e, t) {
    for (; e.length < t.length; )
        e = e.concat(e);
    return Math.max(...t.map( (t, n) => Gs(t) + Gs(e[n])))
}
function Gs(e) {
    return "auto" === e ? 0 : 1e3 * Number(e.slice(0, -1).replace(",", "."))
}
function Ks() {
    return document.body.offsetHeight
}
const Ys = Symbol("_vod")
  , Xs = Symbol("_vsh")
  , Js = {
    beforeMount(e, {value: t}, {transition: n}) {
        e[Ys] = "none" === e.style.display ? "" : e.style.display,
        n && t ? n.beforeEnter(e) : Qs(e, t)
    },
    mounted(e, {value: t}, {transition: n}) {
        n && t && n.enter(e)
    },
    updated(e, {value: t, oldValue: n}, {transition: o}) {
        !t != !n && (o ? t ? (o.beforeEnter(e),
        Qs(e, !0),
        o.enter(e)) : o.leave(e, () => {
            Qs(e, !1)
        }
        ) : Qs(e, t))
    },
    beforeUnmount(e, {value: t}) {
        Qs(e, t)
    }
};
function Qs(e, t) {
    e.style.display = t ? e[Ys] : "none",
    e[Xs] = !t
}
const ei = Symbol("");
function ti(e, t) {
    if (128 & e.shapeFlag) {
        const n = e.suspense;
        e = n.activeBranch,
        n.pendingBranch && !n.isHydrating && n.effects.push( () => {
            ti(n.activeBranch, t)
        }
        )
    }
    for (; e.component; )
        e = e.component.subTree;
    if (1 & e.shapeFlag && e.el)
        ni(e.el, t);
    else if (e.type === _r)
        e.children.forEach(e => ti(e, t));
    else if (e.type === Sr) {
        let {el: n, anchor: o} = e;
        for (; n && (ni(n, t),
        n !== o); )
            n = n.nextSibling
    }
}
function ni(e, t) {
    if (1 === e.nodeType) {
        const n = e.style;
        let o = "";
        for (const e in t)
            n.setProperty(`--${e}`, t[e]),
            o += `--${e}: ${t[e]};`;
        n[ei] = o
    }
}
const oi = /(^|;)\s*display\s*:/;
const ai = /\s*!important$/;
function ri(e, t, n) {
    if (v(n))
        n.forEach(n => ri(e, t, n));
    else if (null == n && (n = ""),
    t.startsWith("--"))
        e.setProperty(t, n);
    else {
        const o = function(e, t) {
            const n = ii[t];
            if (n)
                return n;
            let o = P(t);
            if ("filter" !== o && o in e)
                return ii[t] = o;
            o = L(o);
            for (let a = 0; a < si.length; a++) {
                const n = si[a] + o;
                if (n in e)
                    return ii[t] = n
            }
            return t
        }(e, t);
        ai.test(n) ? e.setProperty(I(o), n.replace(ai, ""), "important") : e[o] = n
    }
}
const si = ["Webkit", "Moz", "ms"]
  , ii = {};
const li = "http://www.w3.org/1999/xlink";
function ui(e, t, n, o, a, r=X(t)) {
    o && t.startsWith("xlink:") ? null == n ? e.removeAttributeNS(li, t.slice(6, t.length)) : e.setAttributeNS(li, t, n) : null == n || r && !J(n) ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : _(n) ? String(n) : n)
}
function ci(e, t, n, o, a) {
    if ("innerHTML" === t || "textContent" === t)
        return void (null != n && (e[t] = "innerHTML" === t ? Ts(n) : n));
    const r = e.tagName;
    if ("value" === t && "PROGRESS" !== r && !r.includes("-")) {
        const o = "OPTION" === r ? e.getAttribute("value") || "" : e.value
          , a = null == n ? "checkbox" === e.type ? "on" : "" : String(n);
        return o === a && "_value"in e || (e.value = a),
        null == n && e.removeAttribute(t),
        void (e._value = n)
    }
    let s = !1;
    if ("" === n || null == n) {
        const o = typeof e[t];
        "boolean" === o ? n = J(n) : null == n && "string" === o ? (n = "",
        s = !0) : "number" === o && (n = 0,
        s = !0)
    }
    try {
        e[t] = n
    } catch (pC) {}
    s && e.removeAttribute(a || t)
}
function di(e, t, n, o) {
    e.addEventListener(t, n, o)
}
const pi = Symbol("_vei");
function fi(e, t, n, o, a=null) {
    const r = e[pi] || (e[pi] = {})
      , s = r[t];
    if (o && s)
        s.value = o;
    else {
        const [n,i] = function(e) {
            let t;
            if (hi.test(e)) {
                let n;
                for (t = {}; n = e.match(hi); )
                    e = e.slice(0, e.length - n[0].length),
                    t[n[0].toLowerCase()] = !0
            }
            const n = ":" === e[2] ? e.slice(3) : I(e.slice(2));
            return [n, t]
        }(t);
        if (o) {
            const s = r[t] = function(e, t) {
                const n = e => {
                    if (e._vts) {
                        if (e._vts <= n.attached)
                            return
                    } else
                        e._vts = Date.now();
                    on(function(e, t) {
                        if (v(t)) {
                            const n = e.stopImmediatePropagation;
                            return e.stopImmediatePropagation = () => {
                                n.call(e),
                                e._stopped = !0
                            }
                            ,
                            t.map(e => t => !t._stopped && e && e(t))
                        }
                        return t
                    }(e, n.value), t, 5, [e])
                }
                ;
                return n.value = e,
                n.attached = gi(),
                n
            }(o, a);
            di(e, n, s, i)
        } else
            s && (!function(e, t, n, o) {
                e.removeEventListener(t, n, o)
            }(e, n, s, i),
            r[t] = void 0)
    }
}
const hi = /(?:Once|Passive|Capture)$/;
let vi = 0;
const mi = Promise.resolve()
  , gi = () => vi || (mi.then( () => vi = 0),
vi = Date.now());
const yi = e => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123;
const bi = {};
/*! #__NO_SIDE_EFFECTS__ */
function wi(e, t, n) {
    const o = to(e, t);
    E(o) && d(o, t);
    class a extends xi {
        constructor(e) {
            super(o, e, n)
        }
    }
    return a.def = o,
    a
}
/*! #__NO_SIDE_EFFECTS__ */
const _i = "undefined" != typeof HTMLElement ? HTMLElement : class {
}
;
class xi extends _i {
    constructor(e, t={}, n=rl) {
        super(),
        this._def = e,
        this._props = t,
        this._createApp = n,
        this._isVueCE = !0,
        this._instance = null,
        this._app = null,
        this._nonce = this._def.nonce,
        this._connected = !1,
        this._resolved = !1,
        this._numberProps = null,
        this._styleChildren = new WeakSet,
        this._ob = null,
        this.shadowRoot && n !== rl ? this._root = this.shadowRoot : !1 !== e.shadowRoot ? (this.attachShadow({
            mode: "open"
        }),
        this._root = this.shadowRoot) : this._root = this
    }
    connectedCallback() {
        if (!this.isConnected)
            return;
        this.shadowRoot || this._resolved || this._parseSlots(),
        this._connected = !0;
        let e = this;
        for (; e = e && (e.parentNode || e.host); )
            if (e instanceof xi) {
                this._parent = e;
                break
            }
        this._instance || (this._resolved ? this._mount(this._def) : e && e._pendingResolve ? this._pendingResolve = e._pendingResolve.then( () => {
            this._pendingResolve = void 0,
            this._resolveDef()
        }
        ) : this._resolveDef())
    }
    _setParent(e=this._parent) {
        e && (this._instance.parent = e._instance,
        this._inheritParentContext(e))
    }
    _inheritParentContext(e=this._parent) {
        e && this._app && Object.setPrototypeOf(this._app._context.provides, e._instance.provides)
    }
    disconnectedCallback() {
        this._connected = !1,
        fn( () => {
            this._connected || (this._ob && (this._ob.disconnect(),
            this._ob = null),
            this._app && this._app.unmount(),
            this._instance && (this._instance.ce = void 0),
            this._app = this._instance = null)
        }
        )
    }
    _resolveDef() {
        if (this._pendingResolve)
            return;
        for (let n = 0; n < this.attributes.length; n++)
            this._setAttr(this.attributes[n].name);
        this._ob = new MutationObserver(e => {
            for (const t of e)
                this._setAttr(t.attributeName)
        }
        ),
        this._ob.observe(this, {
            attributes: !0
        });
        const e = (e, t=!1) => {
            this._resolved = !0,
            this._pendingResolve = void 0;
            const {props: n, styles: o} = e;
            let a;
            if (n && !v(n))
                for (const r in n) {
                    const e = n[r];
                    (e === Number || e && e.type === Number) && (r in this._props && (this._props[r] = F(this._props[r])),
                    (a || (a = Object.create(null)))[P(r)] = !0)
                }
            this._numberProps = a,
            this._resolveProps(e),
            this.shadowRoot && this._applyStyles(o),
            this._mount(e)
        }
          , t = this._def.__asyncLoader;
        t ? this._pendingResolve = t().then(t => {
            t.configureApp = this._def.configureApp,
            e(this._def = t, !0)
        }
        ) : e(this._def)
    }
    _mount(e) {
        this._app = this._createApp(e),
        this._inheritParentContext(),
        e.configureApp && e.configureApp(this._app),
        this._app._ceVNode = this._createVNode(),
        this._app.mount(this._root);
        const t = this._instance && this._instance.exposed;
        if (t)
            for (const n in t)
                h(this, n) || Object.defineProperty(this, n, {
                    get: () => Nt(t[n])
                })
    }
    _resolveProps(e) {
        const {props: t} = e
          , n = v(t) ? t : Object.keys(t || {});
        for (const o of Object.keys(this))
            "_" !== o[0] && n.includes(o) && this._setProp(o, this[o]);
        for (const o of n.map(P))
            Object.defineProperty(this, o, {
                get() {
                    return this._getProp(o)
                },
                set(e) {
                    this._setProp(o, e, !0, !0)
                }
            })
    }
    _setAttr(e) {
        if (e.startsWith("data-v-"))
            return;
        const t = this.hasAttribute(e);
        let n = t ? this.getAttribute(e) : bi;
        const o = P(e);
        t && this._numberProps && this._numberProps[o] && (n = F(n)),
        this._setProp(o, n, !1, !0)
    }
    _getProp(e) {
        return this._props[e]
    }
    _setProp(e, t, n=!0, o=!1) {
        if (t !== this._props[e] && (t === bi ? delete this._props[e] : (this._props[e] = t,
        "key" === e && this._app && (this._app._ceVNode.key = t)),
        o && this._instance && this._update(),
        n)) {
            const n = this._ob;
            n && n.disconnect(),
            !0 === t ? this.setAttribute(I(e), "") : "string" == typeof t || "number" == typeof t ? this.setAttribute(I(e), t + "") : t || this.removeAttribute(I(e)),
            n && n.observe(this, {
                attributes: !0
            })
        }
    }
    _update() {
        const e = this._createVNode();
        this._app && (e.appContext = this._app._context),
        al(e, this._root)
    }
    _createVNode() {
        const e = {};
        this.shadowRoot || (e.onVnodeMounted = e.onVnodeUpdated = this._renderSlots.bind(this));
        const t = jr(this._def, d(e, this._props));
        return this._instance || (t.ce = e => {
            this._instance = e,
            e.ce = this,
            e.isCE = !0;
            const t = (e, t) => {
                this.dispatchEvent(new CustomEvent(e,E(t[0]) ? d({
                    detail: t
                }, t[0]) : {
                    detail: t
                }))
            }
            ;
            e.emit = (e, ...n) => {
                t(e, n),
                I(e) !== e && t(I(e), n)
            }
            ,
            this._setParent()
        }
        ),
        t
    }
    _applyStyles(e, t) {
        if (!e)
            return;
        if (t) {
            if (t === this._def || this._styleChildren.has(t))
                return;
            this._styleChildren.add(t)
        }
        const n = this._nonce;
        for (let o = e.length - 1; o >= 0; o--) {
            const t = document.createElement("style");
            n && t.setAttribute("nonce", n),
            t.textContent = e[o],
            this.shadowRoot.prepend(t)
        }
    }
    _parseSlots() {
        const e = this._slots = {};
        let t;
        for (; t = this.firstChild; ) {
            const n = 1 === t.nodeType && t.getAttribute("slot") || "default";
            (e[n] || (e[n] = [])).push(t),
            this.removeChild(t)
        }
    }
    _renderSlots() {
        const e = (this._teleportTarget || this).querySelectorAll("slot")
          , t = this._instance.type.__scopeId;
        for (let n = 0; n < e.length; n++) {
            const o = e[n]
              , a = o.getAttribute("name") || "default"
              , r = this._slots[a]
              , s = o.parentNode;
            if (r)
                for (const e of r) {
                    if (t && 1 === e.nodeType) {
                        const n = t + "-s"
                          , o = document.createTreeWalker(e, 1);
                        let a;
                        for (e.setAttribute(n, ""); a = o.nextNode(); )
                            a.setAttribute(n, "")
                    }
                    s.insertBefore(e, o)
                }
            else
                for (; o.firstChild; )
                    s.insertBefore(o.firstChild, o);
            s.removeChild(o)
        }
    }
    _injectChildStyle(e) {
        this._applyStyles(e.styles, e)
    }
    _removeChildStyle(e) {}
}
function ki(e) {
    const t = es()
      , n = t && t.ce;
    return n || null
}
const Si = new WeakMap
  , Ci = new WeakMap
  , Ei = Symbol("_moveCb")
  , Ti = Symbol("_enterCb")
  , Ai = (e => (delete e.props.mode,
e))({
    name: "TransitionGroup",
    props: d({}, Rs, {
        tag: String,
        moveClass: String
    }),
    setup(e, {slots: t}) {
        const n = es()
          , o = Hn();
        let a, r;
        return Bo( () => {
            if (!a.length)
                return;
            const t = e.moveClass || `${e.name || "v"}-move`;
            if (!function(e, t, n) {
                const o = e.cloneNode()
                  , a = e[Is];
                a && a.forEach(e => {
                    e.split(/\s+/).forEach(e => e && o.classList.remove(e))
                }
                );
                n.split(/\s+/).forEach(e => e && o.classList.add(e)),
                o.style.display = "none";
                const r = 1 === t.nodeType ? t : t.parentNode;
                r.appendChild(o);
                const {hasTransform: s} = qs(o);
                return r.removeChild(o),
                s
            }(a[0].el, n.vnode.el, t))
                return void (a = []);
            a.forEach(Mi),
            a.forEach(Pi);
            const o = a.filter(Bi);
            Ks(),
            o.forEach(e => {
                const n = e.el
                  , o = n.style;
                $s(n, t),
                o.transform = o.webkitTransform = o.transitionDuration = "";
                const a = n[Ei] = e => {
                    e && e.target !== n || e && !/transform$/.test(e.propertyName) || (n.removeEventListener("transitionend", a),
                    n[Ei] = null,
                    Vs(n, t))
                }
                ;
                n.addEventListener("transitionend", a)
            }
            ),
            a = []
        }
        ),
        () => {
            const s = At(e)
              , i = js(s);
            let l = s.tag || _r;
            if (a = [],
            r)
                for (let e = 0; e < r.length; e++) {
                    const t = r[e];
                    t.el && t.el instanceof Element && (a.push(t),
                    Qn(t, Yn(t, i, o, n)),
                    Si.set(t, t.el.getBoundingClientRect()))
                }
            r = t.default ? eo(t.default()) : [];
            for (let e = 0; e < r.length; e++) {
                const t = r[e];
                null != t.key && Qn(t, Yn(t, i, o, n))
            }
            return jr(l, null, r)
        }
    }
})
  , Oi = Ai;
function Mi(e) {
    const t = e.el;
    t[Ei] && t[Ei](),
    t[Ti] && t[Ti]()
}
function Pi(e) {
    Ci.set(e, e.el.getBoundingClientRect())
}
function Bi(e) {
    const t = Si.get(e)
      , n = Ci.get(e)
      , o = t.left - n.left
      , a = t.top - n.top;
    if (o || a) {
        const t = e.el.style;
        return t.transform = t.webkitTransform = `translate(${o}px,${a}px)`,
        t.transitionDuration = "0s",
        e
    }
}
const Ii = e => {
    const t = e.props["onUpdate:modelValue"] || !1;
    return v(t) ? e => N(t, e) : t
}
;
function Li(e) {
    e.target.composing = !0
}
function Ri(e) {
    const t = e.target;
    t.composing && (t.composing = !1,
    t.dispatchEvent(new Event("input")))
}
const zi = Symbol("_assign")
  , Ni = {
    created(e, {modifiers: {lazy: t, trim: n, number: o}}, a) {
        e[zi] = Ii(a);
        const r = o || a.props && "number" === a.props.type;
        di(e, t ? "change" : "input", t => {
            if (t.target.composing)
                return;
            let o = e.value;
            n && (o = o.trim()),
            r && (o = j(o)),
            e[zi](o)
        }
        ),
        n && di(e, "change", () => {
            e.value = e.value.trim()
        }
        ),
        t || (di(e, "compositionstart", Li),
        di(e, "compositionend", Ri),
        di(e, "change", Ri))
    },
    mounted(e, {value: t}) {
        e.value = null == t ? "" : t
    },
    beforeUpdate(e, {value: t, oldValue: n, modifiers: {lazy: o, trim: a, number: r}}, s) {
        if (e[zi] = Ii(s),
        e.composing)
            return;
        const i = null == t ? "" : t;
        if ((!r && "number" !== e.type || /^0\d/.test(e.value) ? e.value : j(e.value)) !== i) {
            if (document.activeElement === e && "range" !== e.type) {
                if (o && t === n)
                    return;
                if (a && e.value.trim() === i)
                    return
            }
            e.value = i
        }
    }
}
  , Di = {
    deep: !0,
    created(e, t, n) {
        e[zi] = Ii(n),
        di(e, "change", () => {
            const t = e._modelValue
              , n = Hi(e)
              , o = e.checked
              , a = e[zi];
            if (v(t)) {
                const e = ee(t, n)
                  , r = -1 !== e;
                if (o && !r)
                    a(t.concat(n));
                else if (!o && r) {
                    const n = [...t];
                    n.splice(e, 1),
                    a(n)
                }
            } else if (g(t)) {
                const e = new Set(t);
                o ? e.add(n) : e.delete(n),
                a(e)
            } else
                a(Ui(e, o))
        }
        )
    },
    mounted: ji,
    beforeUpdate(e, t, n) {
        e[zi] = Ii(n),
        ji(e, t, n)
    }
};
function ji(e, {value: t, oldValue: n}, o) {
    let a;
    if (e._modelValue = t,
    v(t))
        a = ee(t, o.props.value) > -1;
    else if (g(t))
        a = t.has(o.props.value);
    else {
        if (t === n)
            return;
        a = Q(t, Ui(e, !0))
    }
    e.checked !== a && (e.checked = a)
}
const Fi = {
    created(e, {value: t}, n) {
        e.checked = Q(t, n.props.value),
        e[zi] = Ii(n),
        di(e, "change", () => {
            e[zi](Hi(e))
        }
        )
    },
    beforeUpdate(e, {value: t, oldValue: n}, o) {
        e[zi] = Ii(o),
        t !== n && (e.checked = Q(t, o.props.value))
    }
}
  , $i = {
    deep: !0,
    created(e, {value: t, modifiers: {number: n}}, o) {
        const a = g(t);
        di(e, "change", () => {
            const t = Array.prototype.filter.call(e.options, e => e.selected).map(e => n ? j(Hi(e)) : Hi(e));
            e[zi](e.multiple ? a ? new Set(t) : t : t[0]),
            e._assigning = !0,
            fn( () => {
                e._assigning = !1
            }
            )
        }
        ),
        e[zi] = Ii(o)
    },
    mounted(e, {value: t}) {
        Vi(e, t)
    },
    beforeUpdate(e, t, n) {
        e[zi] = Ii(n)
    },
    updated(e, {value: t}) {
        e._assigning || Vi(e, t)
    }
};
function Vi(e, t) {
    const n = e.multiple
      , o = v(t);
    if (!n || o || g(t)) {
        for (let a = 0, r = e.options.length; a < r; a++) {
            const r = e.options[a]
              , s = Hi(r);
            if (n)
                if (o) {
                    const e = typeof s;
                    r.selected = "string" === e || "number" === e ? t.some(e => String(e) === String(s)) : ee(t, s) > -1
                } else
                    r.selected = t.has(s);
            else if (Q(Hi(r), t))
                return void (e.selectedIndex !== a && (e.selectedIndex = a))
        }
        n || -1 === e.selectedIndex || (e.selectedIndex = -1)
    }
}
function Hi(e) {
    return "_value"in e ? e._value : e.value
}
function Ui(e, t) {
    const n = t ? "_trueValue" : "_falseValue";
    return n in e ? e[n] : t
}
const Zi = {
    created(e, t, n) {
        Wi(e, t, n, null, "created")
    },
    mounted(e, t, n) {
        Wi(e, t, n, null, "mounted")
    },
    beforeUpdate(e, t, n, o) {
        Wi(e, t, n, o, "beforeUpdate")
    },
    updated(e, t, n, o) {
        Wi(e, t, n, o, "updated")
    }
};
function qi(e, t) {
    switch (e) {
    case "SELECT":
        return $i;
    case "TEXTAREA":
        return Ni;
    default:
        switch (t) {
        case "checkbox":
            return Di;
        case "radio":
            return Fi;
        default:
            return Ni
        }
    }
}
function Wi(e, t, n, o, a) {
    const r = qi(e.tagName, n.props && n.props.type)[a];
    r && r(e, t, n, o)
}
const Gi = ["ctrl", "shift", "alt", "meta"]
  , Ki = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => "button"in e && 0 !== e.button,
    middle: e => "button"in e && 1 !== e.button,
    right: e => "button"in e && 2 !== e.button,
    exact: (e, t) => Gi.some(n => e[`${n}Key`] && !t.includes(n))
}
  , Yi = (e, t) => {
    const n = e._withMods || (e._withMods = {})
      , o = t.join(".");
    return n[o] || (n[o] = (n, ...o) => {
        for (let e = 0; e < t.length; e++) {
            const o = Ki[t[e]];
            if (o && o(n, t))
                return
        }
        return e(n, ...o)
    }
    )
}
  , Xi = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
}
  , Ji = (e, t) => {
    const n = e._withKeys || (e._withKeys = {})
      , o = t.join(".");
    return n[o] || (n[o] = n => {
        if (!("key"in n))
            return;
        const o = I(n.key);
        return t.some(e => e === o || Xi[e] === o) ? e(n) : void 0
    }
    )
}
  , Qi = d({
    patchProp: (e, t, n, o, a, r) => {
        const s = "svg" === a;
        "class" === t ? function(e, t, n) {
            const o = e[Is];
            o && (t = (t ? [t, ...o] : [...o]).join(" ")),
            null == t ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
        }(e, o, s) : "style" === t ? function(e, t, n) {
            const o = e.style
              , a = w(n);
            let r = !1;
            if (n && !a) {
                if (t)
                    if (w(t))
                        for (const e of t.split(";")) {
                            const t = e.slice(0, e.indexOf(":")).trim();
                            null == n[t] && ri(o, t, "")
                        }
                    else
                        for (const e in t)
                            null == n[e] && ri(o, e, "");
                for (const e in n)
                    "display" === e && (r = !0),
                    ri(o, e, n[e])
            } else if (a) {
                if (t !== n) {
                    const e = o[ei];
                    e && (n += ";" + e),
                    o.cssText = n,
                    r = oi.test(n)
                }
            } else
                t && e.removeAttribute("style");
            Ys in e && (e[Ys] = r ? o.display : "",
            e[Xs] && (o.display = "none"))
        }(e, n, o) : u(t) ? c(t) || fi(e, t, 0, o, r) : ("." === t[0] ? (t = t.slice(1),
        1) : "^" === t[0] ? (t = t.slice(1),
        0) : function(e, t, n, o) {
            if (o)
                return "innerHTML" === t || "textContent" === t || !!(t in e && yi(t) && b(n));
            if ("spellcheck" === t || "draggable" === t || "translate" === t || "autocorrect" === t)
                return !1;
            if ("form" === t)
                return !1;
            if ("list" === t && "INPUT" === e.tagName)
                return !1;
            if ("type" === t && "TEXTAREA" === e.tagName)
                return !1;
            if ("width" === t || "height" === t) {
                const t = e.tagName;
                if ("IMG" === t || "VIDEO" === t || "CANVAS" === t || "SOURCE" === t)
                    return !1
            }
            if (yi(t) && w(n))
                return !1;
            return t in e
        }(e, t, o, s)) ? (ci(e, t, o),
        e.tagName.includes("-") || "value" !== t && "checked" !== t && "selected" !== t || ui(e, t, o, s, 0, "value" !== t)) : !e._isVueCE || !/[A-Z]/.test(t) && w(o) ? ("true-value" === t ? e._trueValue = o : "false-value" === t && (e._falseValue = o),
        ui(e, t, o, s)) : ci(e, P(t), o, 0, t)
    }
}, Ms);
let el, tl = !1;
function nl() {
    return el || (el = ja(Qi))
}
function ol() {
    return el = tl ? el : Fa(Qi),
    tl = !0,
    el
}
const al = (...e) => {
    nl().render(...e)
}
  , rl = (...e) => {
    const t = nl().createApp(...e)
      , {mount: n} = t;
    return t.mount = e => {
        const o = ll(e);
        if (!o)
            return;
        const a = t._component;
        b(a) || a.render || a.template || (a.template = o.innerHTML),
        1 === o.nodeType && (o.textContent = "");
        const r = n(o, !1, il(o));
        return o instanceof Element && (o.removeAttribute("v-cloak"),
        o.setAttribute("data-v-app", "")),
        r
    }
    ,
    t
}
  , sl = (...e) => {
    const t = ol().createApp(...e)
      , {mount: n} = t;
    return t.mount = e => {
        const t = ll(e);
        if (t)
            return n(t, !0, il(t))
    }
    ,
    t
}
;
function il(e) {
    return e instanceof SVGElement ? "svg" : "function" == typeof MathMLElement && e instanceof MathMLElement ? "mathml" : void 0
}
function ll(e) {
    if (w(e)) {
        return document.querySelector(e)
    }
    return e
}
let ul = !1;
const cl = Object.freeze(Object.defineProperty({
    __proto__: null,
    BaseTransition: Gn,
    BaseTransitionPropsValidators: Zn,
    Comment: kr,
    DeprecationTypes: null,
    EffectScope: ie,
    ErrorCodes: {
        SETUP_FUNCTION: 0,
        0: "SETUP_FUNCTION",
        RENDER_FUNCTION: 1,
        1: "RENDER_FUNCTION",
        NATIVE_EVENT_HANDLER: 5,
        5: "NATIVE_EVENT_HANDLER",
        COMPONENT_EVENT_HANDLER: 6,
        6: "COMPONENT_EVENT_HANDLER",
        VNODE_HOOK: 7,
        7: "VNODE_HOOK",
        DIRECTIVE_HOOK: 8,
        8: "DIRECTIVE_HOOK",
        TRANSITION_HOOK: 9,
        9: "TRANSITION_HOOK",
        APP_ERROR_HANDLER: 10,
        10: "APP_ERROR_HANDLER",
        APP_WARN_HANDLER: 11,
        11: "APP_WARN_HANDLER",
        FUNCTION_REF: 12,
        12: "FUNCTION_REF",
        ASYNC_COMPONENT_LOADER: 13,
        13: "ASYNC_COMPONENT_LOADER",
        SCHEDULER: 14,
        14: "SCHEDULER",
        COMPONENT_UPDATE: 15,
        15: "COMPONENT_UPDATE",
        APP_UNMOUNT_CLEANUP: 16,
        16: "APP_UNMOUNT_CLEANUP"
    },
    ErrorTypeStrings: _s,
    Fragment: _r,
    KeepAlive: bo,
    ReactiveEffect: pe,
    Static: Sr,
    Suspense: vr,
    Teleport: Dn,
    Text: xr,
    TrackOpTypes: {
        GET: "get",
        HAS: "has",
        ITERATE: "iterate"
    },
    Transition: zs,
    TransitionGroup: Oi,
    TriggerOpTypes: {
        SET: "set",
        ADD: "add",
        DELETE: "delete",
        CLEAR: "clear"
    },
    VueElement: xi,
    assertNumber: function(e, t) {},
    callWithAsyncErrorHandling: on,
    callWithErrorHandling: nn,
    camelize: P,
    capitalize: L,
    cloneVNode: $r,
    compatUtils: null,
    compile: () => {}
    ,
    computed: ms,
    createApp: rl,
    createBlock: Ir,
    createCommentVNode: Ur,
    createElementBlock: Br,
    createElementVNode: Dr,
    createHydrationRenderer: Fa,
    createPropsRestProxy: function(e, t) {
        const n = {};
        for (const o in e)
            t.includes(o) || Object.defineProperty(n, o, {
                enumerable: !0,
                get: () => e[o]
            });
        return n
    },
    createRenderer: ja,
    createSSRApp: sl,
    createSlots: function(e, t) {
        for (let n = 0; n < t.length; n++) {
            const o = t[n];
            if (v(o))
                for (let t = 0; t < o.length; t++)
                    e[o[t].name] = o[t].fn;
            else
                o && (e[o.name] = o.key ? (...e) => {
                    const t = o.fn(...e);
                    return t && (t.key = o.key),
                    t
                }
                : o.fn)
        }
        return e
    },
    createStaticVNode: Hr,
    createTextVNode: Vr,
    createVNode: jr,
    customRef: Vt,
    defineAsyncComponent: function(e) {
        b(e) && (e = {
            loader: e
        });
        const {loader: t, loadingComponent: n, errorComponent: o, delay: a=200, hydrate: r, timeout: s, suspensible: i=!0, onError: l} = e;
        let u, c = null, d = 0;
        const p = () => {
            let e;
            return c || (e = c = t().catch(e => {
                if (e = e instanceof Error ? e : new Error(String(e)),
                l)
                    return new Promise( (t, n) => {
                        l(e, () => t((d++,
                        c = null,
                        p())), () => n(e), d + 1)
                    }
                    );
                throw e
            }
            ).then(t => e !== c && c ? c : (t && (t.__esModule || "Module" === t[Symbol.toStringTag]) && (t = t.default),
            u = t,
            t)))
        }
        ;
        return to({
            name: "AsyncComponentWrapper",
            __asyncLoader: p,
            __asyncHydrate(e, t, n) {
                const o = r ? () => {
                    const o = r( () => {
                        n()
                    }
                    , t => function(e, t) {
                        if (lo(e) && "[" === e.data) {
                            let n = 1
                              , o = e.nextSibling;
                            for (; o; ) {
                                if (1 === o.nodeType) {
                                    if (!1 === t(o))
                                        break
                                } else if (lo(o))
                                    if ("]" === o.data) {
                                        if (0 === --n)
                                            break
                                    } else
                                        "[" === o.data && n++;
                                o = o.nextSibling
                            }
                        } else
                            t(e)
                    }(e, t));
                    o && (t.bum || (t.bum = [])).push(o),
                    (t.u || (t.u = [])).push( () => !0)
                }
                : n;
                u ? o() : p().then( () => !t.isUnmounted && o())
            },
            get __asyncResolved() {
                return u
            },
            setup() {
                const e = Qr;
                if (oo(e),
                u)
                    return () => go(u, e);
                const t = t => {
                    c = null,
                    an(t, e, 13, !o)
                }
                ;
                if (i && e.suspense || ls)
                    return p().then(t => () => go(t, e)).catch(e => (t(e),
                    () => o ? jr(o, {
                        error: e
                    }) : null));
                const r = It(!1)
                  , l = It()
                  , d = It(!!a);
                return a && setTimeout( () => {
                    d.value = !1
                }
                , a),
                null != s && setTimeout( () => {
                    if (!r.value && !l.value) {
                        const e = new Error(`Async component timed out after ${s}ms.`);
                        t(e),
                        l.value = e
                    }
                }
                , s),
                p().then( () => {
                    r.value = !0,
                    e.parent && yo(e.parent.vnode) && e.parent.update()
                }
                ).catch(e => {
                    t(e),
                    l.value = e
                }
                ),
                () => r.value && u ? go(u, e) : l.value && o ? jr(o, {
                    error: l.value
                }) : n && !d.value ? jr(n) : void 0
            }
        })
    },
    defineComponent: to,
    defineCustomElement: wi,
    defineEmits: function() {
        return null
    },
    defineExpose: function(e) {},
    defineModel: function() {},
    defineOptions: function(e) {},
    defineProps: function() {
        return null
    },
    defineSSRCustomElement: (e, t) => wi(e, t, sl),
    defineSlots: function() {
        return null
    },
    devtools: xs,
    effect: function(e, t) {
        e.effect instanceof pe && (e = e.effect.fn);
        const n = new pe(e);
        t && d(n, t);
        try {
            n.run()
        } catch (a) {
            throw n.stop(),
            a
        }
        const o = n.run.bind(n);
        return o.effect = n,
        o
    },
    effectScope: le,
    getCurrentInstance: es,
    getCurrentScope: ue,
    getCurrentWatcher: function() {
        return Xt
    },
    getTransitionRawChildren: eo,
    guardReactiveProps: Fr,
    h: gs,
    handleError: an,
    hasInjectionContext: ka,
    hydrate: (...e) => {
        ol().hydrate(...e)
    }
    ,
    hydrateOnIdle: (e=1e4) => t => {
        const n = ho(t, {
            timeout: e
        });
        return () => vo(n)
    }
    ,
    hydrateOnInteraction: (e=[]) => (t, n) => {
        w(e) && (e = [e]);
        let o = !1;
        const a = e => {
            o || (o = !0,
            r(),
            t(),
            e.target.dispatchEvent(new e.constructor(e.type,e)))
        }
          , r = () => {
            n(t => {
                for (const n of e)
                    t.removeEventListener(n, a)
            }
            )
        }
        ;
        return n(t => {
            for (const n of e)
                t.addEventListener(n, a, {
                    once: !0
                })
        }
        ),
        r
    }
    ,
    hydrateOnMediaQuery: e => t => {
        if (e) {
            const n = matchMedia(e);
            if (!n.matches)
                return n.addEventListener("change", t, {
                    once: !0
                }),
                () => n.removeEventListener("change", t);
            t()
        }
    }
    ,
    hydrateOnVisible: e => (t, n) => {
        const o = new IntersectionObserver(e => {
            for (const n of e)
                if (n.isIntersecting) {
                    o.disconnect(),
                    t();
                    break
                }
        }
        ,e);
        return n(e => {
            if (e instanceof Element)
                return function(e) {
                    const {top: t, left: n, bottom: o, right: a} = e.getBoundingClientRect()
                      , {innerHeight: r, innerWidth: s} = window;
                    return (t > 0 && t < r || o > 0 && o < r) && (n > 0 && n < s || a > 0 && a < s)
                }(e) ? (t(),
                o.disconnect(),
                !1) : void o.observe(e)
        }
        ),
        () => o.disconnect()
    }
    ,
    initCustomFormatter: function() {},
    initDirectivesForSSR: () => {
        ul || (ul = !0,
        Ni.getSSRProps = ({value: e}) => ({
            value: e
        }),
        Fi.getSSRProps = ({value: e}, t) => {
            if (t.props && Q(t.props.value, e))
                return {
                    checked: !0
                }
        }
        ,
        Di.getSSRProps = ({value: e}, t) => {
            if (v(e)) {
                if (t.props && ee(e, t.props.value) > -1)
                    return {
                        checked: !0
                    }
            } else if (g(e)) {
                if (t.props && e.has(t.props.value))
                    return {
                        checked: !0
                    }
            } else if (e)
                return {
                    checked: !0
                }
        }
        ,
        Zi.getSSRProps = (e, t) => {
            if ("string" != typeof t.type)
                return;
            const n = qi(t.type.toUpperCase(), t.props && t.props.type);
            return n.getSSRProps ? n.getSSRProps(e, t) : void 0
        }
        ,
        Js.getSSRProps = ({value: e}) => {
            if (!e)
                return {
                    style: {
                        display: "none"
                    }
                }
        }
        )
    }
    ,
    inject: xa,
    isMemoSame: ys,
    isProxy: Tt,
    isReactive: St,
    isReadonly: Ct,
    isRef: Bt,
    isRuntimeOnly: () => !ss,
    isShallow: Et,
    isVNode: Lr,
    markRaw: Ot,
    mergeDefaults: aa,
    mergeModels: function(e, t) {
        return e && t ? v(e) && v(t) ? e.concat(t) : d({}, oa(e), oa(t)) : e || t
    },
    mergeProps: Gr,
    nextTick: fn,
    normalizeClass: K,
    normalizeProps: Y,
    normalizeStyle: U,
    onActivated: _o,
    onBeforeMount: Oo,
    onBeforeUnmount: Io,
    onBeforeUpdate: Po,
    onDeactivated: xo,
    onErrorCaptured: Do,
    onMounted: Mo,
    onRenderTracked: No,
    onRenderTriggered: zo,
    onScopeDispose: ce,
    onServerPrefetch: Ro,
    onUnmounted: Lo,
    onUpdated: Bo,
    onWatcherCleanup: Jt,
    openBlock: Tr,
    popScopeId: function() {
        Sn = null
    },
    provide: _a,
    proxyRefs: Ft,
    pushScopeId: function(e) {
        Sn = e
    },
    queuePostFlushCb: mn,
    reactive: bt,
    readonly: _t,
    ref: It,
    registerRuntimeCompiler: function(e) {
        ss = e,
        is = e => {
            e.render._rc && (e.withProxy = new Proxy(e.ctx,Qo))
        }
    },
    render: al,
    renderList: qo,
    renderSlot: Wo,
    resolveComponent: Fo,
    resolveDirective: Ho,
    resolveDynamicComponent: Vo,
    resolveFilter: null,
    resolveTransitionHooks: Yn,
    setBlockTracking: Mr,
    setDevtoolsHook: ks,
    setTransitionHooks: Qn,
    shallowReactive: wt,
    shallowReadonly: xt,
    shallowRef: Lt,
    ssrContextKey: Ga,
    ssrUtils: Ss,
    stop: function(e) {
        e.effect.stop()
    },
    toDisplayString: ne,
    toHandlerKey: R,
    toHandlers: function(e, t) {
        const n = {};
        for (const o in e)
            n[t && /[A-Z]/.test(o) ? `on:${o}` : R(o)] = e[o];
        return n
    },
    toRaw: At,
    toRef: qt,
    toRefs: Ht,
    toValue: Dt,
    transformVNodeArgs: function(e) {},
    triggerRef: function(e) {
        e.dep && e.dep.trigger()
    },
    unref: Nt,
    useAttrs: ta,
    useCssModule: function(e="$style") {
        {
            const t = es();
            if (!t)
                return r;
            const n = t.type.__cssModules;
            if (!n)
                return r;
            const o = n[e];
            return o || r
        }
    },
    useCssVars: function(e) {
        const t = es();
        if (!t)
            return;
        const n = t.ut = (n=e(t.proxy)) => {
            Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(e => ni(e, n))
        }
          , o = () => {
            const o = e(t.proxy);
            t.ce ? ni(t.ce, o) : ti(t.subTree, o),
            n(o)
        }
        ;
        Po( () => {
            mn(o)
        }
        ),
        Mo( () => {
            Qa(o, i, {
                flush: "post"
            });
            const e = new MutationObserver(o);
            e.observe(t.subTree.el.parentNode, {
                childList: !0
            }),
            Lo( () => e.disconnect())
        }
        )
    },
    useHost: ki,
    useId: no,
    useModel: or,
    useSSRContext: Ka,
    useShadowRoot: function() {
        const e = ki();
        return e && e.shadowRoot
    },
    useSlots: ea,
    useTemplateRef: function(e) {
        const t = es()
          , n = Lt(null);
        if (t) {
            const o = t.refs === r ? t.refs = {} : t.refs;
            Object.defineProperty(o, e, {
                enumerable: !0,
                get: () => n.value,
                set: e => n.value = e
            })
        }
        return n
    },
    useTransitionState: Hn,
    vModelCheckbox: Di,
    vModelDynamic: Zi,
    vModelRadio: Fi,
    vModelSelect: $i,
    vModelText: Ni,
    vShow: Js,
    version: bs,
    warn: ws,
    watch: Qa,
    watchEffect: Ya,
    watchPostEffect: Xa,
    watchSyncEffect: Ja,
    withAsyncContext: function(e) {
        const t = es();
        let n = e();
        return as(),
        k(n) && (n = n.catch(e => {
            throw os(t),
            e
        }
        )),
        [n, () => os(t)]
    },
    withCtx: En,
    withDefaults: function(e, t) {
        return null
    },
    withDirectives: Tn,
    withKeys: Ji,
    withMemo: function(e, t, n, o) {
        const a = n[o];
        if (a && ys(a, e))
            return a;
        const r = t();
        return r.memo = e.slice(),
        r.cacheIndex = o,
        n[o] = r
    },
    withModifiers: Yi,
    withScopeId: e => En
}, Symbol.toStringTag, {
    value: "Module"
}));
/**
* vue v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let dl;
const pl = e => dl = e
  , fl = Symbol();
function hl(e) {
    return e && "object" == typeof e && "[object Object]" === Object.prototype.toString.call(e) && "function" != typeof e.toJSON
}
var vl, ml;
(ml = vl || (vl = {})).direct = "direct",
ml.patchObject = "patch object",
ml.patchFunction = "patch function";
const gl = () => {}
;
function yl(e, t, n, o=gl) {
    e.push(t);
    const a = () => {
        const n = e.indexOf(t);
        n > -1 && (e.splice(n, 1),
        o())
    }
    ;
    return !n && ue() && ce(a),
    a
}
function bl(e, ...t) {
    e.slice().forEach(e => {
        e(...t)
    }
    )
}
const wl = e => e()
  , _l = Symbol()
  , xl = Symbol();
function kl(e, t) {
    e instanceof Map && t instanceof Map ? t.forEach( (t, n) => e.set(n, t)) : e instanceof Set && t instanceof Set && t.forEach(e.add, e);
    for (const n in t) {
        if (!t.hasOwnProperty(n))
            continue;
        const o = t[n]
          , a = e[n];
        hl(a) && hl(o) && e.hasOwnProperty(n) && !Bt(o) && !St(o) ? e[n] = kl(a, o) : e[n] = o
    }
    return e
}
const Sl = Symbol();
function Cl(e) {
    return !hl(e) || !Object.prototype.hasOwnProperty.call(e, Sl)
}
const {assign: El} = Object;
function Tl(e) {
    return !(!Bt(e) || !e.effect)
}
function Al(e, t, n={}, o, a, r) {
    let s;
    const i = El({
        actions: {}
    }, n)
      , l = {
        deep: !0
    };
    let u, c, d, p = [], f = [];
    const h = o.state.value[e];
    let v;
    function m(t) {
        let n;
        u = c = !1,
        "function" == typeof t ? (t(o.state.value[e]),
        n = {
            type: vl.patchFunction,
            storeId: e,
            events: d
        }) : (kl(o.state.value[e], t),
        n = {
            type: vl.patchObject,
            payload: t,
            storeId: e,
            events: d
        });
        const a = v = Symbol();
        fn().then( () => {
            v === a && (u = !0)
        }
        ),
        c = !0,
        bl(p, n, o.state.value[e])
    }
    r || h || (o.state.value[e] = {}),
    It({});
    const g = r ? function() {
        const {state: e} = n
          , t = e ? e() : {};
        this.$patch(e => {
            El(e, t)
        }
        )
    }
    : gl;
    const y = (t, n="") => {
        if (_l in t)
            return t[xl] = n,
            t;
        const a = function() {
            pl(o);
            const n = Array.from(arguments)
              , r = []
              , s = [];
            let i;
            bl(f, {
                args: n,
                name: a[xl],
                store: b,
                after: function(e) {
                    r.push(e)
                },
                onError: function(e) {
                    s.push(e)
                }
            });
            try {
                i = t.apply(this && this.$id === e ? this : b, n)
            } catch (l) {
                throw bl(s, l),
                l
            }
            return i instanceof Promise ? i.then(e => (bl(r, e),
            e)).catch(e => (bl(s, e),
            Promise.reject(e))) : (bl(r, i),
            i)
        };
        return a[_l] = !0,
        a[xl] = n,
        a
    }
      , b = bt({
        _p: o,
        $id: e,
        $onAction: yl.bind(null, f),
        $patch: m,
        $reset: g,
        $subscribe(t, n={}) {
            const a = yl(p, t, n.detached, () => r())
              , r = s.run( () => Qa( () => o.state.value[e], o => {
                ("sync" === n.flush ? c : u) && t({
                    storeId: e,
                    type: vl.direct,
                    events: d
                }, o)
            }
            , El({}, l, n)));
            return a
        },
        $dispose: function() {
            s.stop(),
            p = [],
            f = [],
            o._s.delete(e)
        }
    });
    o._s.set(e, b);
    const w = (o._a && o._a.runWithContext || wl)( () => o._e.run( () => (s = le()).run( () => t({
        action: y
    }))));
    for (const _ in w) {
        const t = w[_];
        if (Bt(t) && !Tl(t) || St(t))
            r || (h && Cl(t) && (Bt(t) ? t.value = h[_] : kl(t, h[_])),
            o.state.value[e][_] = t);
        else if ("function" == typeof t) {
            const e = y(t, _);
            w[_] = e,
            i.actions[_] = t
        }
    }
    return El(b, w),
    El(At(b), w),
    Object.defineProperty(b, "$state", {
        get: () => o.state.value[e],
        set: e => {
            m(t => {
                El(t, e)
            }
            )
        }
    }),
    o._p.forEach(e => {
        El(b, s.run( () => e({
            store: b,
            app: o._a,
            pinia: o,
            options: i
        })))
    }
    ),
    h && r && n.hydrate && n.hydrate(b.$state, h),
    u = !0,
    c = !0,
    b
}
/*! #__NO_SIDE_EFFECTS__ */
function Ol(e, t, n) {
    let o;
    const a = "function" == typeof t;
    function r(n, r) {
        const s = ka();
        (n = n || (s ? xa(fl, null) : null)) && pl(n),
        (n = dl)._s.has(e) || (a ? Al(e, t, o, n) : function(e, t, n) {
            const {state: o, actions: a, getters: r} = t
              , s = n.state.value[e];
            let i;
            i = Al(e, function() {
                s || (n.state.value[e] = o ? o() : {});
                const t = Ht(n.state.value[e]);
                return El(t, a, Object.keys(r || {}).reduce( (t, o) => (t[o] = Ot(ms( () => {
                    pl(n);
                    const t = n._s.get(e);
                    return r[o].call(t, t)
                }
                )),
                t), {}))
            }, t, n, 0, !0)
        }(e, o, n));
        return n._s.get(e)
    }
    return o = a ? n : t,
    r.$id = e,
    r
}
var Ml = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function Pl(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var Bl, Il = {
    exports: {}
};
var Ll = (Bl || (Bl = 1,
Il.exports = function(e) {
    function t(o) {
        if (n[o])
            return n[o].exports;
        var a = n[o] = {
            i: o,
            l: !1,
            exports: {}
        };
        return e[o].call(a.exports, a, a.exports, t),
        a.l = !0,
        a.exports
    }
    var n = {};
    return t.m = e,
    t.c = n,
    t.i = function(e) {
        return e
    }
    ,
    t.d = function(e, n, o) {
        t.o(e, n) || Object.defineProperty(e, n, {
            configurable: !1,
            enumerable: !0,
            get: o
        })
    }
    ,
    t.n = function(e) {
        var n = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return t.d(n, "a", n),
        n
    }
    ,
    t.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    t.p = ".",
    t(t.s = 10)
}([function(e, t) {
    e.exports = {
        "#": {
            pattern: /\d/
        },
        X: {
            pattern: /[0-9a-zA-Z]/
        },
        S: {
            pattern: /[a-zA-Z]/
        },
        A: {
            pattern: /[a-zA-Z]/,
            transform: function(e) {
                return e.toLocaleUpperCase()
            }
        },
        a: {
            pattern: /[a-zA-Z]/,
            transform: function(e) {
                return e.toLocaleLowerCase()
            }
        },
        "!": {
            escape: !0
        }
    }
}
, function(e, t, n) {
    function o(e) {
        var t = document.createEvent("Event");
        return t.initEvent(e, !0, !0),
        t
    }
    var a = n(2)
      , r = n(0)
      , s = n.n(r);
    t.a = function(e, t) {
        var r = t.value;
        if ((Array.isArray(r) || "string" == typeof r) && (r = {
            mask: r,
            tokens: s.a
        }),
        "INPUT" !== e.tagName.toLocaleUpperCase()) {
            var i = e.getElementsByTagName("input");
            if (1 !== i.length)
                throw new Error("v-mask directive requires 1 input, found " + i.length);
            e = i[0]
        }
        e.oninput = function(t) {
            if (t.isTrusted) {
                var s = e.selectionEnd
                  , i = e.value[s - 1];
                for (e.value = n.i(a.a)(e.value, r.mask, !0, r.tokens); s < e.value.length && e.value.charAt(s - 1) !== i; )
                    s++;
                e === document.activeElement && (e.setSelectionRange(s, s),
                setTimeout(function() {
                    e.setSelectionRange(s, s)
                }, 0)),
                e.dispatchEvent(o("input"))
            }
        }
        ;
        var l = n.i(a.a)(e.value, r.mask, !0, r.tokens);
        l !== e.value && (e.value = l,
        e.dispatchEvent(o("input")))
    }
}
, function(e, t, n) {
    var o = n(6)
      , a = n(5);
    t.a = function(e, t) {
        var r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
          , s = arguments[3];
        return Array.isArray(t) ? n.i(a.a)(o.a, t, s)(e, t, r, s) : n.i(o.a)(e, t, r, s)
    }
}
, function(e, t, n) {
    function o(e) {
        e.component(l.a.name, l.a),
        e.directive("mask", s.a)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var a = n(0)
      , r = n.n(a)
      , s = n(1)
      , i = n(7)
      , l = n.n(i);
    n.d(t, "TheMask", function() {
        return l.a
    }),
    n.d(t, "mask", function() {
        return s.a
    }),
    n.d(t, "tokens", function() {
        return r.a
    }),
    n.d(t, "version", function() {
        return u
    });
    var u = "0.11.1";
    t.default = o,
    "undefined" != typeof window && window.Vue && window.Vue.use(o)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var o = n(1)
      , a = n(0)
      , r = n.n(a)
      , s = n(2);
    t.default = {
        name: "TheMask",
        props: {
            value: [String, Number],
            mask: {
                type: [String, Array],
                required: !0
            },
            masked: {
                type: Boolean,
                default: !1
            },
            tokens: {
                type: Object,
                default: function() {
                    return r.a
                }
            }
        },
        directives: {
            mask: o.a
        },
        data: function() {
            return {
                lastValue: null,
                display: this.value
            }
        },
        watch: {
            value: function(e) {
                e !== this.lastValue && (this.display = e)
            },
            masked: function() {
                this.refresh(this.display)
            }
        },
        computed: {
            config: function() {
                return {
                    mask: this.mask,
                    tokens: this.tokens,
                    masked: this.masked
                }
            }
        },
        methods: {
            onInput: function(e) {
                e.isTrusted || this.refresh(e.target.value)
            },
            refresh: function(e) {
                this.display = e,
                (e = n.i(s.a)(e, this.mask, this.masked, this.tokens)) !== this.lastValue && (this.lastValue = e,
                this.$emit("input", e))
            }
        }
    }
}
, function(e, t, n) {
    function o(e, t, n) {
        return t = t.sort(function(e, t) {
            return e.length - t.length
        }),
        function(o, a) {
            for (var r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s = 0; s < t.length; ) {
                var i = t[s];
                s++;
                var l = t[s];
                if (!(l && e(o, l, !0, n).length > i.length))
                    return e(o, i, r, n)
            }
            return ""
        }
    }
    t.a = o
}
, function(e, t, n) {
    function o(e, t) {
        var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
          , o = arguments[3];
        e = e || "",
        t = t || "";
        for (var a = 0, r = 0, s = ""; a < t.length && r < e.length; ) {
            var i = o[c = t[a]]
              , l = e[r];
            i && !i.escape ? (i.pattern.test(l) && (s += i.transform ? i.transform(l) : l,
            a++),
            r++) : (i && i.escape && (c = t[++a]),
            n && (s += c),
            l === c && r++,
            a++)
        }
        for (var u = ""; a < t.length && n; ) {
            var c;
            if (o[c = t[a]]) {
                u = "";
                break
            }
            u += c,
            a++
        }
        return s + u
    }
    t.a = o
}
, function(e, t, n) {
    var o = n(8)(n(4), n(9), null, null);
    e.exports = o.exports
}
, function(e, t) {
    e.exports = function(e, t, n, o) {
        var a, r = e = e || {}, s = typeof e.default;
        "object" !== s && "function" !== s || (a = e,
        r = e.default);
        var i = "function" == typeof r ? r.options : r;
        if (t && (i.render = t.render,
        i.staticRenderFns = t.staticRenderFns),
        n && (i._scopeId = n),
        o) {
            var l = i.computed || (i.computed = {});
            Object.keys(o).forEach(function(e) {
                var t = o[e];
                l[e] = function() {
                    return t
                }
            })
        }
        return {
            esModule: a,
            exports: r,
            options: i
        }
    }
}
, function(e, t) {
    e.exports = {
        render: function() {
            var e = this
              , t = e.$createElement;
            return (e._self._c || t)("input", {
                directives: [{
                    name: "mask",
                    rawName: "v-mask",
                    value: e.config,
                    expression: "config"
                }],
                attrs: {
                    type: "text"
                },
                domProps: {
                    value: e.display
                },
                on: {
                    input: e.onInput
                }
            })
        },
        staticRenderFns: []
    }
}
, function(e, t, n) {
    e.exports = n(3)
}
])),
Il.exports);
const Rl = ["top", "right", "bottom", "left"]
  , zl = Math.min
  , Nl = Math.max
  , Dl = Math.round
  , jl = Math.floor
  , Fl = e => ({
    x: e,
    y: e
})
  , $l = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
}
  , Vl = {
    start: "end",
    end: "start"
};
function Hl(e, t, n) {
    return Nl(e, zl(t, n))
}
function Ul(e, t) {
    return "function" == typeof e ? e(t) : e
}
function Zl(e) {
    return e.split("-")[0]
}
function ql(e) {
    return e.split("-")[1]
}
function Wl(e) {
    return "x" === e ? "y" : "x"
}
function Gl(e) {
    return "y" === e ? "height" : "width"
}
const Kl = new Set(["top", "bottom"]);
function Yl(e) {
    return Kl.has(Zl(e)) ? "y" : "x"
}
function Xl(e) {
    return Wl(Yl(e))
}
function Jl(e) {
    return e.replace(/start|end/g, e => Vl[e])
}
const Ql = ["left", "right"]
  , eu = ["right", "left"]
  , tu = ["top", "bottom"]
  , nu = ["bottom", "top"];
function ou(e, t, n, o) {
    const a = ql(e);
    let r = function(e, t, n) {
        switch (e) {
        case "top":
        case "bottom":
            return n ? t ? eu : Ql : t ? Ql : eu;
        case "left":
        case "right":
            return t ? tu : nu;
        default:
            return []
        }
    }(Zl(e), "start" === n, o);
    return a && (r = r.map(e => e + "-" + a),
    t && (r = r.concat(r.map(Jl)))),
    r
}
function au(e) {
    return e.replace(/left|right|bottom|top/g, e => $l[e])
}
function ru(e) {
    return "number" != typeof e ? function(e) {
        return {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            ...e
        }
    }(e) : {
        top: e,
        right: e,
        bottom: e,
        left: e
    }
}
function su(e) {
    const {x: t, y: n, width: o, height: a} = e;
    return {
        width: o,
        height: a,
        top: n,
        left: t,
        right: t + o,
        bottom: n + a,
        x: t,
        y: n
    }
}
function iu(e, t, n) {
    let {reference: o, floating: a} = e;
    const r = Yl(t)
      , s = Xl(t)
      , i = Gl(s)
      , l = Zl(t)
      , u = "y" === r
      , c = o.x + o.width / 2 - a.width / 2
      , d = o.y + o.height / 2 - a.height / 2
      , p = o[i] / 2 - a[i] / 2;
    let f;
    switch (l) {
    case "top":
        f = {
            x: c,
            y: o.y - a.height
        };
        break;
    case "bottom":
        f = {
            x: c,
            y: o.y + o.height
        };
        break;
    case "right":
        f = {
            x: o.x + o.width,
            y: d
        };
        break;
    case "left":
        f = {
            x: o.x - a.width,
            y: d
        };
        break;
    default:
        f = {
            x: o.x,
            y: o.y
        }
    }
    switch (ql(t)) {
    case "start":
        f[s] -= p * (n && u ? -1 : 1);
        break;
    case "end":
        f[s] += p * (n && u ? -1 : 1)
    }
    return f
}
async function lu(e, t) {
    var n;
    void 0 === t && (t = {});
    const {x: o, y: a, platform: r, rects: s, elements: i, strategy: l} = e
      , {boundary: u="clippingAncestors", rootBoundary: c="viewport", elementContext: d="floating", altBoundary: p=!1, padding: f=0} = Ul(t, e)
      , h = ru(f)
      , v = i[p ? "floating" === d ? "reference" : "floating" : d]
      , m = su(await r.getClippingRect({
        element: null == (n = await (null == r.isElement ? void 0 : r.isElement(v))) || n ? v : v.contextElement || await (null == r.getDocumentElement ? void 0 : r.getDocumentElement(i.floating)),
        boundary: u,
        rootBoundary: c,
        strategy: l
    }))
      , g = "floating" === d ? {
        x: o,
        y: a,
        width: s.floating.width,
        height: s.floating.height
    } : s.reference
      , y = await (null == r.getOffsetParent ? void 0 : r.getOffsetParent(i.floating))
      , b = await (null == r.isElement ? void 0 : r.isElement(y)) && await (null == r.getScale ? void 0 : r.getScale(y)) || {
        x: 1,
        y: 1
    }
      , w = su(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: i,
        rect: g,
        offsetParent: y,
        strategy: l
    }) : g);
    return {
        top: (m.top - w.top + h.top) / b.y,
        bottom: (w.bottom - m.bottom + h.bottom) / b.y,
        left: (m.left - w.left + h.left) / b.x,
        right: (w.right - m.right + h.right) / b.x
    }
}
function uu(e, t) {
    return {
        top: e.top - t.height,
        right: e.right - t.width,
        bottom: e.bottom - t.height,
        left: e.left - t.width
    }
}
function cu(e) {
    return Rl.some(t => e[t] >= 0)
}
const du = new Set(["left", "top"]);
function pu() {
    return "undefined" != typeof window
}
function fu(e) {
    return mu(e) ? (e.nodeName || "").toLowerCase() : "#document"
}
function hu(e) {
    var t;
    return (null == e || null == (t = e.ownerDocument) ? void 0 : t.defaultView) || window
}
function vu(e) {
    var t;
    return null == (t = (mu(e) ? e.ownerDocument : e.document) || window.document) ? void 0 : t.documentElement
}
function mu(e) {
    return !!pu() && (e instanceof Node || e instanceof hu(e).Node)
}
function gu(e) {
    return !!pu() && (e instanceof Element || e instanceof hu(e).Element)
}
function yu(e) {
    return !!pu() && (e instanceof HTMLElement || e instanceof hu(e).HTMLElement)
}
function bu(e) {
    return !(!pu() || "undefined" == typeof ShadowRoot) && (e instanceof ShadowRoot || e instanceof hu(e).ShadowRoot)
}
const wu = new Set(["inline", "contents"]);
function _u(e) {
    const {overflow: t, overflowX: n, overflowY: o, display: a} = Iu(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !wu.has(a)
}
const xu = new Set(["table", "td", "th"]);
function ku(e) {
    return xu.has(fu(e))
}
const Su = [":popover-open", ":modal"];
function Cu(e) {
    return Su.some(t => {
        try {
            return e.matches(t)
        } catch (n) {
            return !1
        }
    }
    )
}
const Eu = ["transform", "translate", "scale", "rotate", "perspective"]
  , Tu = ["transform", "translate", "scale", "rotate", "perspective", "filter"]
  , Au = ["paint", "layout", "strict", "content"];
function Ou(e) {
    const t = Mu()
      , n = gu(e) ? Iu(e) : e;
    return Eu.some(e => !!n[e] && "none" !== n[e]) || !!n.containerType && "normal" !== n.containerType || !t && !!n.backdropFilter && "none" !== n.backdropFilter || !t && !!n.filter && "none" !== n.filter || Tu.some(e => (n.willChange || "").includes(e)) || Au.some(e => (n.contain || "").includes(e))
}
function Mu() {
    return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none")
}
const Pu = new Set(["html", "body", "#document"]);
function Bu(e) {
    return Pu.has(fu(e))
}
function Iu(e) {
    return hu(e).getComputedStyle(e)
}
function Lu(e) {
    return gu(e) ? {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
    } : {
        scrollLeft: e.scrollX,
        scrollTop: e.scrollY
    }
}
function Ru(e) {
    if ("html" === fu(e))
        return e;
    const t = e.assignedSlot || e.parentNode || bu(e) && e.host || vu(e);
    return bu(t) ? t.host : t
}
function zu(e) {
    const t = Ru(e);
    return Bu(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : yu(t) && _u(t) ? t : zu(t)
}
function Nu(e, t, n) {
    var o;
    void 0 === t && (t = []),
    void 0 === n && (n = !0);
    const a = zu(e)
      , r = a === (null == (o = e.ownerDocument) ? void 0 : o.body)
      , s = hu(a);
    if (r) {
        const e = Du(s);
        return t.concat(s, s.visualViewport || [], _u(a) ? a : [], e && n ? Nu(e) : [])
    }
    return t.concat(a, Nu(a, [], n))
}
function Du(e) {
    return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
}
function ju(e) {
    const t = Iu(e);
    let n = parseFloat(t.width) || 0
      , o = parseFloat(t.height) || 0;
    const a = yu(e)
      , r = a ? e.offsetWidth : n
      , s = a ? e.offsetHeight : o
      , i = Dl(n) !== r || Dl(o) !== s;
    return i && (n = r,
    o = s),
    {
        width: n,
        height: o,
        $: i
    }
}
function Fu(e) {
    return gu(e) ? e : e.contextElement
}
function $u(e) {
    const t = Fu(e);
    if (!yu(t))
        return Fl(1);
    const n = t.getBoundingClientRect()
      , {width: o, height: a, $: r} = ju(t);
    let s = (r ? Dl(n.width) : n.width) / o
      , i = (r ? Dl(n.height) : n.height) / a;
    return s && Number.isFinite(s) || (s = 1),
    i && Number.isFinite(i) || (i = 1),
    {
        x: s,
        y: i
    }
}
const Vu = Fl(0);
function Hu(e) {
    const t = hu(e);
    return Mu() && t.visualViewport ? {
        x: t.visualViewport.offsetLeft,
        y: t.visualViewport.offsetTop
    } : Vu
}
function Uu(e, t, n, o) {
    void 0 === t && (t = !1),
    void 0 === n && (n = !1);
    const a = e.getBoundingClientRect()
      , r = Fu(e);
    let s = Fl(1);
    t && (o ? gu(o) && (s = $u(o)) : s = $u(e));
    const i = function(e, t, n) {
        return void 0 === t && (t = !1),
        !(!n || t && n !== hu(e)) && t
    }(r, n, o) ? Hu(r) : Fl(0);
    let l = (a.left + i.x) / s.x
      , u = (a.top + i.y) / s.y
      , c = a.width / s.x
      , d = a.height / s.y;
    if (r) {
        const e = hu(r)
          , t = o && gu(o) ? hu(o) : o;
        let n = e
          , a = Du(n);
        for (; a && o && t !== n; ) {
            const e = $u(a)
              , t = a.getBoundingClientRect()
              , o = Iu(a)
              , r = t.left + (a.clientLeft + parseFloat(o.paddingLeft)) * e.x
              , s = t.top + (a.clientTop + parseFloat(o.paddingTop)) * e.y;
            l *= e.x,
            u *= e.y,
            c *= e.x,
            d *= e.y,
            l += r,
            u += s,
            n = hu(a),
            a = Du(n)
        }
    }
    return su({
        width: c,
        height: d,
        x: l,
        y: u
    })
}
function Zu(e, t) {
    const n = Lu(e).scrollLeft;
    return t ? t.left + n : Uu(vu(e)).left + n
}
function qu(e, t, n) {
    void 0 === n && (n = !1);
    const o = e.getBoundingClientRect();
    return {
        x: o.left + t.scrollLeft - (n ? 0 : Zu(e, o)),
        y: o.top + t.scrollTop
    }
}
const Wu = new Set(["absolute", "fixed"]);
function Gu(e, t, n) {
    let o;
    if ("viewport" === t)
        o = function(e, t) {
            const n = hu(e)
              , o = vu(e)
              , a = n.visualViewport;
            let r = o.clientWidth
              , s = o.clientHeight
              , i = 0
              , l = 0;
            if (a) {
                r = a.width,
                s = a.height;
                const e = Mu();
                (!e || e && "fixed" === t) && (i = a.offsetLeft,
                l = a.offsetTop)
            }
            return {
                width: r,
                height: s,
                x: i,
                y: l
            }
        }(e, n);
    else if ("document" === t)
        o = function(e) {
            const t = vu(e)
              , n = Lu(e)
              , o = e.ownerDocument.body
              , a = Nl(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth)
              , r = Nl(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
            let s = -n.scrollLeft + Zu(e);
            const i = -n.scrollTop;
            return "rtl" === Iu(o).direction && (s += Nl(t.clientWidth, o.clientWidth) - a),
            {
                width: a,
                height: r,
                x: s,
                y: i
            }
        }(vu(e));
    else if (gu(t))
        o = function(e, t) {
            const n = Uu(e, !0, "fixed" === t)
              , o = n.top + e.clientTop
              , a = n.left + e.clientLeft
              , r = yu(e) ? $u(e) : Fl(1);
            return {
                width: e.clientWidth * r.x,
                height: e.clientHeight * r.y,
                x: a * r.x,
                y: o * r.y
            }
        }(t, n);
    else {
        const n = Hu(e);
        o = {
            x: t.x - n.x,
            y: t.y - n.y,
            width: t.width,
            height: t.height
        }
    }
    return su(o)
}
function Ku(e, t) {
    const n = Ru(e);
    return !(n === t || !gu(n) || Bu(n)) && ("fixed" === Iu(n).position || Ku(n, t))
}
function Yu(e, t, n) {
    const o = yu(t)
      , a = vu(t)
      , r = "fixed" === n
      , s = Uu(e, !0, r, t);
    let i = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const l = Fl(0);
    function u() {
        l.x = Zu(a)
    }
    if (o || !o && !r)
        if (("body" !== fu(t) || _u(a)) && (i = Lu(t)),
        o) {
            const e = Uu(t, !0, r, t);
            l.x = e.x + t.clientLeft,
            l.y = e.y + t.clientTop
        } else
            a && u();
    r && !o && a && u();
    const c = !a || o || r ? Fl(0) : qu(a, i);
    return {
        x: s.left + i.scrollLeft - l.x - c.x,
        y: s.top + i.scrollTop - l.y - c.y,
        width: s.width,
        height: s.height
    }
}
function Xu(e) {
    return "static" === Iu(e).position
}
function Ju(e, t) {
    if (!yu(e) || "fixed" === Iu(e).position)
        return null;
    if (t)
        return t(e);
    let n = e.offsetParent;
    return vu(e) === n && (n = n.ownerDocument.body),
    n
}
function Qu(e, t) {
    const n = hu(e);
    if (Cu(e))
        return n;
    if (!yu(e)) {
        let t = Ru(e);
        for (; t && !Bu(t); ) {
            if (gu(t) && !Xu(t))
                return t;
            t = Ru(t)
        }
        return n
    }
    let o = Ju(e, t);
    for (; o && ku(o) && Xu(o); )
        o = Ju(o, t);
    return o && Bu(o) && Xu(o) && !Ou(o) ? n : o || function(e) {
        let t = Ru(e);
        for (; yu(t) && !Bu(t); ) {
            if (Ou(t))
                return t;
            if (Cu(t))
                return null;
            t = Ru(t)
        }
        return null
    }(e) || n
}
const ec = {
    convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
        let {elements: t, rect: n, offsetParent: o, strategy: a} = e;
        const r = "fixed" === a
          , s = vu(o)
          , i = !!t && Cu(t.floating);
        if (o === s || i && r)
            return n;
        let l = {
            scrollLeft: 0,
            scrollTop: 0
        }
          , u = Fl(1);
        const c = Fl(0)
          , d = yu(o);
        if ((d || !d && !r) && (("body" !== fu(o) || _u(s)) && (l = Lu(o)),
        yu(o))) {
            const e = Uu(o);
            u = $u(o),
            c.x = e.x + o.clientLeft,
            c.y = e.y + o.clientTop
        }
        const p = !s || d || r ? Fl(0) : qu(s, l, !0);
        return {
            width: n.width * u.x,
            height: n.height * u.y,
            x: n.x * u.x - l.scrollLeft * u.x + c.x + p.x,
            y: n.y * u.y - l.scrollTop * u.y + c.y + p.y
        }
    },
    getDocumentElement: vu,
    getClippingRect: function(e) {
        let {element: t, boundary: n, rootBoundary: o, strategy: a} = e;
        const r = [..."clippingAncestors" === n ? Cu(t) ? [] : function(e, t) {
            const n = t.get(e);
            if (n)
                return n;
            let o = Nu(e, [], !1).filter(e => gu(e) && "body" !== fu(e))
              , a = null;
            const r = "fixed" === Iu(e).position;
            let s = r ? Ru(e) : e;
            for (; gu(s) && !Bu(s); ) {
                const t = Iu(s)
                  , n = Ou(s);
                n || "fixed" !== t.position || (a = null),
                (r ? !n && !a : !n && "static" === t.position && a && Wu.has(a.position) || _u(s) && !n && Ku(e, s)) ? o = o.filter(e => e !== s) : a = t,
                s = Ru(s)
            }
            return t.set(e, o),
            o
        }(t, this._c) : [].concat(n), o]
          , s = r[0]
          , i = r.reduce( (e, n) => {
            const o = Gu(t, n, a);
            return e.top = Nl(o.top, e.top),
            e.right = zl(o.right, e.right),
            e.bottom = zl(o.bottom, e.bottom),
            e.left = Nl(o.left, e.left),
            e
        }
        , Gu(t, s, a));
        return {
            width: i.right - i.left,
            height: i.bottom - i.top,
            x: i.left,
            y: i.top
        }
    },
    getOffsetParent: Qu,
    getElementRects: async function(e) {
        const t = this.getOffsetParent || Qu
          , n = this.getDimensions
          , o = await n(e.floating);
        return {
            reference: Yu(e.reference, await t(e.floating), e.strategy),
            floating: {
                x: 0,
                y: 0,
                width: o.width,
                height: o.height
            }
        }
    },
    getClientRects: function(e) {
        return Array.from(e.getClientRects())
    },
    getDimensions: function(e) {
        const {width: t, height: n} = ju(e);
        return {
            width: t,
            height: n
        }
    },
    getScale: $u,
    isElement: gu,
    isRTL: function(e) {
        return "rtl" === Iu(e).direction
    }
};
function tc(e, t) {
    return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height
}
function nc(e, t, n, o) {
    void 0 === o && (o = {});
    const {ancestorScroll: a=!0, ancestorResize: r=!0, elementResize: s="function" == typeof ResizeObserver, layoutShift: i="function" == typeof IntersectionObserver, animationFrame: l=!1} = o
      , u = Fu(e)
      , c = a || r ? [...u ? Nu(u) : [], ...Nu(t)] : [];
    c.forEach(e => {
        a && e.addEventListener("scroll", n, {
            passive: !0
        }),
        r && e.addEventListener("resize", n)
    }
    );
    const d = u && i ? function(e, t) {
        let n, o = null;
        const a = vu(e);
        function r() {
            var e;
            clearTimeout(n),
            null == (e = o) || e.disconnect(),
            o = null
        }
        return function s(i, l) {
            void 0 === i && (i = !1),
            void 0 === l && (l = 1),
            r();
            const u = e.getBoundingClientRect()
              , {left: c, top: d, width: p, height: f} = u;
            if (i || t(),
            !p || !f)
                return;
            const h = {
                rootMargin: -jl(d) + "px " + -jl(a.clientWidth - (c + p)) + "px " + -jl(a.clientHeight - (d + f)) + "px " + -jl(c) + "px",
                threshold: Nl(0, zl(1, l)) || 1
            };
            let v = !0;
            function m(t) {
                const o = t[0].intersectionRatio;
                if (o !== l) {
                    if (!v)
                        return s();
                    o ? s(!1, o) : n = setTimeout( () => {
                        s(!1, 1e-7)
                    }
                    , 1e3)
                }
                1 !== o || tc(u, e.getBoundingClientRect()) || s(),
                v = !1
            }
            try {
                o = new IntersectionObserver(m,{
                    ...h,
                    root: a.ownerDocument
                })
            } catch (g) {
                o = new IntersectionObserver(m,h)
            }
            o.observe(e)
        }(!0),
        r
    }(u, n) : null;
    let p, f = -1, h = null;
    s && (h = new ResizeObserver(e => {
        let[o] = e;
        o && o.target === u && h && (h.unobserve(t),
        cancelAnimationFrame(f),
        f = requestAnimationFrame( () => {
            var e;
            null == (e = h) || e.observe(t)
        }
        )),
        n()
    }
    ),
    u && !l && h.observe(u),
    h.observe(t));
    let v = l ? Uu(e) : null;
    return l && function t() {
        const o = Uu(e);
        v && !tc(v, o) && n();
        v = o,
        p = requestAnimationFrame(t)
    }(),
    n(),
    () => {
        var e;
        c.forEach(e => {
            a && e.removeEventListener("scroll", n),
            r && e.removeEventListener("resize", n)
        }
        ),
        null == d || d(),
        null == (e = h) || e.disconnect(),
        h = null,
        l && cancelAnimationFrame(p)
    }
}
const oc = function(e) {
    return void 0 === e && (e = 0),
    {
        name: "offset",
        options: e,
        async fn(t) {
            var n, o;
            const {x: a, y: r, placement: s, middlewareData: i} = t
              , l = await async function(e, t) {
                const {placement: n, platform: o, elements: a} = e
                  , r = await (null == o.isRTL ? void 0 : o.isRTL(a.floating))
                  , s = Zl(n)
                  , i = ql(n)
                  , l = "y" === Yl(n)
                  , u = du.has(s) ? -1 : 1
                  , c = r && l ? -1 : 1
                  , d = Ul(t, e);
                let {mainAxis: p, crossAxis: f, alignmentAxis: h} = "number" == typeof d ? {
                    mainAxis: d,
                    crossAxis: 0,
                    alignmentAxis: null
                } : {
                    mainAxis: d.mainAxis || 0,
                    crossAxis: d.crossAxis || 0,
                    alignmentAxis: d.alignmentAxis
                };
                return i && "number" == typeof h && (f = "end" === i ? -1 * h : h),
                l ? {
                    x: f * c,
                    y: p * u
                } : {
                    x: p * u,
                    y: f * c
                }
            }(t, e);
            return s === (null == (n = i.offset) ? void 0 : n.placement) && null != (o = i.arrow) && o.alignmentOffset ? {} : {
                x: a + l.x,
                y: r + l.y,
                data: {
                    ...l,
                    placement: s
                }
            }
        }
    }
}
  , ac = function(e) {
    return void 0 === e && (e = {}),
    {
        name: "shift",
        options: e,
        async fn(t) {
            const {x: n, y: o, placement: a} = t
              , {mainAxis: r=!0, crossAxis: s=!1, limiter: i={
                fn: e => {
                    let {x: t, y: n} = e;
                    return {
                        x: t,
                        y: n
                    }
                }
            }, ...l} = Ul(e, t)
              , u = {
                x: n,
                y: o
            }
              , c = await lu(t, l)
              , d = Yl(Zl(a))
              , p = Wl(d);
            let f = u[p]
              , h = u[d];
            if (r) {
                const e = "y" === p ? "bottom" : "right";
                f = Hl(f + c["y" === p ? "top" : "left"], f, f - c[e])
            }
            if (s) {
                const e = "y" === d ? "bottom" : "right";
                h = Hl(h + c["y" === d ? "top" : "left"], h, h - c[e])
            }
            const v = i.fn({
                ...t,
                [p]: f,
                [d]: h
            });
            return {
                ...v,
                data: {
                    x: v.x - n,
                    y: v.y - o,
                    enabled: {
                        [p]: r,
                        [d]: s
                    }
                }
            }
        }
    }
}
  , rc = function(e) {
    return void 0 === e && (e = {}),
    {
        name: "flip",
        options: e,
        async fn(t) {
            var n, o;
            const {placement: a, middlewareData: r, rects: s, initialPlacement: i, platform: l, elements: u} = t
              , {mainAxis: c=!0, crossAxis: d=!0, fallbackPlacements: p, fallbackStrategy: f="bestFit", fallbackAxisSideDirection: h="none", flipAlignment: v=!0, ...m} = Ul(e, t);
            if (null != (n = r.arrow) && n.alignmentOffset)
                return {};
            const g = Zl(a)
              , y = Yl(i)
              , b = Zl(i) === i
              , w = await (null == l.isRTL ? void 0 : l.isRTL(u.floating))
              , _ = p || (b || !v ? [au(i)] : function(e) {
                const t = au(e);
                return [Jl(e), t, Jl(t)]
            }(i))
              , x = "none" !== h;
            !p && x && _.push(...ou(i, v, h, w));
            const k = [i, ..._]
              , S = await lu(t, m)
              , C = [];
            let E = (null == (o = r.flip) ? void 0 : o.overflows) || [];
            if (c && C.push(S[g]),
            d) {
                const e = function(e, t, n) {
                    void 0 === n && (n = !1);
                    const o = ql(e)
                      , a = Xl(e)
                      , r = Gl(a);
                    let s = "x" === a ? o === (n ? "end" : "start") ? "right" : "left" : "start" === o ? "bottom" : "top";
                    return t.reference[r] > t.floating[r] && (s = au(s)),
                    [s, au(s)]
                }(a, s, w);
                C.push(S[e[0]], S[e[1]])
            }
            if (E = [...E, {
                placement: a,
                overflows: C
            }],
            !C.every(e => e <= 0)) {
                var T, A;
                const e = ((null == (T = r.flip) ? void 0 : T.index) || 0) + 1
                  , t = k[e];
                if (t) {
                    if (!("alignment" === d && y !== Yl(t)) || E.every(e => e.overflows[0] > 0 && Yl(e.placement) === y))
                        return {
                            data: {
                                index: e,
                                overflows: E
                            },
                            reset: {
                                placement: t
                            }
                        }
                }
                let n = null == (A = E.filter(e => e.overflows[0] <= 0).sort( (e, t) => e.overflows[1] - t.overflows[1])[0]) ? void 0 : A.placement;
                if (!n)
                    switch (f) {
                    case "bestFit":
                        {
                            var O;
                            const e = null == (O = E.filter(e => {
                                if (x) {
                                    const t = Yl(e.placement);
                                    return t === y || "y" === t
                                }
                                return !0
                            }
                            ).map(e => [e.placement, e.overflows.filter(e => e > 0).reduce( (e, t) => e + t, 0)]).sort( (e, t) => e[1] - t[1])[0]) ? void 0 : O[0];
                            e && (n = e);
                            break
                        }
                    case "initialPlacement":
                        n = i
                    }
                if (a !== n)
                    return {
                        reset: {
                            placement: n
                        }
                    }
            }
            return {}
        }
    }
}
  , sc = function(e) {
    return void 0 === e && (e = {}),
    {
        name: "size",
        options: e,
        async fn(t) {
            var n, o;
            const {placement: a, rects: r, platform: s, elements: i} = t
              , {apply: l= () => {}
            , ...u} = Ul(e, t)
              , c = await lu(t, u)
              , d = Zl(a)
              , p = ql(a)
              , f = "y" === Yl(a)
              , {width: h, height: v} = r.floating;
            let m, g;
            "top" === d || "bottom" === d ? (m = d,
            g = p === (await (null == s.isRTL ? void 0 : s.isRTL(i.floating)) ? "start" : "end") ? "left" : "right") : (g = d,
            m = "end" === p ? "top" : "bottom");
            const y = v - c.top - c.bottom
              , b = h - c.left - c.right
              , w = zl(v - c[m], y)
              , _ = zl(h - c[g], b)
              , x = !t.middlewareData.shift;
            let k = w
              , S = _;
            if (null != (n = t.middlewareData.shift) && n.enabled.x && (S = b),
            null != (o = t.middlewareData.shift) && o.enabled.y && (k = y),
            x && !p) {
                const e = Nl(c.left, 0)
                  , t = Nl(c.right, 0)
                  , n = Nl(c.top, 0)
                  , o = Nl(c.bottom, 0);
                f ? S = h - 2 * (0 !== e || 0 !== t ? e + t : Nl(c.left, c.right)) : k = v - 2 * (0 !== n || 0 !== o ? n + o : Nl(c.top, c.bottom))
            }
            await l({
                ...t,
                availableWidth: S,
                availableHeight: k
            });
            const C = await s.getDimensions(i.floating);
            return h !== C.width || v !== C.height ? {
                reset: {
                    rects: !0
                }
            } : {}
        }
    }
}
  , ic = function(e) {
    return void 0 === e && (e = {}),
    {
        name: "hide",
        options: e,
        async fn(t) {
            const {rects: n} = t
              , {strategy: o="referenceHidden", ...a} = Ul(e, t);
            switch (o) {
            case "referenceHidden":
                {
                    const e = uu(await lu(t, {
                        ...a,
                        elementContext: "reference"
                    }), n.reference);
                    return {
                        data: {
                            referenceHiddenOffsets: e,
                            referenceHidden: cu(e)
                        }
                    }
                }
            case "escaped":
                {
                    const e = uu(await lu(t, {
                        ...a,
                        altBoundary: !0
                    }), n.floating);
                    return {
                        data: {
                            escapedOffsets: e,
                            escaped: cu(e)
                        }
                    }
                }
            default:
                return {}
            }
        }
    }
}
  , lc = e => ({
    name: "arrow",
    options: e,
    async fn(t) {
        const {x: n, y: o, placement: a, rects: r, platform: s, elements: i, middlewareData: l} = t
          , {element: u, padding: c=0} = Ul(e, t) || {};
        if (null == u)
            return {};
        const d = ru(c)
          , p = {
            x: n,
            y: o
        }
          , f = Xl(a)
          , h = Gl(f)
          , v = await s.getDimensions(u)
          , m = "y" === f
          , g = m ? "top" : "left"
          , y = m ? "bottom" : "right"
          , b = m ? "clientHeight" : "clientWidth"
          , w = r.reference[h] + r.reference[f] - p[f] - r.floating[h]
          , _ = p[f] - r.reference[f]
          , x = await (null == s.getOffsetParent ? void 0 : s.getOffsetParent(u));
        let k = x ? x[b] : 0;
        k && await (null == s.isElement ? void 0 : s.isElement(x)) || (k = i.floating[b] || r.floating[h]);
        const S = w / 2 - _ / 2
          , C = k / 2 - v[h] / 2 - 1
          , E = zl(d[g], C)
          , T = zl(d[y], C)
          , A = E
          , O = k - v[h] - T
          , M = k / 2 - v[h] / 2 + S
          , P = Hl(A, M, O)
          , B = !l.arrow && null != ql(a) && M !== P && r.reference[h] / 2 - (M < A ? E : T) - v[h] / 2 < 0
          , I = B ? M < A ? M - A : M - O : 0;
        return {
            [f]: p[f] + I,
            data: {
                [f]: P,
                centerOffset: M - P - I,
                ...B && {
                    alignmentOffset: I
                }
            },
            reset: B
        }
    }
})
  , uc = function(e) {
    return void 0 === e && (e = {}),
    {
        options: e,
        fn(t) {
            const {x: n, y: o, placement: a, rects: r, middlewareData: s} = t
              , {offset: i=0, mainAxis: l=!0, crossAxis: u=!0} = Ul(e, t)
              , c = {
                x: n,
                y: o
            }
              , d = Yl(a)
              , p = Wl(d);
            let f = c[p]
              , h = c[d];
            const v = Ul(i, t)
              , m = "number" == typeof v ? {
                mainAxis: v,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ...v
            };
            if (l) {
                const e = "y" === p ? "height" : "width"
                  , t = r.reference[p] - r.floating[e] + m.mainAxis
                  , n = r.reference[p] + r.reference[e] - m.mainAxis;
                f < t ? f = t : f > n && (f = n)
            }
            if (u) {
                var g, y;
                const e = "y" === p ? "width" : "height"
                  , t = du.has(Zl(a))
                  , n = r.reference[d] - r.floating[e] + (t && (null == (g = s.offset) ? void 0 : g[d]) || 0) + (t ? 0 : m.crossAxis)
                  , o = r.reference[d] + r.reference[e] + (t ? 0 : (null == (y = s.offset) ? void 0 : y[d]) || 0) - (t ? m.crossAxis : 0);
                h < n ? h = n : h > o && (h = o)
            }
            return {
                [p]: f,
                [d]: h
            }
        }
    }
}
  , cc = (e, t, n) => {
    const o = new Map
      , a = {
        platform: ec,
        ...n
    }
      , r = {
        ...a.platform,
        _c: o
    };
    return (async (e, t, n) => {
        const {placement: o="bottom", strategy: a="absolute", middleware: r=[], platform: s} = n
          , i = r.filter(Boolean)
          , l = await (null == s.isRTL ? void 0 : s.isRTL(t));
        let u = await s.getElementRects({
            reference: e,
            floating: t,
            strategy: a
        })
          , {x: c, y: d} = iu(u, o, l)
          , p = o
          , f = {}
          , h = 0;
        for (let v = 0; v < i.length; v++) {
            const {name: n, fn: r} = i[v]
              , {x: m, y: g, data: y, reset: b} = await r({
                x: c,
                y: d,
                initialPlacement: o,
                placement: p,
                strategy: a,
                middlewareData: f,
                rects: u,
                platform: s,
                elements: {
                    reference: e,
                    floating: t
                }
            });
            c = null != m ? m : c,
            d = null != g ? g : d,
            f = {
                ...f,
                [n]: {
                    ...f[n],
                    ...y
                }
            },
            b && h <= 50 && (h++,
            "object" == typeof b && (b.placement && (p = b.placement),
            b.rects && (u = !0 === b.rects ? await s.getElementRects({
                reference: e,
                floating: t,
                strategy: a
            }) : b.rects),
            ({x: c, y: d} = iu(u, p, l))),
            v = -1)
        }
        return {
            x: c,
            y: d,
            placement: p,
            strategy: a,
            middlewareData: f
        }
    }
    )(e, t, {
        ...a,
        platform: r
    })
}
;
function dc(e) {
    if (function(e) {
        return null != e && "object" == typeof e && "$el"in e
    }(e)) {
        const t = e.$el;
        return mu(t) && "#comment" === fu(t) ? null : t
    }
    return e
}
function pc(e) {
    return "function" == typeof e ? e() : Nt(e)
}
function fc(e) {
    if ("undefined" == typeof window)
        return 1;
    return (e.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function hc(e, t) {
    const n = fc(e);
    return Math.round(t * n) / n
}
function vc(e) {
    return e ? e.flatMap(e => e.type === _r ? vc(e.children) : [e]) : []
}
const mc = to({
    name: "PrimitiveSlot",
    inheritAttrs: !1,
    setup: (e, {attrs: t, slots: n}) => () => {
        var e;
        if (!n.default)
            return null;
        const o = vc(n.default())
          , a = o.findIndex(e => e.type !== kr);
        if (-1 === a)
            return o;
        const r = o[a];
        null == (e = r.props) || delete e.ref;
        const s = r.props ? Gr(t, r.props) : t
          , i = $r({
            ...r,
            props: {}
        }, s);
        return 1 === o.length ? i : (o[a] = i,
        o)
    }
})
  , gc = ["area", "img", "input"]
  , yc = to({
    name: "Primitive",
    inheritAttrs: !1,
    props: {
        asChild: {
            type: Boolean,
            default: !1
        },
        as: {
            type: [String, Object],
            default: "div"
        }
    },
    setup(e, {attrs: t, slots: n}) {
        const o = e.asChild ? "template" : e.as;
        return "string" == typeof o && gc.includes(o) ? () => gs(o, t) : "template" !== o ? () => gs(e.as, t, {
            default: n.default
        }) : () => gs(mc, t, {
            default: n.default
        })
    }
})
  , bc = to({
    __name: "VisuallyHidden",
    props: {
        feature: {
            default: "focusable"
        },
        asChild: {
            type: Boolean
        },
        as: {
            default: "span"
        }
    },
    setup: e => (e, t) => (Tr(),
    Ir(Nt(yc), {
        as: e.as,
        "as-child": e.asChild,
        "aria-hidden": "focusable" === e.feature ? "true" : void 0,
        "data-hidden": "fully-hidden" === e.feature ? "" : void 0,
        tabindex: "fully-hidden" === e.feature ? "-1" : void 0,
        style: {
            position: "absolute",
            border: 0,
            width: "1px",
            height: "1px",
            padding: 0,
            margin: "-1px",
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            clipPath: "inset(50%)",
            whiteSpace: "nowrap",
            wordWrap: "normal"
        }
    }, {
        default: En( () => [Wo(e.$slots, "default")]),
        _: 3
    }, 8, ["as", "as-child", "aria-hidden", "data-hidden", "tabindex"]))
});
function wc(e) {
    return !!ue() && (ce(e),
    !0)
}
function _c(e) {
    return Bt(t = ms(e)) ? bt(new Proxy({},{
        get: (e, n, o) => Nt(Reflect.get(t.value, n, o)),
        set: (e, n, o) => (Bt(t.value[n]) && !Bt(o) ? t.value[n].value = o : t.value[n] = o,
        !0),
        deleteProperty: (e, n) => Reflect.deleteProperty(t.value, n),
        has: (e, n) => Reflect.has(t.value, n),
        ownKeys: () => Object.keys(t.value),
        getOwnPropertyDescriptor: () => ({
            enumerable: !0,
            configurable: !0
        })
    })) : bt(t);
    var t
}
const xc = "undefined" != typeof window && "undefined" != typeof document;
"undefined" != typeof WorkerGlobalScope && (globalThis,
WorkerGlobalScope);
const kc = Object.prototype.toString
  , Sc = Cc();
function Cc() {
    var e, t;
    return xc && (null == (e = null == window ? void 0 : window.navigator) ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || (null == (t = null == window ? void 0 : window.navigator) ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(null == window ? void 0 : window.navigator.userAgent))
}
function Ec(e) {
    return Array.isArray(e) ? e : [e]
}
function Tc(e, t=1e4) {
    return Vt( (n, o) => {
        let a, r = Dt(e);
        return wc( () => {
            clearTimeout(a)
        }
        ),
        {
            get: () => (n(),
            r),
            set(n) {
                r = n,
                o(),
                clearTimeout(a),
                a = setTimeout( () => {
                    r = Dt(e),
                    o()
                }
                , Dt(t))
            }
        }
    }
    )
}
const Ac = Dt;
function Oc(e, t) {
    es() && Io(e, t)
}
const Mc = xc ? window : void 0;
function Pc(e) {
    var t;
    const n = Dt(e);
    return null != (t = null == n ? void 0 : n.$el) ? t : n
}
function Bc(...e) {
    const t = []
      , n = () => {
        t.forEach(e => e()),
        t.length = 0
    }
      , o = ms( () => {
        const t = Ec(Dt(e[0])).filter(e => null != e);
        return t.every(e => "string" != typeof e) ? t : void 0
    }
    )
      , a = (r = ([e,o,a,r]) => {
        if (n(),
        !(null == e ? void 0 : e.length) || !(null == o ? void 0 : o.length) || !(null == a ? void 0 : a.length))
            return;
        const s = (i = r,
        "[object Object]" === kc.call(i) ? {
            ...r
        } : r);
        var i;
        t.push(...e.flatMap(e => o.flatMap(t => a.map(n => ( (e, t, n, o) => (e.addEventListener(t, n, o),
        () => e.removeEventListener(t, n, o)))(e, t, n, s)))))
    }
    ,
    s = {
        flush: "post"
    },
    Qa( () => {
        var t, n;
        return [null != (n = null == (t = o.value) ? void 0 : t.map(e => Pc(e))) ? n : [Mc].filter(e => null != e), Ec(Dt(o.value ? e[1] : e[0])), Ec(Nt(o.value ? e[2] : e[1])), Dt(o.value ? e[3] : e[2])]
    }
    , r, {
        ...s,
        immediate: !0
    }));
    var r, s;
    return wc(n),
    () => {
        a(),
        n()
    }
}
function Ic() {
    const e = Lt(!1)
      , t = es();
    return t && Mo( () => {
        e.value = !0
    }
    , t),
    e
}
function Lc(...e) {
    let t, n, o = {};
    3 === e.length ? (t = e[0],
    n = e[1],
    o = e[2]) : 2 === e.length ? "object" == typeof e[1] ? (t = !0,
    n = e[0],
    o = e[1]) : (t = e[0],
    n = e[1]) : (t = !0,
    n = e[0]);
    const {target: a=Mc, eventName: r="keydown", passive: s=!1, dedupe: i=!1} = o
      , l = "function" == typeof (u = t) ? u : "string" == typeof u ? e => e.key === u : Array.isArray(u) ? e => u.includes(e.key) : () => !0;
    var u;
    return Bc(a, r, e => {
        e.repeat && Dt(i) || l(e) && n(e)
    }
    , s)
}
function Rc(e, t, n={}) {
    const {window: o=Mc, ...a} = n;
    let r;
    const s = function(e) {
        const t = Ic();
        return ms( () => (t.value,
        Boolean(e())))
    }( () => o && "ResizeObserver"in o)
      , i = () => {
        r && (r.disconnect(),
        r = void 0)
    }
      , l = Qa(ms( () => {
        const t = Dt(e);
        return Array.isArray(t) ? t.map(e => Pc(e)) : [Pc(t)]
    }
    ), e => {
        if (i(),
        s.value && o) {
            r = new ResizeObserver(t);
            for (const t of e)
                t && r.observe(t, a)
        }
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , u = () => {
        i(),
        l()
    }
    ;
    return wc(u),
    {
        isSupported: s,
        stop: u
    }
}
function zc(e, t, n, o={}) {
    var a, r, s;
    const {clone: i=!1, passive: l=!1, eventName: u, deep: c=!1, defaultValue: d, shouldEmit: p} = o
      , f = es()
      , h = n || (null == f ? void 0 : f.emit) || (null == (a = null == f ? void 0 : f.$emit) ? void 0 : a.bind(f)) || (null == (s = null == (r = null == f ? void 0 : f.proxy) ? void 0 : r.$emit) ? void 0 : s.bind(null == f ? void 0 : f.proxy));
    let v = u;
    t || (t = "modelValue"),
    v = v || `update:${t.toString()}`;
    const m = e => {
        return i ? "function" == typeof i ? i(e) : (t = e,
        JSON.parse(JSON.stringify(t))) : e;
        var t
    }
      , g = () => void 0 !== e[t] ? m(e[t]) : d
      , y = e => {
        p ? p(e) && h(v, e) : h(v, e)
    }
    ;
    if (l) {
        const n = It(g());
        let o = !1;
        return Qa( () => e[t], e => {
            o || (o = !0,
            n.value = m(e),
            fn( () => o = !1))
        }
        ),
        Qa(n, n => {
            o || n === e[t] && !c || y(n)
        }
        , {
            deep: c
        }),
        n
    }
    return ms({
        get: () => g(),
        set(e) {
            y(e)
        }
    })
}
function Nc(e, t) {
    const n = Symbol("string" != typeof e || t ? t : `${e}Context`);
    return [t => {
        const o = xa(n, t);
        if (o)
            return o;
        if (null === o)
            return o;
        throw new Error(`Injection \`${n.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`)
    }
    , e => (_a(n, e),
    e)]
}
function Dc(e) {
    return "string" == typeof e ? `'${e}'` : (new jc).serialize(e)
}
const jc = function() {
    var e;
    class n {
        constructor() {
            var n, o, a;
            n = this,
            o = e,
            a = new Map,
            o.has(n) ? t("Cannot add the same private member more than once") : o instanceof WeakSet ? o.add(n) : o.set(n, a)
        }
        compare(e, t) {
            const n = typeof e
              , o = typeof t;
            return "string" === n && "string" === o ? e.localeCompare(t) : "number" === n && "number" === o ? e - t : String.prototype.localeCompare.call(this.serialize(e, !0), this.serialize(t, !0))
        }
        serialize(e, t) {
            if (null === e)
                return "null";
            switch (typeof e) {
            case "string":
                return t ? e : `'${e}'`;
            case "bigint":
                return `${e}n`;
            case "object":
                return this.$object(e);
            case "function":
                return this.$function(e)
            }
            return String(e)
        }
        serializeObject(e) {
            const t = Object.prototype.toString.call(e);
            if ("[object Object]" !== t)
                return this.serializeBuiltInType(t.length < 10 ? `unknown:${t}` : t.slice(8, -1), e);
            const n = e.constructor
              , o = n === Object || void 0 === n ? "" : n.name;
            if ("" !== o && globalThis[o] === n)
                return this.serializeBuiltInType(o, e);
            if ("function" == typeof e.toJSON) {
                const t = e.toJSON();
                return o + (null !== t && "object" == typeof t ? this.$object(t) : `(${this.serialize(t)})`)
            }
            return this.serializeObjectEntries(o, Object.entries(e))
        }
        serializeBuiltInType(e, t) {
            const n = this["$" + e];
            if (n)
                return n.call(this, t);
            if ("function" == typeof (null == t ? void 0 : t.entries))
                return this.serializeObjectEntries(e, t.entries());
            throw new Error(`Cannot serialize ${e}`)
        }
        serializeObjectEntries(e, t) {
            const n = Array.from(t).sort( (e, t) => this.compare(e[0], t[0]));
            let o = `${e}{`;
            for (let a = 0; a < n.length; a++) {
                const [e,t] = n[a];
                o += `${this.serialize(e, !0)}:${this.serialize(t)}`,
                a < n.length - 1 && (o += ",")
            }
            return o + "}"
        }
        $object(t) {
            let n = o(this, e).get(t);
            return void 0 === n && (o(this, e).set(t, `#${o(this, e).size}`),
            n = this.serializeObject(t),
            o(this, e).set(t, n)),
            n
        }
        $function(e) {
            const t = Function.prototype.toString.call(e);
            return "[native code] }" === t.slice(-15) ? `${e.name || ""}()[native]` : `${e.name}(${e.length})${t.replace(/\s*\n\s*/g, "")}`
        }
        $Array(e) {
            let t = "[";
            for (let n = 0; n < e.length; n++)
                t += this.serialize(e[n]),
                n < e.length - 1 && (t += ",");
            return t + "]"
        }
        $Date(e) {
            try {
                return `Date(${e.toISOString()})`
            } catch {
                return "Date(null)"
            }
        }
        $ArrayBuffer(e) {
            return `ArrayBuffer[${new Uint8Array(e).join(",")}]`
        }
        $Set(e) {
            return `Set${this.$Array(Array.from(e).sort( (e, t) => this.compare(e, t)))}`
        }
        $Map(e) {
            return this.serializeObjectEntries("Map", e.entries())
        }
    }
    e = new WeakMap;
    for (const t of ["Error", "RegExp", "URL"])
        n.prototype["$" + t] = function(e) {
            return `${t}(${e})`
        }
        ;
    for (const t of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"])
        n.prototype["$" + t] = function(e) {
            return `${t}[${e.join(",")}]`
        }
        ;
    for (const t of ["BigInt64Array", "BigUint64Array"])
        n.prototype["$" + t] = function(e) {
            return `${t}[${e.join("n,")}${e.length > 0 ? "n" : ""}]`
        }
        ;
    return n
}();
function Fc(e) {
    return null == e
}
const [$c,Vc] = Nc("ConfigProvider");
function Hc(e) {
    const t = $c({
        dir: It("ltr")
    });
    return ms( () => {
        var n;
        return (null == e ? void 0 : e.value) || (null == (n = t.dir) ? void 0 : n.value) || "ltr"
    }
    )
}
function Uc() {
    const e = es()
      , t = It()
      , n = ms( () => {
        var e, n;
        return ["#text", "#comment"].includes(null == (e = t.value) ? void 0 : e.$el.nodeName) ? null == (n = t.value) ? void 0 : n.$el.nextElementSibling : Pc(t)
    }
    )
      , o = Object.assign({}, e.exposed)
      , a = {};
    for (const r in e.props)
        Object.defineProperty(a, r, {
            enumerable: !0,
            configurable: !0,
            get: () => e.props[r]
        });
    if (Object.keys(o).length > 0)
        for (const r in o)
            Object.defineProperty(a, r, {
                enumerable: !0,
                configurable: !0,
                get: () => o[r]
            });
    return Object.defineProperty(a, "$el", {
        enumerable: !0,
        configurable: !0,
        get: () => e.vnode.el
    }),
    e.exposed = a,
    {
        forwardRef: function(n) {
            t.value = n,
            n && (Object.defineProperty(a, "$el", {
                enumerable: !0,
                configurable: !0,
                get: () => n instanceof Element ? n : n.$el
            }),
            e.exposed = a)
        },
        currentRef: t,
        currentElement: n
    }
}
const Zc = ["INPUT", "TEXTAREA"];
function qc(e, t, n, o={}) {
    if (!t || o.enableIgnoredElement && Zc.includes(t.nodeName))
        return null;
    const {arrowKeyOptions: a="both", attributeName: r="[data-reka-collection-item]", itemsArray: s=[], loop: i=!0, dir: l="ltr", preventScroll: u=!0, focus: c=!1} = o
      , [d,p,f,h,v,m] = ["ArrowRight" === e.key, "ArrowLeft" === e.key, "ArrowUp" === e.key, "ArrowDown" === e.key, "Home" === e.key, "End" === e.key]
      , g = f || h
      , y = d || p;
    if (!v && !m && (!g && !y || "vertical" === a && y || "horizontal" === a && g))
        return null;
    const b = s;
    if (!b.length)
        return null;
    u && e.preventDefault();
    let w = null;
    if (y || g) {
        w = Wc(b, t, {
            goForward: g ? h : "ltr" === l ? d : p,
            loop: i
        })
    } else
        v ? w = b.at(0) || null : m && (w = b.at(-1) || null);
    return c && (null == w || w.focus()),
    w
}
function Wc(e, t, n, o=e.length) {
    if (0 === --o)
        return null;
    const a = e.indexOf(t)
      , r = n.goForward ? a + 1 : a - 1;
    if (!n.loop && (r < 0 || r >= e.length))
        return null;
    const s = e[(r + e.length) % e.length];
    if (!s)
        return null;
    return s.hasAttribute("disabled") && "false" !== s.getAttribute("disabled") ? Wc(e, s, n, o) : s
}
let Gc = 0;
function Kc(e, t="reka") {
    const n = $c({
        useId: void 0
    });
    return Object.hasOwn(cl, "useId") ? `${t}-${null == no ? void 0 : no()}` : n.useId ? `${t}-${n.useId()}` : `${t}-${++Gc}`
}
function Yc(e, t) {
    const n = It(e);
    return {
        state: n,
        dispatch: e => {
            n.value = function(e) {
                return t[n.value][e] ?? n.value
            }(e)
        }
    }
}
function Xc(e) {
    return e && getComputedStyle(e).animationName || "none"
}
const Jc = to({
    name: "Presence",
    props: {
        present: {
            type: Boolean,
            required: !0
        },
        forceMount: {
            type: Boolean
        }
    },
    slots: {},
    setup(e, {slots: t, expose: n}) {
        var o;
        const {present: a, forceMount: r} = Ht(e)
          , s = It()
          , {isPresent: i} = function(e, t) {
            var n;
            const o = It({})
              , a = It("none")
              , r = It(e)
              , s = e.value ? "mounted" : "unmounted";
            let i;
            const l = (null == (n = t.value) ? void 0 : n.ownerDocument.defaultView) ?? Mc
              , {state: u, dispatch: c} = Yc(s, {
                mounted: {
                    UNMOUNT: "unmounted",
                    ANIMATION_OUT: "unmountSuspended"
                },
                unmountSuspended: {
                    MOUNT: "mounted",
                    ANIMATION_END: "unmounted"
                },
                unmounted: {
                    MOUNT: "mounted"
                }
            })
              , d = e => {
                var n;
                if (xc) {
                    const o = new CustomEvent(e,{
                        bubbles: !1,
                        cancelable: !1
                    });
                    null == (n = t.value) || n.dispatchEvent(o)
                }
            }
            ;
            Qa(e, async (e, n) => {
                var r;
                const s = n !== e;
                if (await fn(),
                s) {
                    const s = a.value
                      , i = Xc(t.value);
                    e ? (c("MOUNT"),
                    d("enter"),
                    "none" === i && d("after-enter")) : "none" === i || "undefined" === i || "none" === (null == (r = o.value) ? void 0 : r.display) ? (c("UNMOUNT"),
                    d("leave"),
                    d("after-leave")) : n && s !== i ? (c("ANIMATION_OUT"),
                    d("leave")) : (c("UNMOUNT"),
                    d("after-leave"))
                }
            }
            , {
                immediate: !0
            });
            const p = e => {
                const n = Xc(t.value)
                  , o = n.includes(e.animationName)
                  , a = "mounted" === u.value ? "enter" : "leave";
                if (e.target === t.value && o && (d(`after-${a}`),
                c("ANIMATION_END"),
                !r.value)) {
                    const e = t.value.style.animationFillMode;
                    t.value.style.animationFillMode = "forwards",
                    i = null == l ? void 0 : l.setTimeout( () => {
                        var n;
                        "forwards" === (null == (n = t.value) ? void 0 : n.style.animationFillMode) && (t.value.style.animationFillMode = e)
                    }
                    )
                }
                e.target === t.value && "none" === n && c("ANIMATION_END")
            }
              , f = e => {
                e.target === t.value && (a.value = Xc(t.value))
            }
              , h = Qa(t, (e, t) => {
                e ? (o.value = getComputedStyle(e),
                e.addEventListener("animationstart", f),
                e.addEventListener("animationcancel", p),
                e.addEventListener("animationend", p)) : (c("ANIMATION_END"),
                void 0 !== i && (null == l || l.clearTimeout(i)),
                null == t || t.removeEventListener("animationstart", f),
                null == t || t.removeEventListener("animationcancel", p),
                null == t || t.removeEventListener("animationend", p))
            }
            , {
                immediate: !0
            })
              , v = Qa(u, () => {
                const e = Xc(t.value);
                a.value = "mounted" === u.value ? e : "none"
            }
            );
            return Lo( () => {
                h(),
                v()
            }
            ),
            {
                isPresent: ms( () => ["mounted", "unmountSuspended"].includes(u.value))
            }
        }(a, s);
        n({
            present: i
        });
        let l = t.default({
            present: i.value
        });
        l = vc(l || []);
        const u = es();
        if (l && (null == l ? void 0 : l.length) > 1) {
            const e = (null == (o = null == u ? void 0 : u.parent) ? void 0 : o.type.name) ? `<${u.parent.type.name} />` : "component";
            throw new Error([`Detected an invalid children for \`${e}\` for  \`Presence\` component.`, "", "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.", "You can apply a few solutions:", ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map(e => `  - ${e}`).join("\n")].join("\n"))
        }
        return () => r.value || a.value || i.value ? gs(t.default({
            present: i.value
        })[0], {
            ref: e => {
                const t = Pc(e);
                return void 0 === (null == t ? void 0 : t.hasAttribute) || ((null == t ? void 0 : t.hasAttribute("data-reka-popper-content-wrapper")) ? s.value = t.firstElementChild : s.value = t),
                t
            }
        }) : null
    }
})
  , [Qc,ed] = Nc("DialogRoot")
  , td = to({
    inheritAttrs: !1,
    __name: "DialogRoot",
    props: {
        open: {
            type: Boolean,
            default: void 0
        },
        defaultOpen: {
            type: Boolean,
            default: !1
        },
        modal: {
            type: Boolean,
            default: !0
        }
    },
    emits: ["update:open"],
    setup(e, {emit: t}) {
        const n = e
          , o = zc(n, "open", t, {
            defaultValue: n.defaultOpen,
            passive: void 0 === n.open
        })
          , a = It()
          , r = It()
          , {modal: s} = Ht(n);
        return ed({
            open: o,
            modal: s,
            openModal: () => {
                o.value = !0
            }
            ,
            onOpenChange: e => {
                o.value = e
            }
            ,
            onOpenToggle: () => {
                o.value = !o.value
            }
            ,
            contentId: "",
            titleId: "",
            descriptionId: "",
            triggerElement: a,
            contentElement: r
        }),
        (e, t) => Wo(e.$slots, "default", {
            open: Nt(o),
            close: () => o.value = !1
        })
    }
})
  , nd = to({
    __name: "DialogClose",
    props: {
        asChild: {
            type: Boolean
        },
        as: {
            default: "button"
        }
    },
    setup(e) {
        const t = e;
        Uc();
        const n = Qc();
        return (e, o) => (Tr(),
        Ir(Nt(yc), Gr(t, {
            type: "button" === e.as ? "button" : void 0,
            onClick: o[0] || (o[0] = e => Nt(n).onOpenChange(!1))
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["type"]))
    }
});
function od(e) {
    const t = es()
      , n = null == t ? void 0 : t.type.emits
      , o = {};
    return null == n || n.length,
    null == n || n.forEach(t => {
        o[R(P(t))] = (...n) => e(t, ...n)
    }
    ),
    o
}
function ad() {
    let e = document.activeElement;
    if (null == e)
        return null;
    for (; null != e && null != e.shadowRoot && null != e.shadowRoot.activeElement; )
        e = e.shadowRoot.activeElement;
    return e
}
function rd(e) {
    return e ? "open" : "closed"
}
function sd(e) {
    const t = ad();
    for (const n of e) {
        if (n === t)
            return;
        if (n.focus(),
        ad() !== t)
            return
    }
}
const id = function(e) {
    let t, n = !1;
    const o = le(!0);
    return (...a) => (n || (t = o.run( () => e(...a)),
    n = !0),
    t)
}( () => It([]));
function ld(e, t) {
    const n = [...e]
      , o = n.indexOf(t);
    return -1 !== o && n.splice(o, 1),
    n
}
const ud = "focusScope.autoFocusOnMount"
  , cd = "focusScope.autoFocusOnUnmount"
  , dd = {
    bubbles: !1,
    cancelable: !0
};
function pd(e) {
    const t = []
      , n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
        acceptNode: e => {
            const t = "INPUT" === e.tagName && "hidden" === e.type;
            return e.disabled || e.hidden || t ? NodeFilter.FILTER_SKIP : e.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; n.nextNode(); )
        t.push(n.currentNode);
    return t
}
function fd(e, t) {
    for (const n of e)
        if (!hd(n, {
            upTo: t
        }))
            return n
}
function hd(e, {upTo: t}) {
    if ("hidden" === getComputedStyle(e).visibility)
        return !0;
    for (; e; ) {
        if (void 0 !== t && e === t)
            return !1;
        if ("none" === getComputedStyle(e).display)
            return !0;
        e = e.parentElement
    }
    return !1
}
function vd(e, {select: t=!1}={}) {
    if (e && e.focus) {
        const n = ad();
        e.focus({
            preventScroll: !0
        }),
        e !== n && function(e) {
            return e instanceof HTMLInputElement && "select"in e
        }(e) && t && e.select()
    }
}
const md = to({
    __name: "FocusScope",
    props: {
        loop: {
            type: Boolean,
            default: !1
        },
        trapped: {
            type: Boolean,
            default: !1
        },
        asChild: {
            type: Boolean
        },
        as: {}
    },
    emits: ["mountAutoFocus", "unmountAutoFocus"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , {currentRef: a, currentElement: r} = Uc()
          , s = It(null)
          , i = function() {
            const e = id();
            return {
                add(t) {
                    const n = e.value[0];
                    t !== n && (null == n || n.pause()),
                    e.value = ld(e.value, t),
                    e.value.unshift(t)
                },
                remove(t) {
                    var n;
                    e.value = ld(e.value, t),
                    null == (n = e.value[0]) || n.resume()
                }
            }
        }()
          , l = bt({
            paused: !1,
            pause() {
                this.paused = !0
            },
            resume() {
                this.paused = !1
            }
        });
        function u(e) {
            if (!n.loop && !n.trapped)
                return;
            if (l.paused)
                return;
            const t = "Tab" === e.key && !e.altKey && !e.ctrlKey && !e.metaKey
              , o = ad();
            if (t && o) {
                const t = e.currentTarget
                  , [a,r] = function(e) {
                    const t = pd(e);
                    return [fd(t, e), fd(t.reverse(), e)]
                }(t);
                a && r ? e.shiftKey || o !== r ? e.shiftKey && o === a && (e.preventDefault(),
                n.loop && vd(r, {
                    select: !0
                })) : (e.preventDefault(),
                n.loop && vd(a, {
                    select: !0
                })) : o === t && e.preventDefault()
            }
        }
        return Ya(e => {
            if (!xc)
                return;
            const t = r.value;
            if (!n.trapped)
                return;
            function o(e) {
                if (l.paused || !t)
                    return;
                const n = e.target;
                t.contains(n) ? s.value = n : vd(s.value, {
                    select: !0
                })
            }
            function a(e) {
                if (l.paused || !t)
                    return;
                const n = e.relatedTarget;
                null !== n && (t.contains(n) || vd(s.value, {
                    select: !0
                }))
            }
            document.addEventListener("focusin", o),
            document.addEventListener("focusout", a);
            const i = new MutationObserver(function(e) {
                t.contains(s.value) || vd(t)
            }
            );
            t && i.observe(t, {
                childList: !0,
                subtree: !0
            }),
            e( () => {
                document.removeEventListener("focusin", o),
                document.removeEventListener("focusout", a),
                i.disconnect()
            }
            )
        }
        ),
        Ya(async e => {
            const t = r.value;
            if (await fn(),
            !t)
                return;
            i.add(l);
            const n = ad();
            if (!t.contains(n)) {
                const e = new CustomEvent(ud,dd);
                t.addEventListener(ud, e => o("mountAutoFocus", e)),
                t.dispatchEvent(e),
                e.defaultPrevented || (!function(e, {select: t=!1}={}) {
                    const n = ad();
                    for (const o of e)
                        if (vd(o, {
                            select: t
                        }),
                        ad() !== n)
                            return !0
                }((a = pd(t),
                a.filter(e => "A" !== e.tagName)), {
                    select: !0
                }),
                ad() === n && vd(t))
            }
            var a;
            e( () => {
                t.removeEventListener(ud, e => o("mountAutoFocus", e));
                const e = new CustomEvent(cd,dd)
                  , a = e => {
                    o("unmountAutoFocus", e)
                }
                ;
                t.addEventListener(cd, a),
                t.dispatchEvent(e),
                setTimeout( () => {
                    e.defaultPrevented || vd(n ?? document.body, {
                        select: !0
                    }),
                    t.removeEventListener(cd, a),
                    i.remove(l)
                }
                , 0)
            }
            )
        }
        ),
        (e, t) => (Tr(),
        Ir(Nt(yc), {
            ref_key: "currentRef",
            ref: a,
            tabindex: "-1",
            "as-child": e.asChild,
            as: e.as,
            onKeydown: u
        }, {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 8, ["as-child", "as"]))
    }
});
function gd(e, t, n) {
    const o = n.originalEvent.target
      , a = new CustomEvent(e,{
        bubbles: !1,
        cancelable: !0,
        detail: n
    });
    t && o.addEventListener(e, t, {
        once: !0
    }),
    o.dispatchEvent(a)
}
function yd(e, t) {
    const n = t.closest("[data-dismissable-layer]")
      , o = "" === e.dataset.dismissableLayer ? e : e.querySelector("[data-dismissable-layer]")
      , a = Array.from(e.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
    return !(!n || !(o === n || a.indexOf(o) < a.indexOf(n)))
}
const bd = bt({
    layersRoot: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
})
  , wd = to({
    __name: "DismissableLayer",
    props: {
        disableOutsidePointerEvents: {
            type: Boolean,
            default: !1
        },
        asChild: {
            type: Boolean
        },
        as: {}
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , {forwardRef: a, currentElement: r} = Uc()
          , s = ms( () => {
            var e;
            return (null == (e = r.value) ? void 0 : e.ownerDocument) ?? globalThis.document
        }
        )
          , i = ms( () => bd.layersRoot)
          , l = ms( () => r.value ? Array.from(i.value).indexOf(r.value) : -1)
          , u = ms( () => bd.layersWithOutsidePointerEventsDisabled.size > 0)
          , c = ms( () => {
            const e = Array.from(i.value)
              , [t] = [...bd.layersWithOutsidePointerEventsDisabled].slice(-1)
              , n = e.indexOf(t);
            return l.value >= n
        }
        )
          , d = function(e, t, n=!0) {
            var o;
            const a = (null == (o = null == t ? void 0 : t.value) ? void 0 : o.ownerDocument) ?? (null == globalThis ? void 0 : globalThis.document)
              , r = It(!1)
              , s = It( () => {}
            );
            return Ya(o => {
                if (!xc || !Dt(n))
                    return;
                const i = async n => {
                    const o = n.target;
                    if ((null == t ? void 0 : t.value) && o)
                        if (yd(t.value, o))
                            r.value = !1;
                        else {
                            if (n.target && !r.value) {
                                let t = function() {
                                    gd("dismissableLayer.pointerDownOutside", e, o)
                                };
                                const o = {
                                    originalEvent: n
                                };
                                "touch" === n.pointerType ? (a.removeEventListener("click", s.value),
                                s.value = t,
                                a.addEventListener("click", s.value, {
                                    once: !0
                                })) : t()
                            } else
                                a.removeEventListener("click", s.value);
                            r.value = !1
                        }
                }
                  , l = window.setTimeout( () => {
                    a.addEventListener("pointerdown", i)
                }
                , 0);
                o( () => {
                    window.clearTimeout(l),
                    a.removeEventListener("pointerdown", i),
                    a.removeEventListener("click", s.value)
                }
                )
            }
            ),
            {
                onPointerDownCapture: () => {
                    Dt(n) && (r.value = !0)
                }
            }
        }(async e => {
            const t = [...bd.branches].some(t => null == t ? void 0 : t.contains(e.target));
            c.value && !t && (o("pointerDownOutside", e),
            o("interactOutside", e),
            await fn(),
            e.defaultPrevented || o("dismiss"))
        }
        , r)
          , p = function(e, t, n=!0) {
            var o;
            const a = (null == (o = null == t ? void 0 : t.value) ? void 0 : o.ownerDocument) ?? (null == globalThis ? void 0 : globalThis.document)
              , r = It(!1);
            return Ya(o => {
                if (!xc || !Dt(n))
                    return;
                const s = async n => {
                    if (!(null == t ? void 0 : t.value))
                        return;
                    await fn(),
                    await fn();
                    const o = n.target;
                    t.value && o && !yd(t.value, o) && n.target && !r.value && gd("dismissableLayer.focusOutside", e, {
                        originalEvent: n
                    })
                }
                ;
                a.addEventListener("focusin", s),
                o( () => a.removeEventListener("focusin", s))
            }
            ),
            {
                onFocusCapture: () => {
                    Dt(n) && (r.value = !0)
                }
                ,
                onBlurCapture: () => {
                    Dt(n) && (r.value = !1)
                }
            }
        }(e => {
            [...bd.branches].some(t => null == t ? void 0 : t.contains(e.target)) || (o("focusOutside", e),
            o("interactOutside", e),
            e.defaultPrevented || o("dismiss"))
        }
        , r);
        let f;
        return Lc("Escape", e => {
            l.value === i.value.size - 1 && (o("escapeKeyDown", e),
            e.defaultPrevented || o("dismiss"))
        }
        ),
        Ya(e => {
            r.value && (n.disableOutsidePointerEvents && (0 === bd.layersWithOutsidePointerEventsDisabled.size && (f = s.value.body.style.pointerEvents,
            s.value.body.style.pointerEvents = "none"),
            bd.layersWithOutsidePointerEventsDisabled.add(r.value)),
            i.value.add(r.value),
            e( () => {
                n.disableOutsidePointerEvents && 1 === bd.layersWithOutsidePointerEventsDisabled.size && (s.value.body.style.pointerEvents = f)
            }
            ))
        }
        ),
        Ya(e => {
            e( () => {
                r.value && (i.value.delete(r.value),
                bd.layersWithOutsidePointerEventsDisabled.delete(r.value))
            }
            )
        }
        ),
        (e, t) => (Tr(),
        Ir(Nt(yc), {
            ref: Nt(a),
            "as-child": e.asChild,
            as: e.as,
            "data-dismissable-layer": "",
            style: U({
                pointerEvents: u.value ? c.value ? "auto" : "none" : void 0
            }),
            onFocusCapture: Nt(p).onFocusCapture,
            onBlurCapture: Nt(p).onBlurCapture,
            onPointerdownCapture: Nt(d).onPointerDownCapture
        }, {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]))
    }
})
  , _d = to({
    __name: "DialogContentImpl",
    props: {
        forceMount: {
            type: Boolean
        },
        trapFocus: {
            type: Boolean
        },
        disableOutsidePointerEvents: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {}
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = Qc()
          , {forwardRef: r, currentElement: s} = Uc();
        return a.titleId || (a.titleId = Kc(0, "reka-dialog-title")),
        a.descriptionId || (a.descriptionId = Kc(0, "reka-dialog-description")),
        Mo( () => {
            a.contentElement = s,
            ad() !== document.body && (a.triggerElement.value = ad())
        }
        ),
        (e, t) => (Tr(),
        Ir(Nt(md), {
            "as-child": "",
            loop: "",
            trapped: n.trapFocus,
            onMountAutoFocus: t[5] || (t[5] = e => o("openAutoFocus", e)),
            onUnmountAutoFocus: t[6] || (t[6] = e => o("closeAutoFocus", e))
        }, {
            default: En( () => [jr(Nt(wd), Gr({
                id: Nt(a).contentId,
                ref: Nt(r),
                as: e.as,
                "as-child": e.asChild,
                "disable-outside-pointer-events": e.disableOutsidePointerEvents,
                role: "dialog",
                "aria-describedby": Nt(a).descriptionId,
                "aria-labelledby": Nt(a).titleId,
                "data-state": Nt(rd)(Nt(a).open.value)
            }, e.$attrs, {
                onDismiss: t[0] || (t[0] = e => Nt(a).onOpenChange(!1)),
                onEscapeKeyDown: t[1] || (t[1] = e => o("escapeKeyDown", e)),
                onFocusOutside: t[2] || (t[2] = e => o("focusOutside", e)),
                onInteractOutside: t[3] || (t[3] = e => o("interactOutside", e)),
                onPointerDownOutside: t[4] || (t[4] = e => o("pointerDownOutside", e))
            }), {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            }, 16, ["id", "as", "as-child", "disable-outside-pointer-events", "aria-describedby", "aria-labelledby", "data-state"])]),
            _: 3
        }, 8, ["trapped"]))
    }
});
var xd = new WeakMap
  , kd = new WeakMap
  , Sd = {}
  , Cd = 0
  , Ed = function(e) {
    return e && (e.host || Ed(e.parentNode))
}
  , Td = function(e, t, n, o) {
    var a = function(e, t) {
        return t.map(function(t) {
            if (e.contains(t))
                return t;
            var n = Ed(t);
            return n && e.contains(n) ? n : null
        }).filter(function(e) {
            return Boolean(e)
        })
    }(t, Array.isArray(e) ? e : [e]);
    Sd[n] || (Sd[n] = new WeakMap);
    var r = Sd[n]
      , s = []
      , i = new Set
      , l = new Set(a)
      , u = function(e) {
        e && !i.has(e) && (i.add(e),
        u(e.parentNode))
    };
    a.forEach(u);
    var c = function(e) {
        e && !l.has(e) && Array.prototype.forEach.call(e.children, function(e) {
            if (i.has(e))
                c(e);
            else
                try {
                    var t = e.getAttribute(o)
                      , a = null !== t && "false" !== t
                      , l = (xd.get(e) || 0) + 1
                      , u = (r.get(e) || 0) + 1;
                    xd.set(e, l),
                    r.set(e, u),
                    s.push(e),
                    1 === l && a && kd.set(e, !0),
                    1 === u && e.setAttribute(n, "true"),
                    a || e.setAttribute(o, "true")
                } catch (pC) {}
        })
    };
    return c(t),
    i.clear(),
    Cd++,
    function() {
        s.forEach(function(e) {
            var t = xd.get(e) - 1
              , a = r.get(e) - 1;
            xd.set(e, t),
            r.set(e, a),
            t || (kd.has(e) || e.removeAttribute(o),
            kd.delete(e)),
            a || e.removeAttribute(n)
        }),
        --Cd || (xd = new WeakMap,
        xd = new WeakMap,
        kd = new WeakMap,
        Sd = {})
    }
}
  , Ad = function(e, t, n) {
    void 0 === n && (n = "data-aria-hidden");
    var o = Array.from(Array.isArray(e) ? e : [e])
      , a = function(e) {
        return "undefined" == typeof document ? null : (Array.isArray(e) ? e[0] : e).ownerDocument.body
    }(e);
    return a ? (o.push.apply(o, Array.from(a.querySelectorAll("[aria-live], script"))),
    Td(o, a, n, "aria-hidden")) : function() {
        return null
    }
};
function Od(e) {
    let t;
    Qa( () => Pc(e), e => {
        e ? t = Ad(e) : t && t()
    }
    ),
    Lo( () => {
        t && t()
    }
    )
}
const Md = to({
    __name: "DialogContentModal",
    props: {
        forceMount: {
            type: Boolean
        },
        trapFocus: {
            type: Boolean
        },
        disableOutsidePointerEvents: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {}
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = Qc()
          , r = od(o)
          , {forwardRef: s, currentElement: i} = Uc();
        return Od(i),
        (e, t) => (Tr(),
        Ir(_d, Gr({
            ...n,
            ...Nt(r)
        }, {
            ref: Nt(s),
            "trap-focus": Nt(a).open.value,
            "disable-outside-pointer-events": !0,
            onCloseAutoFocus: t[0] || (t[0] = e => {
                var t;
                e.defaultPrevented || (e.preventDefault(),
                null == (t = Nt(a).triggerElement.value) || t.focus())
            }
            ),
            onPointerDownOutside: t[1] || (t[1] = e => {
                const t = e.detail.originalEvent
                  , n = 0 === t.button && !0 === t.ctrlKey;
                (2 === t.button || n) && e.preventDefault()
            }
            ),
            onFocusOutside: t[2] || (t[2] = e => {
                e.preventDefault()
            }
            )
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["trap-focus"]))
    }
})
  , Pd = to({
    __name: "DialogContentNonModal",
    props: {
        forceMount: {
            type: Boolean
        },
        trapFocus: {
            type: Boolean
        },
        disableOutsidePointerEvents: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {}
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
    setup(e, {emit: t}) {
        const n = e
          , o = od(t);
        Uc();
        const a = Qc()
          , r = It(!1)
          , s = It(!1);
        return (e, t) => (Tr(),
        Ir(_d, Gr({
            ...n,
            ...Nt(o)
        }, {
            "trap-focus": !1,
            "disable-outside-pointer-events": !1,
            onCloseAutoFocus: t[0] || (t[0] = e => {
                var t;
                e.defaultPrevented || (r.value || null == (t = Nt(a).triggerElement.value) || t.focus(),
                e.preventDefault()),
                r.value = !1,
                s.value = !1
            }
            ),
            onInteractOutside: t[1] || (t[1] = e => {
                var t;
                e.defaultPrevented || (r.value = !0,
                "pointerdown" === e.detail.originalEvent.type && (s.value = !0));
                const n = e.target;
                (null == (t = Nt(a).triggerElement.value) ? void 0 : t.contains(n)) && e.preventDefault(),
                "focusin" === e.detail.originalEvent.type && s.value && e.preventDefault()
            }
            )
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , Bd = to({
    __name: "DialogContent",
    props: {
        forceMount: {
            type: Boolean
        },
        disableOutsidePointerEvents: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {}
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = Qc()
          , r = od(o)
          , {forwardRef: s} = Uc();
        return (e, t) => (Tr(),
        Ir(Nt(Jc), {
            present: e.forceMount || Nt(a).open.value
        }, {
            default: En( () => [Nt(a).modal.value ? (Tr(),
            Ir(Md, Gr({
                key: 0,
                ref: Nt(s)
            }, {
                ...n,
                ...Nt(r),
                ...e.$attrs
            }), {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            }, 16)) : (Tr(),
            Ir(Pd, Gr({
                key: 1,
                ref: Nt(s)
            }, {
                ...n,
                ...Nt(r),
                ...e.$attrs
            }), {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            }, 16))]),
            _: 3
        }, 8, ["present"]))
    }
})
  , Id = to({
    __name: "DialogDescription",
    props: {
        asChild: {
            type: Boolean
        },
        as: {
            default: "p"
        }
    },
    setup(e) {
        const t = e;
        Uc();
        const n = Qc();
        return (e, o) => (Tr(),
        Ir(Nt(yc), Gr(t, {
            id: Nt(n).descriptionId
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["id"]))
    }
});
function Ld(e) {
    if (null === e || "object" != typeof e)
        return !1;
    const t = Object.getPrototypeOf(e);
    return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && (!(Symbol.iterator in e) && (!(Symbol.toStringTag in e) || "[object Module]" === Object.prototype.toString.call(e)))
}
function Rd(e, t, n=".", o) {
    if (!Ld(t))
        return Rd(e, {}, n, o);
    const a = Object.assign({}, t);
    for (const r in e) {
        if ("__proto__" === r || "constructor" === r)
            continue;
        const t = e[r];
        null != t && (o && o(a, r, t, n) || (Array.isArray(t) && Array.isArray(a[r]) ? a[r] = [...t, ...a[r]] : Ld(t) && Ld(a[r]) ? a[r] = Rd(t, a[r], (n ? `${n}.` : "") + r.toString(), o) : a[r] = t))
    }
    return a
}
const zd = (...e) => e.reduce( (e, t) => Rd(e, t, "", Nd), {});
var Nd;
const Dd = function(e) {
    let t, n, o = 0;
    const a = () => {
        o -= 1,
        n && o <= 0 && (n.stop(),
        t = void 0,
        n = void 0)
    }
    ;
    return (...r) => (o += 1,
    n || (n = le(!0),
    t = n.run( () => e(...r))),
    wc(a),
    t)
}( () => {
    const e = It(new Map)
      , t = It()
      , n = ms( () => {
        for (const t of e.value.values())
            if (t)
                return !0;
        return !1
    }
    )
      , o = $c({
        scrollBody: It(!0)
    });
    let a = null;
    return Qa(n, (e, n) => {
        var r;
        if (!xc)
            return;
        if (!e)
            return void (n && (document.body.style.paddingRight = "",
            document.body.style.marginRight = "",
            document.body.style.pointerEvents = "",
            document.documentElement.style.removeProperty("--scrollbar-width"),
            document.body.style.overflow = t.value ?? "",
            Sc && (null == a || a()),
            t.value = void 0));
        void 0 === t.value && (t.value = document.body.style.overflow);
        const s = window.innerWidth - document.documentElement.clientWidth
          , i = {
            padding: s,
            margin: 0
        }
          , l = (null == (r = o.scrollBody) ? void 0 : r.value) ? "object" == typeof o.scrollBody.value ? zd({
            padding: !0 === o.scrollBody.value.padding ? s : o.scrollBody.value.padding,
            margin: !0 === o.scrollBody.value.margin ? s : o.scrollBody.value.margin
        }, i) : i : {
            padding: 0,
            margin: 0
        };
        s > 0 && (document.body.style.paddingRight = "number" == typeof l.padding ? `${l.padding}px` : String(l.padding),
        document.body.style.marginRight = "number" == typeof l.margin ? `${l.margin}px` : String(l.margin),
        document.documentElement.style.setProperty("--scrollbar-width", `${s}px`),
        document.body.style.overflow = "hidden"),
        Sc && (a = Bc(document, "touchmove", e => function(e) {
            const t = e || window.event
              , n = t.target;
            if (n instanceof Element && Fd(n))
                return !1;
            if (t.touches.length > 1)
                return !0;
            t.preventDefault && t.cancelable && t.preventDefault();
            return !1
        }(e), {
            passive: !1
        })),
        fn( () => {
            document.body.style.pointerEvents = "none",
            document.body.style.overflow = "hidden"
        }
        )
    }
    , {
        immediate: !0,
        flush: "sync"
    }),
    e
}
);
function jd(e) {
    const t = Math.random().toString(36).substring(2, 7)
      , n = Dd();
    n.value.set(t, e ?? !1);
    const o = ms({
        get: () => n.value.get(t) ?? !1,
        set: e => n.value.set(t, e)
    });
    return Oc( () => {
        n.value.delete(t)
    }
    ),
    o
}
function Fd(e) {
    const t = window.getComputedStyle(e);
    if ("scroll" === t.overflowX || "scroll" === t.overflowY || "auto" === t.overflowX && e.clientWidth < e.scrollWidth || "auto" === t.overflowY && e.clientHeight < e.scrollHeight)
        return !0;
    {
        const t = e.parentNode;
        return t instanceof Element && "BODY" !== t.tagName && Fd(t)
    }
}
const $d = to({
    __name: "DialogOverlayImpl",
    props: {
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = Qc();
        return jd(!0),
        Uc(),
        (e, n) => (Tr(),
        Ir(Nt(yc), {
            as: e.as,
            "as-child": e.asChild,
            "data-state": Nt(t).open.value ? "open" : "closed",
            style: {
                "pointer-events": "auto"
            }
        }, {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 8, ["as", "as-child", "data-state"]))
    }
})
  , Vd = to({
    __name: "DialogOverlay",
    props: {
        forceMount: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = Qc()
          , {forwardRef: n} = Uc();
        return (e, o) => {
            var a;
            return (null == (a = Nt(t)) ? void 0 : a.modal.value) ? (Tr(),
            Ir(Nt(Jc), {
                key: 0,
                present: e.forceMount || Nt(t).open.value
            }, {
                default: En( () => [jr($d, Gr(e.$attrs, {
                    ref: Nt(n),
                    as: e.as,
                    "as-child": e.asChild
                }), {
                    default: En( () => [Wo(e.$slots, "default")]),
                    _: 3
                }, 16, ["as", "as-child"])]),
                _: 3
            }, 8, ["present"])) : Ur("", !0)
        }
    }
})
  , Hd = to({
    __name: "Teleport",
    props: {
        to: {
            default: "body"
        },
        disabled: {
            type: Boolean
        },
        defer: {
            type: Boolean
        },
        forceMount: {
            type: Boolean
        }
    },
    setup(e) {
        const t = Ic();
        return (e, n) => Nt(t) || e.forceMount ? (Tr(),
        Ir(Dn, {
            key: 0,
            to: e.to,
            disabled: e.disabled,
            defer: e.defer
        }, [Wo(e.$slots, "default")], 8, ["to", "disabled", "defer"])) : Ur("", !0)
    }
});
function Ud(e) {
    const t = es()
      , n = Object.keys((null == t ? void 0 : t.type.props) ?? {}).reduce( (e, n) => {
        const o = (null == t ? void 0 : t.type.props[n]).default;
        return void 0 !== o && (e[n] = o),
        e
    }
    , {})
      , o = qt(e);
    return ms( () => {
        const e = {}
          , a = (null == t ? void 0 : t.vnode.props) ?? {};
        return Object.keys(a).forEach(t => {
            e[P(t)] = a[t]
        }
        ),
        Object.keys({
            ...n,
            ...e
        }).reduce( (e, t) => (void 0 !== o.value[t] && (e[t] = o.value[t]),
        e), {})
    }
    )
}
function Zd(e, t) {
    const n = Ud(e)
      , o = t ? od(t) : {};
    return ms( () => ({
        ...n.value,
        ...o
    }))
}
const qd = to({
    __name: "DialogTitle",
    props: {
        asChild: {
            type: Boolean
        },
        as: {
            default: "h2"
        }
    },
    setup(e) {
        const t = e
          , n = Qc();
        return Uc(),
        (e, o) => (Tr(),
        Ir(Nt(yc), Gr(t, {
            id: Nt(n).titleId
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["id"]))
    }
})
  , Wd = to({
    __name: "DialogTrigger",
    props: {
        asChild: {
            type: Boolean
        },
        as: {
            default: "button"
        }
    },
    setup(e) {
        const t = e
          , n = Qc()
          , {forwardRef: o, currentElement: a} = Uc();
        return n.contentId || (n.contentId = Kc(0, "reka-dialog-content")),
        Mo( () => {
            n.triggerElement.value = a.value
        }
        ),
        (e, a) => (Tr(),
        Ir(Nt(yc), Gr(t, {
            ref: Nt(o),
            type: "button" === e.as ? "button" : void 0,
            "aria-haspopup": "dialog",
            "aria-expanded": Nt(n).open.value || !1,
            "aria-controls": Nt(n).open.value ? Nt(n).contentId : void 0,
            "data-state": Nt(n).open.value ? "open" : "closed",
            onClick: Nt(n).onOpenToggle
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "onClick"]))
    }
})
  , [Gd,Kd] = Nc("AvatarRoot")
  , Yd = to({
    __name: "AvatarRoot",
    props: {
        asChild: {
            type: Boolean
        },
        as: {
            default: "span"
        }
    },
    setup: e => (Uc(),
    Kd({
        imageLoadingStatus: It("idle")
    }),
    (e, t) => (Tr(),
    Ir(Nt(yc), {
        "as-child": e.asChild,
        as: e.as
    }, {
        default: En( () => [Wo(e.$slots, "default")]),
        _: 3
    }, 8, ["as-child", "as"])))
})
  , Xd = to({
    __name: "AvatarFallback",
    props: {
        delayMs: {},
        asChild: {
            type: Boolean
        },
        as: {
            default: "span"
        }
    },
    setup(e) {
        const t = e
          , n = Gd();
        Uc();
        const o = It(void 0 === t.delayMs);
        return Ya(e => {
            if (t.delayMs && xc) {
                const n = window.setTimeout( () => {
                    o.value = !0
                }
                , t.delayMs);
                e( () => {
                    window.clearTimeout(n)
                }
                )
            }
        }
        ),
        (e, t) => o.value && "loaded" !== Nt(n).imageLoadingStatus.value ? (Tr(),
        Ir(Nt(yc), {
            key: 0,
            "as-child": e.asChild,
            as: e.as
        }, {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 8, ["as-child", "as"])) : Ur("", !0)
    }
});
function Jd(e, t) {
    return e ? t ? (e.src !== t && (e.src = t),
    e.complete && e.naturalWidth > 0 ? "loaded" : "loading") : "error" : "idle"
}
const Qd = to({
    __name: "AvatarImage",
    props: {
        src: {},
        referrerPolicy: {},
        crossOrigin: {},
        asChild: {
            type: Boolean
        },
        as: {
            default: "img"
        }
    },
    emits: ["loadingStatusChange"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , {src: a, referrerPolicy: r, crossOrigin: s} = Ht(n);
        Uc();
        const i = Gd()
          , l = function(e, {referrerPolicy: t, crossOrigin: n}={}) {
            const o = It(!1)
              , a = It(null)
              , r = ms( () => o.value ? (!a.value && xc && (a.value = new window.Image),
            a.value) : null)
              , s = It(Jd(r.value, e.value))
              , i = e => () => {
                o.value && (s.value = e)
            }
            ;
            return Mo( () => {
                o.value = !0,
                Ya(o => {
                    const a = r.value;
                    if (!a)
                        return;
                    s.value = Jd(a, e.value);
                    const l = i("loaded")
                      , u = i("error");
                    a.addEventListener("load", l),
                    a.addEventListener("error", u),
                    (null == t ? void 0 : t.value) && (a.referrerPolicy = t.value),
                    "string" == typeof (null == n ? void 0 : n.value) && (a.crossOrigin = n.value),
                    o( () => {
                        a.removeEventListener("load", l),
                        a.removeEventListener("error", u)
                    }
                    )
                }
                )
            }
            ),
            Lo( () => {
                o.value = !1
            }
            ),
            s
        }(a, {
            referrerPolicy: r,
            crossOrigin: s
        });
        return Qa(l, e => {
            o("loadingStatusChange", e),
            "idle" !== e && (i.imageLoadingStatus.value = e)
        }
        , {
            immediate: !0
        }),
        (e, t) => Tn((Tr(),
        Ir(Nt(yc), {
            role: "img",
            "as-child": e.asChild,
            as: e.as,
            src: Nt(a),
            "referrer-policy": Nt(r)
        }, {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 8, ["as-child", "as", "src", "referrer-policy"])), [[Js, "loaded" === Nt(l)]])
    }
});
function ep() {
    const e = It()
      , t = ms( () => {
        var t, n;
        return ["#text", "#comment"].includes(null == (t = e.value) ? void 0 : t.$el.nodeName) ? null == (n = e.value) ? void 0 : n.$el.nextElementSibling : Pc(e)
    }
    );
    return {
        primitiveElement: e,
        currentElement: t
    }
}
const tp = "data-reka-collection-item";
function np(e={}) {
    const {key: t="", isProvider: n=!1} = e
      , o = `${t}CollectionProvider`;
    let a;
    if (n) {
        const e = It(new Map)
          , t = It();
        a = {
            collectionRef: t,
            itemMap: e
        },
        _a(o, a)
    } else
        a = xa(o);
    const r = to({
        name: "CollectionSlot",
        setup(e, {slots: t}) {
            const {primitiveElement: n, currentElement: o} = ep();
            return Qa(o, () => {
                a.collectionRef.value = o.value
            }
            ),
            () => gs(mc, {
                ref: n
            }, t)
        }
    })
      , s = to({
        name: "CollectionItem",
        inheritAttrs: !1,
        props: {
            value: {
                validator: () => !0
            }
        },
        setup(e, {slots: t, attrs: n}) {
            const {primitiveElement: o, currentElement: r} = ep();
            return Ya(t => {
                if (r.value) {
                    const n = Ot(r.value);
                    a.itemMap.value.set(n, {
                        ref: r.value,
                        value: e.value
                    }),
                    t( () => a.itemMap.value.delete(n))
                }
            }
            ),
            () => gs(mc, {
                ...n,
                [tp]: "",
                ref: o
            }, t)
        }
    });
    return {
        getItems: (e=!1) => {
            const t = a.collectionRef.value;
            if (!t)
                return [];
            const n = Array.from(t.querySelectorAll(`[${tp}]`))
              , o = Array.from(a.itemMap.value.values()).sort( (e, t) => n.indexOf(e.ref) - n.indexOf(t.ref));
            return e ? o : o.filter(e => "" !== e.ref.dataset.disabled)
        }
        ,
        reactiveItems: ms( () => Array.from(a.itemMap.value.values())),
        itemMapSize: ms( () => a.itemMap.value.size),
        CollectionSlot: r,
        CollectionItem: s
    }
}
const [op,ap] = Nc("PopperRoot")
  , rp = to({
    inheritAttrs: !1,
    __name: "PopperRoot",
    setup(e) {
        const t = It();
        return ap({
            anchor: t,
            onAnchorChange: e => t.value = e
        }),
        (e, t) => Wo(e.$slots, "default")
    }
})
  , sp = to({
    __name: "PopperAnchor",
    props: {
        reference: {},
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = e
          , {forwardRef: n, currentElement: o} = Uc()
          , a = op();
        return Xa( () => {
            a.onAnchorChange(t.reference ?? o.value)
        }
        ),
        (e, t) => (Tr(),
        Ir(Nt(yc), {
            ref: Nt(n),
            as: e.as,
            "as-child": e.asChild
        }, {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 8, ["as", "as-child"]))
    }
});
function ip(e) {
    return null !== e
}
function lp(e) {
    return {
        name: "transformOrigin",
        options: e,
        fn(t) {
            var n, o, a;
            const {placement: r, rects: s, middlewareData: i} = t
              , l = 0 !== (null == (n = i.arrow) ? void 0 : n.centerOffset)
              , u = l ? 0 : e.arrowWidth
              , c = l ? 0 : e.arrowHeight
              , [d,p] = up(r)
              , f = {
                start: "0%",
                center: "50%",
                end: "100%"
            }[p]
              , h = ((null == (o = i.arrow) ? void 0 : o.x) ?? 0) + u / 2
              , v = ((null == (a = i.arrow) ? void 0 : a.y) ?? 0) + c / 2;
            let m = ""
              , g = "";
            return "bottom" === d ? (m = l ? f : `${h}px`,
            g = -c + "px") : "top" === d ? (m = l ? f : `${h}px`,
            g = `${s.floating.height + c}px`) : "right" === d ? (m = -c + "px",
            g = l ? f : `${v}px`) : "left" === d && (m = `${s.floating.width + c}px`,
            g = l ? f : `${v}px`),
            {
                data: {
                    x: m,
                    y: g
                }
            }
        }
    }
}
function up(e) {
    const [t,n="center"] = e.split("-");
    return [t, n]
}
const [cp,dp] = Nc("PopperContent")
  , pp = to({
    inheritAttrs: !1,
    __name: "PopperContent",
    props: aa({
        side: {},
        sideOffset: {},
        align: {},
        alignOffset: {},
        avoidCollisions: {
            type: Boolean
        },
        collisionBoundary: {},
        collisionPadding: {},
        arrowPadding: {},
        sticky: {},
        hideWhenDetached: {
            type: Boolean
        },
        positionStrategy: {},
        updatePositionStrategy: {},
        disableUpdateOnLayoutShift: {
            type: Boolean
        },
        prioritizePosition: {
            type: Boolean
        },
        reference: {},
        asChild: {
            type: Boolean
        },
        as: {}
    }, {
        side: "bottom",
        sideOffset: 0,
        align: "center",
        alignOffset: 0,
        arrowPadding: 0,
        avoidCollisions: !0,
        collisionBoundary: () => [],
        collisionPadding: 0,
        sticky: "partial",
        hideWhenDetached: !1,
        positionStrategy: "fixed",
        updatePositionStrategy: "optimized",
        prioritizePosition: !1
    }),
    emits: ["placed"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = op()
          , {forwardRef: r, currentElement: s} = Uc()
          , i = It()
          , l = It()
          , {width: u, height: c} = function(e) {
            const t = It()
              , n = ms( () => {
                var e;
                return (null == (e = t.value) ? void 0 : e.width) ?? 0
            }
            )
              , o = ms( () => {
                var e;
                return (null == (e = t.value) ? void 0 : e.height) ?? 0
            }
            );
            return Mo( () => {
                const n = Pc(e);
                if (n) {
                    t.value = {
                        width: n.offsetWidth,
                        height: n.offsetHeight
                    };
                    const e = new ResizeObserver(e => {
                        if (!Array.isArray(e))
                            return;
                        if (!e.length)
                            return;
                        const o = e[0];
                        let a, r;
                        if ("borderBoxSize"in o) {
                            const e = o.borderBoxSize
                              , t = Array.isArray(e) ? e[0] : e;
                            a = t.inlineSize,
                            r = t.blockSize
                        } else
                            a = n.offsetWidth,
                            r = n.offsetHeight;
                        t.value = {
                            width: a,
                            height: r
                        }
                    }
                    );
                    return e.observe(n, {
                        box: "border-box"
                    }),
                    () => e.unobserve(n)
                }
                t.value = void 0
            }
            ),
            {
                width: n,
                height: o
            }
        }(l)
          , d = ms( () => n.side + ("center" !== n.align ? `-${n.align}` : ""))
          , p = ms( () => "number" == typeof n.collisionPadding ? n.collisionPadding : {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            ...n.collisionPadding
        })
          , f = ms( () => Array.isArray(n.collisionBoundary) ? n.collisionBoundary : [n.collisionBoundary])
          , h = ms( () => ({
            padding: p.value,
            boundary: f.value.filter(ip),
            altBoundary: f.value.length > 0
        }))
          , v = function(e, t) {
            const n = Lt();
            return Ya( () => {
                n.value = e()
            }
            , {
                ...t,
                flush: "sync"
            }),
            _t(n)
        }( () => {
            return [oc({
                mainAxis: n.sideOffset + c.value,
                alignmentAxis: n.alignOffset
            }), n.prioritizePosition && n.avoidCollisions && rc({
                ...h.value
            }), n.avoidCollisions && ac({
                mainAxis: !0,
                crossAxis: !!n.prioritizePosition,
                limiter: "partial" === n.sticky ? uc() : void 0,
                ...h.value
            }), !n.prioritizePosition && n.avoidCollisions && rc({
                ...h.value
            }), sc({
                ...h.value,
                apply: ({elements: e, rects: t, availableWidth: n, availableHeight: o}) => {
                    const {width: a, height: r} = t.reference
                      , s = e.floating.style;
                    s.setProperty("--reka-popper-available-width", `${n}px`),
                    s.setProperty("--reka-popper-available-height", `${o}px`),
                    s.setProperty("--reka-popper-anchor-width", `${a}px`),
                    s.setProperty("--reka-popper-anchor-height", `${r}px`)
                }
            }), l.value && (e = {
                element: l.value,
                padding: n.arrowPadding
            },
            {
                name: "arrow",
                options: e,
                fn(t) {
                    const n = dc(pc(e.element));
                    return null == n ? {} : lc({
                        element: n,
                        padding: e.padding
                    }).fn(t)
                }
            }), lp({
                arrowWidth: u.value,
                arrowHeight: c.value
            }), n.hideWhenDetached && ic({
                strategy: "referenceHidden",
                ...h.value
            })];
            var e
        }
        )
          , m = ms( () => n.reference ?? a.anchor.value)
          , {floatingStyles: g, placement: y, isPositioned: b, middlewareData: w} = function(e, t, n) {
            void 0 === n && (n = {});
            const o = n.whileElementsMounted
              , a = ms( () => {
                var e;
                return null == (e = pc(n.open)) || e
            }
            )
              , r = ms( () => pc(n.middleware))
              , s = ms( () => {
                var e;
                return null != (e = pc(n.placement)) ? e : "bottom"
            }
            )
              , i = ms( () => {
                var e;
                return null != (e = pc(n.strategy)) ? e : "absolute"
            }
            )
              , l = ms( () => {
                var e;
                return null == (e = pc(n.transform)) || e
            }
            )
              , u = ms( () => dc(e.value))
              , c = ms( () => dc(t.value))
              , d = It(0)
              , p = It(0)
              , f = It(i.value)
              , h = It(s.value)
              , v = Lt({})
              , m = It(!1)
              , g = ms( () => {
                const e = {
                    position: f.value,
                    left: "0",
                    top: "0"
                };
                if (!c.value)
                    return e;
                const t = hc(c.value, d.value)
                  , n = hc(c.value, p.value);
                return l.value ? {
                    ...e,
                    transform: "translate(" + t + "px, " + n + "px)",
                    ...fc(c.value) >= 1.5 && {
                        willChange: "transform"
                    }
                } : {
                    position: f.value,
                    left: t + "px",
                    top: n + "px"
                }
            }
            );
            let y;
            function b() {
                if (null == u.value || null == c.value)
                    return;
                const e = a.value;
                cc(u.value, c.value, {
                    middleware: r.value,
                    placement: s.value,
                    strategy: i.value
                }).then(t => {
                    d.value = t.x,
                    p.value = t.y,
                    f.value = t.strategy,
                    h.value = t.placement,
                    v.value = t.middlewareData,
                    m.value = !1 !== e
                }
                )
            }
            function w() {
                "function" == typeof y && (y(),
                y = void 0)
            }
            return Qa([r, s, i, a], b, {
                flush: "sync"
            }),
            Qa([u, c], function() {
                w(),
                void 0 !== o ? null == u.value || null == c.value || (y = o(u.value, c.value, b)) : b()
            }, {
                flush: "sync"
            }),
            Qa(a, function() {
                a.value || (m.value = !1)
            }, {
                flush: "sync"
            }),
            ue() && ce(w),
            {
                x: xt(d),
                y: xt(p),
                strategy: xt(f),
                placement: xt(h),
                middlewareData: xt(v),
                isPositioned: xt(m),
                floatingStyles: g,
                update: b
            }
        }(m, i, {
            strategy: n.positionStrategy,
            placement: d,
            whileElementsMounted: (...e) => nc(...e, {
                layoutShift: !n.disableUpdateOnLayoutShift,
                animationFrame: "always" === n.updatePositionStrategy
            }),
            middleware: v
        })
          , _ = ms( () => up(y.value)[0])
          , x = ms( () => up(y.value)[1]);
        Xa( () => {
            b.value && o("placed")
        }
        );
        const k = ms( () => {
            var e;
            return 0 !== (null == (e = w.value.arrow) ? void 0 : e.centerOffset)
        }
        )
          , S = It("");
        Ya( () => {
            s.value && (S.value = window.getComputedStyle(s.value).zIndex)
        }
        );
        const C = ms( () => {
            var e;
            return (null == (e = w.value.arrow) ? void 0 : e.x) ?? 0
        }
        )
          , E = ms( () => {
            var e;
            return (null == (e = w.value.arrow) ? void 0 : e.y) ?? 0
        }
        );
        return dp({
            placedSide: _,
            onArrowChange: e => l.value = e,
            arrowX: C,
            arrowY: E,
            shouldHideArrow: k
        }),
        (e, t) => {
            var o, a, s;
            return Tr(),
            Br("div", {
                ref_key: "floatingRef",
                ref: i,
                "data-reka-popper-content-wrapper": "",
                style: U({
                    ...Nt(g),
                    transform: Nt(b) ? Nt(g).transform : "translate(0, -200%)",
                    minWidth: "max-content",
                    zIndex: S.value,
                    "--reka-popper-transform-origin": [null == (o = Nt(w).transformOrigin) ? void 0 : o.x, null == (a = Nt(w).transformOrigin) ? void 0 : a.y].join(" "),
                    ...(null == (s = Nt(w).hide) ? void 0 : s.referenceHidden) && {
                        visibility: "hidden",
                        pointerEvents: "none"
                    }
                })
            }, [jr(Nt(yc), Gr({
                ref: Nt(r)
            }, e.$attrs, {
                "as-child": n.asChild,
                as: e.as,
                "data-side": _.value,
                "data-align": x.value,
                style: {
                    animation: Nt(b) ? void 0 : "none"
                }
            }), {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            }, 16, ["as-child", "as", "data-side", "data-align", "style"])], 4)
        }
    }
});
function fp(e) {
    const t = Tc("", 1e3);
    return {
        search: t,
        handleTypeaheadSearch: (e, n) => {
            t.value = t.value + e;
            {
                const e = ad()
                  , o = n.map(e => {
                    var t, n;
                    return {
                        ...e,
                        textValue: (null == (t = e.value) ? void 0 : t.textValue) ?? (null == (n = e.ref.textContent) ? void 0 : n.trim()) ?? ""
                    }
                }
                )
                  , a = o.find(t => t.ref === e)
                  , r = function(e, t, n) {
                    const o = t.length > 1 && Array.from(t).every(e => e === t[0])
                      , a = o ? t[0] : t
                      , r = n ? e.indexOf(n) : -1;
                    let s = (i = e,
                    l = Math.max(r, 0),
                    i.map( (e, t) => i[(l + t) % i.length]));
                    var i, l;
                    1 === a.length && (s = s.filter(e => e !== n));
                    const u = s.find(e => e.toLowerCase().startsWith(a.toLowerCase()));
                    return u !== n ? u : void 0
                }(o.map(e => e.textValue), t.value, null == a ? void 0 : a.textValue)
                  , s = o.find(e => e.textValue === r);
                return s && s.ref.focus(),
                null == s ? void 0 : s.ref
            }
        }
        ,
        resetTypeahead: () => {
            t.value = ""
        }
    }
}
let hp = 0;
function vp() {
    Ya(e => {
        if (!xc)
            return;
        const t = document.querySelectorAll("[data-reka-focus-guard]");
        document.body.insertAdjacentElement("afterbegin", t[0] ?? mp()),
        document.body.insertAdjacentElement("beforeend", t[1] ?? mp()),
        hp++,
        e( () => {
            1 === hp && document.querySelectorAll("[data-reka-focus-guard]").forEach(e => e.remove()),
            hp--
        }
        )
    }
    )
}
function mp() {
    const e = document.createElement("span");
    return e.setAttribute("data-reka-focus-guard", ""),
    e.tabIndex = 0,
    e.style.outline = "none",
    e.style.opacity = "0",
    e.style.position = "fixed",
    e.style.pointerEvents = "none",
    e
}
const [gp,yp] = Nc("PopoverRoot")
  , bp = to({
    __name: "PopoverRoot",
    props: {
        defaultOpen: {
            type: Boolean,
            default: !1
        },
        open: {
            type: Boolean,
            default: void 0
        },
        modal: {
            type: Boolean,
            default: !1
        }
    },
    emits: ["update:open"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , {modal: a} = Ht(n)
          , r = zc(n, "open", o, {
            defaultValue: n.defaultOpen,
            passive: void 0 === n.open
        })
          , s = It()
          , i = It(!1);
        return yp({
            contentId: "",
            triggerId: "",
            modal: a,
            open: r,
            onOpenChange: e => {
                r.value = e
            }
            ,
            onOpenToggle: () => {
                r.value = !r.value
            }
            ,
            triggerElement: s,
            hasCustomAnchor: i
        }),
        (e, t) => (Tr(),
        Ir(Nt(rp), null, {
            default: En( () => [Wo(e.$slots, "default", {
                open: Nt(r)
            })]),
            _: 3
        }))
    }
})
  , wp = to({
    __name: "PopoverPortal",
    props: {
        to: {},
        disabled: {
            type: Boolean
        },
        defer: {
            type: Boolean
        },
        forceMount: {
            type: Boolean
        }
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Ir(Nt(Hd), Y(Fr(t)), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , _p = to({
    __name: "PopoverContentImpl",
    props: {
        trapFocus: {
            type: Boolean
        },
        side: {},
        sideOffset: {},
        align: {},
        alignOffset: {},
        avoidCollisions: {
            type: Boolean
        },
        collisionBoundary: {},
        collisionPadding: {},
        arrowPadding: {},
        sticky: {},
        hideWhenDetached: {
            type: Boolean
        },
        positionStrategy: {},
        updatePositionStrategy: {},
        disableUpdateOnLayoutShift: {
            type: Boolean
        },
        prioritizePosition: {
            type: Boolean
        },
        reference: {},
        asChild: {
            type: Boolean
        },
        as: {},
        disableOutsidePointerEvents: {
            type: Boolean
        }
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
    setup(e, {emit: t}) {
        const n = t
          , o = Ud(function(e, ...t) {
            const n = t.flat()
              , o = n[0];
            return _c( () => "function" == typeof o ? Object.fromEntries(Object.entries(Ht(e)).filter( ([e,t]) => !o(Dt(t), e))) : Object.fromEntries(Object.entries(Ht(e)).filter(e => !n.includes(e[0]))))
        }(e, "trapFocus", "disableOutsidePointerEvents"))
          , {forwardRef: a} = Uc()
          , r = gp();
        return vp(),
        (e, t) => (Tr(),
        Ir(Nt(md), {
            "as-child": "",
            loop: "",
            trapped: e.trapFocus,
            onMountAutoFocus: t[5] || (t[5] = e => n("openAutoFocus", e)),
            onUnmountAutoFocus: t[6] || (t[6] = e => n("closeAutoFocus", e))
        }, {
            default: En( () => [jr(Nt(wd), {
                "as-child": "",
                "disable-outside-pointer-events": e.disableOutsidePointerEvents,
                onPointerDownOutside: t[0] || (t[0] = e => n("pointerDownOutside", e)),
                onInteractOutside: t[1] || (t[1] = e => n("interactOutside", e)),
                onEscapeKeyDown: t[2] || (t[2] = e => n("escapeKeyDown", e)),
                onFocusOutside: t[3] || (t[3] = e => n("focusOutside", e)),
                onDismiss: t[4] || (t[4] = e => Nt(r).onOpenChange(!1))
            }, {
                default: En( () => [jr(Nt(pp), Gr(Nt(o), {
                    id: Nt(r).contentId,
                    ref: Nt(a),
                    "data-state": Nt(r).open.value ? "open" : "closed",
                    "aria-labelledby": Nt(r).triggerId,
                    style: {
                        "--reka-popover-content-transform-origin": "var(--reka-popper-transform-origin)",
                        "--reka-popover-content-available-width": "var(--reka-popper-available-width)",
                        "--reka-popover-content-available-height": "var(--reka-popper-available-height)",
                        "--reka-popover-trigger-width": "var(--reka-popper-anchor-width)",
                        "--reka-popover-trigger-height": "var(--reka-popper-anchor-height)"
                    },
                    role: "dialog"
                }), {
                    default: En( () => [Wo(e.$slots, "default")]),
                    _: 3
                }, 16, ["id", "data-state", "aria-labelledby"])]),
                _: 3
            }, 8, ["disable-outside-pointer-events"])]),
            _: 3
        }, 8, ["trapped"]))
    }
})
  , xp = to({
    __name: "PopoverContentModal",
    props: {
        side: {},
        sideOffset: {},
        align: {},
        alignOffset: {},
        avoidCollisions: {
            type: Boolean
        },
        collisionBoundary: {},
        collisionPadding: {},
        arrowPadding: {},
        sticky: {},
        hideWhenDetached: {
            type: Boolean
        },
        positionStrategy: {},
        updatePositionStrategy: {},
        disableUpdateOnLayoutShift: {
            type: Boolean
        },
        prioritizePosition: {
            type: Boolean
        },
        reference: {},
        asChild: {
            type: Boolean
        },
        as: {},
        disableOutsidePointerEvents: {
            type: Boolean
        }
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = gp()
          , r = It(!1);
        jd(!0);
        const s = Zd(n, o)
          , {forwardRef: i, currentElement: l} = Uc();
        return Od(l),
        (e, t) => (Tr(),
        Ir(_p, Gr(Nt(s), {
            ref: Nt(i),
            "trap-focus": Nt(a).open.value,
            "disable-outside-pointer-events": "",
            onCloseAutoFocus: t[0] || (t[0] = Yi(e => {
                var t;
                o("closeAutoFocus", e),
                r.value || null == (t = Nt(a).triggerElement.value) || t.focus()
            }
            , ["prevent"])),
            onPointerDownOutside: t[1] || (t[1] = e => {
                o("pointerDownOutside", e);
                const t = e.detail.originalEvent
                  , n = 0 === t.button && !0 === t.ctrlKey
                  , a = 2 === t.button || n;
                r.value = a
            }
            ),
            onFocusOutside: t[2] || (t[2] = Yi( () => {}
            , ["prevent"]))
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["trap-focus"]))
    }
})
  , kp = to({
    __name: "PopoverContentNonModal",
    props: {
        side: {},
        sideOffset: {},
        align: {},
        alignOffset: {},
        avoidCollisions: {
            type: Boolean
        },
        collisionBoundary: {},
        collisionPadding: {},
        arrowPadding: {},
        sticky: {},
        hideWhenDetached: {
            type: Boolean
        },
        positionStrategy: {},
        updatePositionStrategy: {},
        disableUpdateOnLayoutShift: {
            type: Boolean
        },
        prioritizePosition: {
            type: Boolean
        },
        reference: {},
        asChild: {
            type: Boolean
        },
        as: {},
        disableOutsidePointerEvents: {
            type: Boolean
        }
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = gp()
          , r = It(!1)
          , s = It(!1)
          , i = Zd(n, o);
        return (e, t) => (Tr(),
        Ir(_p, Gr(Nt(i), {
            "trap-focus": !1,
            "disable-outside-pointer-events": !1,
            onCloseAutoFocus: t[0] || (t[0] = e => {
                var t;
                o("closeAutoFocus", e),
                e.defaultPrevented || (r.value || null == (t = Nt(a).triggerElement.value) || t.focus(),
                e.preventDefault()),
                r.value = !1,
                s.value = !1
            }
            ),
            onInteractOutside: t[1] || (t[1] = async e => {
                var t;
                o("interactOutside", e),
                e.defaultPrevented || (r.value = !0,
                "pointerdown" === e.detail.originalEvent.type && (s.value = !0));
                const n = e.target;
                (null == (t = Nt(a).triggerElement.value) ? void 0 : t.contains(n)) && e.preventDefault(),
                "focusin" === e.detail.originalEvent.type && s.value && e.preventDefault()
            }
            )
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , Sp = to({
    __name: "PopoverContent",
    props: {
        forceMount: {
            type: Boolean
        },
        side: {},
        sideOffset: {},
        align: {},
        alignOffset: {},
        avoidCollisions: {
            type: Boolean
        },
        collisionBoundary: {},
        collisionPadding: {},
        arrowPadding: {},
        sticky: {},
        hideWhenDetached: {
            type: Boolean
        },
        positionStrategy: {},
        updatePositionStrategy: {},
        disableUpdateOnLayoutShift: {
            type: Boolean
        },
        prioritizePosition: {
            type: Boolean
        },
        reference: {},
        asChild: {
            type: Boolean
        },
        as: {},
        disableOutsidePointerEvents: {
            type: Boolean
        }
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = gp()
          , r = Zd(n, o)
          , {forwardRef: s} = Uc();
        return a.contentId || (a.contentId = Kc(0, "reka-popover-content")),
        (e, t) => (Tr(),
        Ir(Nt(Jc), {
            present: e.forceMount || Nt(a).open.value
        }, {
            default: En( () => [Nt(a).modal.value ? (Tr(),
            Ir(xp, Gr({
                key: 0
            }, Nt(r), {
                ref: Nt(s)
            }), {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            }, 16)) : (Tr(),
            Ir(kp, Gr({
                key: 1
            }, Nt(r), {
                ref: Nt(s)
            }), {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            }, 16))]),
            _: 3
        }, 8, ["present"]))
    }
})
  , Cp = to({
    __name: "PopoverTrigger",
    props: {
        asChild: {
            type: Boolean
        },
        as: {
            default: "button"
        }
    },
    setup(e) {
        const t = e
          , n = gp()
          , {forwardRef: o, currentElement: a} = Uc();
        return n.triggerId || (n.triggerId = Kc(0, "reka-popover-trigger")),
        Mo( () => {
            n.triggerElement.value = a.value
        }
        ),
        (e, a) => (Tr(),
        Ir(Vo(Nt(n).hasCustomAnchor.value ? Nt(yc) : Nt(sp)), {
            "as-child": ""
        }, {
            default: En( () => [jr(Nt(yc), {
                id: Nt(n).triggerId,
                ref: Nt(o),
                type: "button" === e.as ? "button" : void 0,
                "aria-haspopup": "dialog",
                "aria-expanded": Nt(n).open.value,
                "aria-controls": Nt(n).contentId,
                "data-state": Nt(n).open.value ? "open" : "closed",
                as: e.as,
                "as-child": t.asChild,
                onClick: Nt(n).onOpenToggle
            }, {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            }, 8, ["id", "type", "aria-expanded", "aria-controls", "data-state", "as", "as-child", "onClick"])]),
            _: 3
        }))
    }
})
  , Ep = to({
    __name: "DialogPortal",
    props: {
        to: {},
        disabled: {
            type: Boolean
        },
        defer: {
            type: Boolean
        },
        forceMount: {
            type: Boolean
        }
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Ir(Nt(Hd), Y(Fr(t)), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , Tp = to({
    __name: "Label",
    props: {
        for: {},
        asChild: {
            type: Boolean
        },
        as: {
            default: "label"
        }
    },
    setup(e) {
        const t = e;
        return Uc(),
        (e, n) => (Tr(),
        Ir(Nt(yc), Gr(t, {
            onMousedown: n[0] || (n[0] = e => {
                !e.defaultPrevented && e.detail > 1 && e.preventDefault()
            }
            )
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
});
function Ap(e, t=Number.NEGATIVE_INFINITY, n=Number.POSITIVE_INFINITY) {
    return Math.min(n, Math.max(t, e))
}
const [Op,Mp] = Nc("ProgressRoot")
  , Pp = e => "number" == typeof e;
const Bp = to({
    __name: "ProgressRoot",
    props: {
        modelValue: {},
        max: {
            default: 100
        },
        getValueLabel: {
            type: Function,
            default: (e, t) => Pp(e) ? `${Math.round(e / t * 100)}%` : void 0
        },
        getValueText: {},
        asChild: {
            type: Boolean
        },
        as: {}
    },
    emits: ["update:modelValue", "update:max"],
    setup(e, {emit: t}) {
        const n = e
          , o = t;
        Uc();
        const a = zc(n, "modelValue", o, {
            passive: void 0 === n.modelValue
        })
          , r = zc(n, "max", o, {
            passive: void 0 === n.max
        });
        Qa( () => a.value, async e => {
            const t = function(e, t) {
                return Fc(e) || Pp(e) && !Number.isNaN(e) && e <= t && e >= 0 ? e : null
            }(e, n.max);
            t !== e && (await fn(),
            a.value = t)
        }
        , {
            immediate: !0
        }),
        Qa( () => n.max, e => {
            const t = function(e) {
                return Pp(e) && !Number.isNaN(e) && e > 0 ? e : 100
            }(n.max);
            t !== e && (r.value = t)
        }
        , {
            immediate: !0
        });
        const s = ms( () => Fc(a.value) ? "indeterminate" : a.value === r.value ? "complete" : "loading");
        return Mp({
            modelValue: a,
            max: r,
            progressState: s
        }),
        (e, t) => {
            var n;
            return Tr(),
            Ir(Nt(yc), {
                "as-child": e.asChild,
                as: e.as,
                "aria-valuemax": Nt(r),
                "aria-valuemin": 0,
                "aria-valuenow": Pp(Nt(a)) ? Nt(a) : void 0,
                "aria-valuetext": null == (n = e.getValueText) ? void 0 : n.call(e, Nt(a), Nt(r)),
                "aria-label": e.getValueLabel(Nt(a), Nt(r)),
                role: "progressbar",
                "data-state": s.value,
                "data-value": Nt(a) ?? void 0,
                "data-max": Nt(r)
            }, {
                default: En( () => [Wo(e.$slots, "default", {
                    modelValue: Nt(a)
                })]),
                _: 3
            }, 8, ["as-child", "as", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-label", "data-state", "data-value", "data-max"])
        }
    }
})
  , Ip = to({
    __name: "ProgressIndicator",
    props: {
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = e
          , n = Op();
        return Uc(),
        (e, o) => {
            var a;
            return Tr(),
            Ir(Nt(yc), Gr(t, {
                "data-state": Nt(n).progressState.value,
                "data-value": (null == (a = Nt(n).modelValue) ? void 0 : a.value) ?? void 0,
                "data-max": Nt(n).max.value
            }), {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            }, 16, ["data-state", "data-value", "data-max"])
        }
    }
})
  , Lp = [" ", "Enter", "ArrowUp", "ArrowDown"]
  , Rp = [" ", "Enter"]
  , zp = 10;
function Np(e, t, n) {
    return void 0 !== e && (Array.isArray(e) ? e.some(e => Dp(e, t, n)) : Dp(e, t, n))
}
function Dp(e, t, n) {
    return void 0 !== e && void 0 !== t && ("string" == typeof e ? e === t : "function" == typeof n ? n(e, t) : "string" == typeof n ? (null == e ? void 0 : e[n]) === (null == t ? void 0 : t[n]) : (o = e) === (a = t) || Dc(o) === Dc(a));
    var o, a
}
function jp(e) {
    return null == e || "" === e || Array.isArray(e) && 0 === e.length
}
const Fp = to({
    __name: "BubbleSelect",
    props: {
        autocomplete: {},
        autofocus: {
            type: Boolean
        },
        disabled: {
            type: Boolean
        },
        form: {},
        multiple: {
            type: Boolean
        },
        name: {},
        required: {
            type: Boolean
        },
        size: {},
        value: {}
    },
    setup(e) {
        const t = e
          , n = It();
        return Qa( () => t.value, (e, t) => {
            const o = window.HTMLSelectElement.prototype
              , a = Object.getOwnPropertyDescriptor(o, "value").set;
            if (e !== t && a && n.value) {
                const t = new Event("change",{
                    bubbles: !0
                });
                a.call(n.value, e),
                n.value.dispatchEvent(t)
            }
        }
        ),
        (e, o) => (Tr(),
        Ir(Nt(bc), {
            "as-child": ""
        }, {
            default: En( () => [Dr("select", Gr({
                ref_key: "selectElement",
                ref: n
            }, t), [Wo(e.$slots, "default")], 16)]),
            _: 3
        }))
    }
})
  , $p = {
    key: 0,
    value: ""
}
  , [Vp,Hp] = Nc("SelectRoot")
  , Up = to({
    inheritAttrs: !1,
    __name: "SelectRoot",
    props: {
        open: {
            type: Boolean,
            default: void 0
        },
        defaultOpen: {
            type: Boolean
        },
        defaultValue: {},
        modelValue: {
            default: void 0
        },
        by: {},
        dir: {},
        multiple: {
            type: Boolean
        },
        autocomplete: {},
        disabled: {
            type: Boolean
        },
        name: {},
        required: {
            type: Boolean
        }
    },
    emits: ["update:modelValue", "update:open"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , {required: a, disabled: r, multiple: s, dir: i} = Ht(n)
          , l = zc(n, "modelValue", o, {
            defaultValue: n.defaultValue ?? (s.value ? [] : void 0),
            passive: void 0 === n.modelValue,
            deep: !0
        })
          , u = zc(n, "open", o, {
            defaultValue: n.defaultOpen,
            passive: void 0 === n.open
        })
          , c = It()
          , d = It()
          , p = It({
            x: 0,
            y: 0
        })
          , f = ms( () => {
            var e;
            return s.value && Array.isArray(l.value) ? 0 === (null == (e = l.value) ? void 0 : e.length) : Fc(l.value)
        }
        );
        np({
            isProvider: !0
        });
        const h = Hc(i)
          , v = (m = c,
        ms( () => {
            var e;
            return !Ac(m) || Boolean(null == (e = Pc(m)) ? void 0 : e.closest("form"))
        }
        ));
        var m;
        const g = It(new Set)
          , y = ms( () => Array.from(g.value).map(e => e.value).join(";"));
        return Hp({
            triggerElement: c,
            onTriggerChange: e => {
                c.value = e
            }
            ,
            valueElement: d,
            onValueElementChange: e => {
                d.value = e
            }
            ,
            contentId: "",
            modelValue: l,
            onValueChange: function(e) {
                if (s.value) {
                    const t = Array.isArray(l.value) ? [...l.value] : []
                      , o = t.findIndex(t => Dp(t, e, n.by));
                    -1 === o ? t.push(e) : t.splice(o, 1),
                    l.value = [...t]
                } else
                    l.value = e
            },
            by: n.by,
            open: u,
            multiple: s,
            required: a,
            onOpenChange: e => {
                u.value = e
            }
            ,
            dir: h,
            triggerPointerDownPosRef: p,
            disabled: r,
            isEmptyModelValue: f,
            optionsSet: g,
            onOptionAdd: e => g.value.add(e),
            onOptionRemove: e => g.value.delete(e)
        }),
        (e, t) => (Tr(),
        Ir(Nt(rp), null, {
            default: En( () => [Wo(e.$slots, "default", {
                modelValue: Nt(l),
                open: Nt(u)
            }), Nt(v) ? (Tr(),
            Ir(Fp, {
                key: y.value,
                "aria-hidden": "true",
                tabindex: "-1",
                multiple: Nt(s),
                required: Nt(a),
                name: e.name,
                autocomplete: e.autocomplete,
                disabled: Nt(r),
                value: Nt(l)
            }, {
                default: En( () => [Nt(Fc)(Nt(l)) ? (Tr(),
                Br("option", $p)) : Ur("", !0), (Tr(!0),
                Br(_r, null, qo(Array.from(g.value), e => (Tr(),
                Br("option", Gr({
                    key: e.value ?? "",
                    ref_for: !0
                }, e), null, 16))), 128))]),
                _: 1
            }, 8, ["multiple", "required", "name", "autocomplete", "disabled", "value"])) : Ur("", !0)]),
            _: 3
        }))
    }
})
  , [Zp,qp] = Nc("SelectItemAlignedPosition")
  , Wp = to({
    inheritAttrs: !1,
    __name: "SelectItemAlignedPosition",
    props: {
        asChild: {
            type: Boolean
        },
        as: {}
    },
    emits: ["placed"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , {getItems: a} = np()
          , r = Vp()
          , s = Yp()
          , i = It(!1)
          , l = It(!0)
          , u = It()
          , {forwardRef: c, currentElement: d} = Uc()
          , {viewport: p, selectedItem: f, selectedItemText: h, focusSelectedItem: v} = s;
        function m() {
            if (r.triggerElement.value && r.valueElement.value && u.value && d.value && (null == p ? void 0 : p.value) && (null == f ? void 0 : f.value) && (null == h ? void 0 : h.value)) {
                const e = r.triggerElement.value.getBoundingClientRect()
                  , t = d.value.getBoundingClientRect()
                  , n = r.valueElement.value.getBoundingClientRect()
                  , s = h.value.getBoundingClientRect();
                if ("rtl" !== r.dir.value) {
                    const o = s.left - t.left
                      , a = n.left - o
                      , r = e.left - a
                      , i = e.width + r
                      , l = Math.max(i, t.width)
                      , c = window.innerWidth - zp
                      , d = Ap(a, zp, Math.max(zp, c - l));
                    u.value.style.minWidth = `${i}px`,
                    u.value.style.left = `${d}px`
                } else {
                    const o = t.right - s.right
                      , a = window.innerWidth - n.right - o
                      , r = window.innerWidth - e.right - a
                      , i = e.width + r
                      , l = Math.max(i, t.width)
                      , c = window.innerWidth - zp
                      , d = Ap(a, zp, Math.max(zp, c - l));
                    u.value.style.minWidth = `${i}px`,
                    u.value.style.right = `${d}px`
                }
                const l = a().map(e => e.ref)
                  , c = window.innerHeight - 20
                  , v = p.value.scrollHeight
                  , m = window.getComputedStyle(d.value)
                  , g = Number.parseInt(m.borderTopWidth, 10)
                  , y = Number.parseInt(m.paddingTop, 10)
                  , b = Number.parseInt(m.borderBottomWidth, 10)
                  , w = g + y + v + Number.parseInt(m.paddingBottom, 10) + b
                  , _ = Math.min(5 * f.value.offsetHeight, w)
                  , x = window.getComputedStyle(p.value)
                  , k = Number.parseInt(x.paddingTop, 10)
                  , S = Number.parseInt(x.paddingBottom, 10)
                  , C = e.top + e.height / 2 - zp
                  , E = c - C
                  , T = f.value.offsetHeight / 2
                  , A = g + y + (f.value.offsetTop + T)
                  , O = w - A;
                if (A <= C) {
                    const e = f.value === l[l.length - 1];
                    u.value.style.bottom = "0px";
                    const t = d.value.clientHeight - p.value.offsetTop - p.value.offsetHeight
                      , n = A + Math.max(E, T + (e ? S : 0) + t + b);
                    u.value.style.height = `${n}px`
                } else {
                    const e = f.value === l[0];
                    u.value.style.top = "0px";
                    const t = Math.max(C, g + p.value.offsetTop + (e ? k : 0) + T) + O;
                    u.value.style.height = `${t}px`,
                    p.value.scrollTop = A - C + p.value.offsetTop
                }
                u.value.style.margin = "10px 0",
                u.value.style.minHeight = `${_}px`,
                u.value.style.maxHeight = `${c}px`,
                o("placed"),
                requestAnimationFrame( () => i.value = !0)
            }
        }
        const g = It("");
        return Mo(async () => {
            await fn(),
            m(),
            d.value && (g.value = window.getComputedStyle(d.value).zIndex)
        }
        ),
        Rc(r.triggerElement, () => {
            m()
        }
        ),
        qp({
            contentWrapper: u,
            shouldExpandOnScrollRef: i,
            onScrollButtonChange: function(e) {
                e && !0 === l.value && (m(),
                null == v || v(),
                l.value = !1)
            }
        }),
        (e, t) => (Tr(),
        Br("div", {
            ref_key: "contentWrapperElement",
            ref: u,
            style: U({
                display: "flex",
                flexDirection: "column",
                position: "fixed",
                zIndex: g.value
            })
        }, [jr(Nt(yc), Gr({
            ref: Nt(c),
            style: {
                boxSizing: "border-box",
                maxHeight: "100%"
            }
        }, {
            ...e.$attrs,
            ...n
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16)], 4))
    }
})
  , Gp = to({
    __name: "SelectPopperPosition",
    props: {
        side: {},
        sideOffset: {},
        align: {
            default: "start"
        },
        alignOffset: {},
        avoidCollisions: {
            type: Boolean
        },
        collisionBoundary: {},
        collisionPadding: {
            default: zp
        },
        arrowPadding: {},
        sticky: {},
        hideWhenDetached: {
            type: Boolean
        },
        positionStrategy: {},
        updatePositionStrategy: {},
        disableUpdateOnLayoutShift: {
            type: Boolean
        },
        prioritizePosition: {
            type: Boolean
        },
        reference: {},
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = Ud(e);
        return (e, n) => (Tr(),
        Ir(Nt(pp), Gr(Nt(t), {
            style: {
                boxSizing: "border-box",
                "--reka-select-content-transform-origin": "var(--reka-popper-transform-origin)",
                "--reka-select-content-available-width": "var(--reka-popper-available-width)",
                "--reka-select-content-available-height": "var(--reka-popper-available-height)",
                "--reka-select-trigger-width": "var(--reka-popper-anchor-width)",
                "--reka-select-trigger-height": "var(--reka-popper-anchor-height)"
            }
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , Kp = {
    onViewportChange: () => {}
    ,
    itemTextRefCallback: () => {}
    ,
    itemRefCallback: () => {}
}
  , [Yp,Xp] = Nc("SelectContent")
  , Jp = to({
    __name: "SelectContentImpl",
    props: {
        position: {
            default: "item-aligned"
        },
        bodyLock: {
            type: Boolean,
            default: !0
        },
        side: {},
        sideOffset: {},
        align: {
            default: "start"
        },
        alignOffset: {},
        avoidCollisions: {
            type: Boolean
        },
        collisionBoundary: {},
        collisionPadding: {},
        arrowPadding: {},
        sticky: {},
        hideWhenDetached: {
            type: Boolean
        },
        positionStrategy: {},
        updatePositionStrategy: {},
        disableUpdateOnLayoutShift: {
            type: Boolean
        },
        prioritizePosition: {
            type: Boolean
        },
        reference: {},
        asChild: {
            type: Boolean
        },
        as: {}
    },
    emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = Vp();
        vp(),
        jd(n.bodyLock);
        const {CollectionSlot: r, getItems: s} = np()
          , i = It();
        Od(i);
        const {search: l, handleTypeaheadSearch: u} = fp()
          , c = It()
          , d = It()
          , p = It()
          , f = It(!1)
          , h = It(!1)
          , v = It(!1);
        function m() {
            d.value && i.value && sd([d.value, i.value])
        }
        Qa(f, () => {
            m()
        }
        );
        const {onOpenChange: g, triggerPointerDownPosRef: y} = a;
        function b(e) {
            const t = e.ctrlKey || e.altKey || e.metaKey;
            if ("Tab" === e.key && e.preventDefault(),
            t || 1 !== e.key.length || u(e.key, s()),
            ["ArrowUp", "ArrowDown", "Home", "End"].includes(e.key)) {
                let t = [...s().map(e => e.ref)];
                if (["ArrowUp", "End"].includes(e.key) && (t = t.slice().reverse()),
                ["ArrowUp", "ArrowDown"].includes(e.key)) {
                    const n = e.target
                      , o = t.indexOf(n);
                    t = t.slice(o + 1)
                }
                setTimeout( () => sd(t)),
                e.preventDefault()
            }
        }
        Ya(e => {
            if (!i.value)
                return;
            let t = {
                x: 0,
                y: 0
            };
            const n = e => {
                var n, o;
                t = {
                    x: Math.abs(Math.round(e.pageX) - ((null == (n = y.value) ? void 0 : n.x) ?? 0)),
                    y: Math.abs(Math.round(e.pageY) - ((null == (o = y.value) ? void 0 : o.y) ?? 0))
                }
            }
              , o = e => {
                var o;
                "touch" !== e.pointerType && (t.x <= 10 && t.y <= 10 ? e.preventDefault() : (null == (o = i.value) ? void 0 : o.contains(e.target)) || g(!1),
                document.removeEventListener("pointermove", n),
                y.value = null)
            }
            ;
            null !== y.value && (document.addEventListener("pointermove", n),
            document.addEventListener("pointerup", o, {
                capture: !0,
                once: !0
            })),
            e( () => {
                document.removeEventListener("pointermove", n),
                document.removeEventListener("pointerup", o, {
                    capture: !0
                })
            }
            )
        }
        );
        const w = Ud(ms( () => "popper" === n.position ? n : {}).value);
        return Xp({
            content: i,
            viewport: c,
            onViewportChange: e => {
                c.value = e
            }
            ,
            itemRefCallback: (e, t, n) => {
                const o = !h.value && !n
                  , r = Np(a.modelValue.value, t, a.by);
                if (a.multiple.value) {
                    if (v.value)
                        return;
                    (r || o) && (d.value = e,
                    r && (v.value = !0))
                } else
                    (r || o) && (d.value = e);
                o && (h.value = !0)
            }
            ,
            selectedItem: d,
            selectedItemText: p,
            onItemLeave: () => {
                var e;
                null == (e = i.value) || e.focus()
            }
            ,
            itemTextRefCallback: (e, t, n) => {
                const o = !h.value && !n;
                (Np(a.modelValue.value, t, a.by) || o) && (p.value = e)
            }
            ,
            focusSelectedItem: m,
            position: n.position,
            isPositioned: f,
            searchRef: l
        }),
        (e, t) => (Tr(),
        Ir(Nt(r), null, {
            default: En( () => [jr(Nt(md), {
                "as-child": "",
                onMountAutoFocus: t[6] || (t[6] = Yi( () => {}
                , ["prevent"])),
                onUnmountAutoFocus: t[7] || (t[7] = e => {
                    var t;
                    o("closeAutoFocus", e),
                    e.defaultPrevented || (null == (t = Nt(a).triggerElement.value) || t.focus({
                        preventScroll: !0
                    }),
                    e.preventDefault())
                }
                )
            }, {
                default: En( () => [jr(Nt(wd), {
                    "as-child": "",
                    "disable-outside-pointer-events": "",
                    onFocusOutside: t[2] || (t[2] = Yi( () => {}
                    , ["prevent"])),
                    onDismiss: t[3] || (t[3] = e => Nt(a).onOpenChange(!1)),
                    onEscapeKeyDown: t[4] || (t[4] = e => o("escapeKeyDown", e)),
                    onPointerDownOutside: t[5] || (t[5] = e => o("pointerDownOutside", e))
                }, {
                    default: En( () => [(Tr(),
                    Ir(Vo("popper" === e.position ? Gp : Wp), Gr({
                        ...e.$attrs,
                        ...Nt(w)
                    }, {
                        id: Nt(a).contentId,
                        ref: e => {
                            i.value = Nt(Pc)(e)
                        }
                        ,
                        role: "listbox",
                        "data-state": Nt(a).open.value ? "open" : "closed",
                        dir: Nt(a).dir.value,
                        style: {
                            display: "flex",
                            flexDirection: "column",
                            outline: "none"
                        },
                        onContextmenu: t[0] || (t[0] = Yi( () => {}
                        , ["prevent"])),
                        onPlaced: t[1] || (t[1] = e => f.value = !0),
                        onKeydown: b
                    }), {
                        default: En( () => [Wo(e.$slots, "default")]),
                        _: 3
                    }, 16, ["id", "data-state", "dir", "onKeydown"]))]),
                    _: 3
                })]),
                _: 3
            })]),
            _: 3
        }))
    }
})
  , Qp = to({
    inheritAttrs: !1,
    __name: "SelectProvider",
    props: {
        context: {}
    },
    setup: e => (Hp(e.context),
    Xp(Kp),
    (e, t) => Wo(e.$slots, "default"))
})
  , ef = {
    key: 1
}
  , tf = to({
    inheritAttrs: !1,
    __name: "SelectContent",
    props: {
        forceMount: {
            type: Boolean
        },
        position: {},
        bodyLock: {
            type: Boolean
        },
        side: {},
        sideOffset: {},
        align: {},
        alignOffset: {},
        avoidCollisions: {
            type: Boolean
        },
        collisionBoundary: {},
        collisionPadding: {},
        arrowPadding: {},
        sticky: {},
        hideWhenDetached: {
            type: Boolean
        },
        positionStrategy: {},
        updatePositionStrategy: {},
        disableUpdateOnLayoutShift: {
            type: Boolean
        },
        prioritizePosition: {
            type: Boolean
        },
        reference: {},
        asChild: {
            type: Boolean
        },
        as: {}
    },
    emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
    setup(e, {emit: t}) {
        const n = e
          , o = Zd(n, t)
          , a = Vp()
          , r = It();
        Mo( () => {
            r.value = new DocumentFragment
        }
        );
        const s = It()
          , i = ms( () => n.forceMount || a.open.value)
          , l = It(i.value);
        return Qa(i, () => {
            setTimeout( () => l.value = i.value)
        }
        ),
        (e, t) => {
            var n;
            return i.value || l.value || (null == (n = s.value) ? void 0 : n.present) ? (Tr(),
            Ir(Nt(Jc), {
                key: 0,
                ref_key: "presenceRef",
                ref: s,
                present: i.value
            }, {
                default: En( () => [jr(Jp, Y(Fr({
                    ...Nt(o),
                    ...e.$attrs
                })), {
                    default: En( () => [Wo(e.$slots, "default")]),
                    _: 3
                }, 16)]),
                _: 3
            }, 8, ["present"])) : r.value ? (Tr(),
            Br("div", ef, [(Tr(),
            Ir(Dn, {
                to: r.value
            }, [jr(Qp, {
                context: Nt(a)
            }, {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            }, 8, ["context"])], 8, ["to"]))])) : Ur("", !0)
        }
    }
})
  , [nf,of] = Nc("SelectGroup")
  , af = to({
    __name: "SelectGroup",
    props: {
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = e
          , n = Kc(0, "reka-select-group");
        return of({
            id: n
        }),
        (e, o) => (Tr(),
        Ir(Nt(yc), Gr({
            role: "group"
        }, t, {
            "aria-labelledby": Nt(n)
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["aria-labelledby"]))
    }
})
  , rf = to({
    __name: "SelectIcon",
    props: {
        asChild: {
            type: Boolean
        },
        as: {
            default: "span"
        }
    },
    setup: e => (e, t) => (Tr(),
    Ir(Nt(yc), {
        "aria-hidden": "true",
        as: e.as,
        "as-child": e.asChild
    }, {
        default: En( () => [Wo(e.$slots, "default", {}, () => [t[0] || (t[0] = Vr(""))])]),
        _: 3
    }, 8, ["as", "as-child"]))
})
  , [sf,lf] = Nc("SelectItem")
  , uf = to({
    __name: "SelectItem",
    props: {
        value: {},
        disabled: {
            type: Boolean
        },
        textValue: {},
        asChild: {
            type: Boolean
        },
        as: {}
    },
    emits: ["select"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , {disabled: a} = Ht(n)
          , r = Vp()
          , s = Yp()
          , {forwardRef: i, currentElement: l} = Uc()
          , {CollectionItem: u} = np()
          , c = ms( () => {
            var e;
            return Np(null == (e = r.modelValue) ? void 0 : e.value, n.value, r.by)
        }
        )
          , d = It(!1)
          , p = It(n.textValue ?? "")
          , f = Kc(0, "reka-select-item-text");
        async function h(e) {
            if (e.defaultPrevented)
                return;
            gd("select.select", v, {
                originalEvent: e,
                value: n.value
            })
        }
        async function v(e) {
            await fn(),
            o("select", e),
            e.defaultPrevented || a.value || (r.onValueChange(n.value),
            r.multiple.value || r.onOpenChange(!1))
        }
        async function m(e) {
            var t, n;
            await fn(),
            e.defaultPrevented || (a.value ? null == (t = s.onItemLeave) || t.call(s) : null == (n = e.currentTarget) || n.focus({
                preventScroll: !0
            }))
        }
        async function g(e) {
            var t;
            await fn(),
            e.defaultPrevented || e.currentTarget === ad() && (null == (t = s.onItemLeave) || t.call(s))
        }
        async function y(e) {
            var t;
            if (await fn(),
            e.defaultPrevented)
                return;
            "" !== (null == (t = s.searchRef) ? void 0 : t.value) && " " === e.key || (Rp.includes(e.key) && h(e),
            " " === e.key && e.preventDefault())
        }
        if ("" === n.value)
            throw new Error("A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
        return Mo( () => {
            l.value && s.itemRefCallback(l.value, n.value, n.disabled)
        }
        ),
        lf({
            value: n.value,
            disabled: a,
            textId: f,
            isSelected: c,
            onItemTextChange: e => {
                p.value = ((p.value || (null == e ? void 0 : e.textContent)) ?? "").trim()
            }
        }),
        (e, t) => (Tr(),
        Ir(Nt(u), {
            value: {
                textValue: p.value
            }
        }, {
            default: En( () => [jr(Nt(yc), {
                ref: Nt(i),
                role: "option",
                "aria-labelledby": Nt(f),
                "data-highlighted": d.value ? "" : void 0,
                "aria-selected": c.value,
                "data-state": c.value ? "checked" : "unchecked",
                "aria-disabled": Nt(a) || void 0,
                "data-disabled": Nt(a) ? "" : void 0,
                tabindex: Nt(a) ? void 0 : -1,
                as: e.as,
                "as-child": e.asChild,
                onFocus: t[0] || (t[0] = e => d.value = !0),
                onBlur: t[1] || (t[1] = e => d.value = !1),
                onPointerup: h,
                onPointerdown: t[2] || (t[2] = e => {
                    e.currentTarget.focus({
                        preventScroll: !0
                    })
                }
                ),
                onTouchend: t[3] || (t[3] = Yi( () => {}
                , ["prevent", "stop"])),
                onPointermove: m,
                onPointerleave: g,
                onKeydown: y
            }, {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "tabindex", "as", "as-child"])]),
            _: 3
        }, 8, ["value"]))
    }
})
  , cf = to({
    __name: "SelectItemIndicator",
    props: {
        asChild: {
            type: Boolean
        },
        as: {
            default: "span"
        }
    },
    setup(e) {
        const t = e
          , n = sf();
        return (e, o) => Nt(n).isSelected.value ? (Tr(),
        Ir(Nt(yc), Gr({
            key: 0,
            "aria-hidden": "true"
        }, t), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16)) : Ur("", !0)
    }
})
  , df = to({
    inheritAttrs: !1,
    __name: "SelectItemText",
    props: {
        asChild: {
            type: Boolean
        },
        as: {
            default: "span"
        }
    },
    setup(e) {
        const t = e
          , n = Vp()
          , o = Yp()
          , a = sf()
          , {forwardRef: r, currentElement: s} = Uc()
          , i = ms( () => {
            var e, t;
            return {
                value: a.value,
                disabled: a.disabled.value,
                textContent: (null == (e = s.value) ? void 0 : e.textContent) ?? (null == (t = a.value) ? void 0 : t.toString()) ?? ""
            }
        }
        );
        return Mo( () => {
            s.value && (a.onItemTextChange(s.value),
            o.itemTextRefCallback(s.value, a.value, a.disabled.value),
            n.onOptionAdd(i.value))
        }
        ),
        Lo( () => {
            n.onOptionRemove(i.value)
        }
        ),
        (e, n) => (Tr(),
        Ir(Nt(yc), Gr({
            id: Nt(a).textId,
            ref: Nt(r)
        }, {
            ...t,
            ...e.$attrs
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["id"]))
    }
})
  , pf = to({
    __name: "SelectPortal",
    props: {
        to: {},
        disabled: {
            type: Boolean
        },
        defer: {
            type: Boolean
        },
        forceMount: {
            type: Boolean
        }
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Ir(Nt(Hd), Y(Fr(t)), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , ff = to({
    __name: "SelectScrollButtonImpl",
    emits: ["autoScroll"],
    setup(e, {emit: t}) {
        const n = t
          , {getItems: o} = np()
          , a = Yp()
          , r = It(null);
        function s() {
            null !== r.value && (window.clearInterval(r.value),
            r.value = null)
        }
        function i() {
            null === r.value && (r.value = window.setInterval( () => {
                n("autoScroll")
            }
            , 50))
        }
        function l() {
            var e;
            null == (e = a.onItemLeave) || e.call(a),
            null === r.value && (r.value = window.setInterval( () => {
                n("autoScroll")
            }
            , 50))
        }
        return Ya( () => {
            const e = o().map(e => e.ref).find(e => e === ad());
            null == e || e.scrollIntoView({
                block: "nearest"
            })
        }
        ),
        Io( () => s()),
        (e, t) => {
            var n;
            return Tr(),
            Ir(Nt(yc), Gr({
                "aria-hidden": "true",
                style: {
                    flexShrink: 0
                }
            }, null == (n = e.$parent) ? void 0 : n.$props, {
                onPointerdown: i,
                onPointermove: l,
                onPointerleave: t[0] || (t[0] = () => {
                    s()
                }
                )
            }), {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            }, 16)
        }
    }
})
  , hf = to({
    __name: "SelectScrollDownButton",
    props: {
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = Yp()
          , n = "item-aligned" === t.position ? Zp() : void 0
          , {forwardRef: o, currentElement: a} = Uc()
          , r = It(!1);
        return Ya(e => {
            var n, o;
            if ((null == (n = t.viewport) ? void 0 : n.value) && (null == (o = t.isPositioned) ? void 0 : o.value)) {
                let n = function() {
                    const e = o.scrollHeight - o.clientHeight;
                    r.value = Math.ceil(o.scrollTop) < e
                };
                const o = t.viewport.value;
                n(),
                o.addEventListener("scroll", n),
                e( () => o.removeEventListener("scroll", n))
            }
        }
        ),
        Qa(a, () => {
            a.value && (null == n || n.onScrollButtonChange(a.value))
        }
        ),
        (e, n) => r.value ? (Tr(),
        Ir(ff, {
            key: 0,
            ref: Nt(o),
            onAutoScroll: n[0] || (n[0] = () => {
                const {viewport: e, selectedItem: n} = Nt(t);
                (null == e ? void 0 : e.value) && (null == n ? void 0 : n.value) && (e.value.scrollTop = e.value.scrollTop + n.value.offsetHeight)
            }
            )
        }, {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 512)) : Ur("", !0)
    }
})
  , vf = to({
    __name: "SelectScrollUpButton",
    props: {
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = Yp()
          , n = "item-aligned" === t.position ? Zp() : void 0
          , {forwardRef: o, currentElement: a} = Uc()
          , r = It(!1);
        return Ya(e => {
            var n, o;
            if ((null == (n = t.viewport) ? void 0 : n.value) && (null == (o = t.isPositioned) ? void 0 : o.value)) {
                let n = function() {
                    r.value = o.scrollTop > 0
                };
                const o = t.viewport.value;
                n(),
                o.addEventListener("scroll", n),
                e( () => o.removeEventListener("scroll", n))
            }
        }
        ),
        Qa(a, () => {
            a.value && (null == n || n.onScrollButtonChange(a.value))
        }
        ),
        (e, n) => r.value ? (Tr(),
        Ir(ff, {
            key: 0,
            ref: Nt(o),
            onAutoScroll: n[0] || (n[0] = () => {
                const {viewport: e, selectedItem: n} = Nt(t);
                (null == e ? void 0 : e.value) && (null == n ? void 0 : n.value) && (e.value.scrollTop = e.value.scrollTop - n.value.offsetHeight)
            }
            )
        }, {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 512)) : Ur("", !0)
    }
})
  , mf = to({
    __name: "SelectTrigger",
    props: {
        disabled: {
            type: Boolean
        },
        reference: {},
        asChild: {
            type: Boolean
        },
        as: {
            default: "button"
        }
    },
    setup(e) {
        const t = e
          , n = Vp()
          , {forwardRef: o, currentElement: a} = Uc()
          , r = ms( () => {
            var e;
            return (null == (e = n.disabled) ? void 0 : e.value) || t.disabled
        }
        );
        n.contentId || (n.contentId = Kc(0, "reka-select-content")),
        Mo( () => {
            n.onTriggerChange(a.value)
        }
        );
        const {getItems: s} = np()
          , {search: i, handleTypeaheadSearch: l, resetTypeahead: u} = fp();
        function c() {
            r.value || (n.onOpenChange(!0),
            u())
        }
        function d(e) {
            c(),
            n.triggerPointerDownPosRef.value = {
                x: Math.round(e.pageX),
                y: Math.round(e.pageY)
            }
        }
        return (e, t) => (Tr(),
        Ir(Nt(sp), {
            "as-child": "",
            reference: e.reference
        }, {
            default: En( () => {
                var a, u, p, f;
                return [jr(Nt(yc), {
                    ref: Nt(o),
                    role: "combobox",
                    type: "button" === e.as ? "button" : void 0,
                    "aria-controls": Nt(n).contentId,
                    "aria-expanded": Nt(n).open.value || !1,
                    "aria-required": null == (a = Nt(n).required) ? void 0 : a.value,
                    "aria-autocomplete": "none",
                    disabled: r.value,
                    dir: null == (u = Nt(n)) ? void 0 : u.dir.value,
                    "data-state": (null == (p = Nt(n)) ? void 0 : p.open.value) ? "open" : "closed",
                    "data-disabled": r.value ? "" : void 0,
                    "data-placeholder": Nt(jp)(null == (f = Nt(n).modelValue) ? void 0 : f.value) ? "" : void 0,
                    "as-child": e.asChild,
                    as: e.as,
                    onClick: t[0] || (t[0] = e => {
                        var t;
                        null == (t = null == e ? void 0 : e.currentTarget) || t.focus()
                    }
                    ),
                    onPointerdown: t[1] || (t[1] = e => {
                        if ("touch" === e.pointerType)
                            return e.preventDefault();
                        const t = e.target;
                        t.hasPointerCapture(e.pointerId) && t.releasePointerCapture(e.pointerId),
                        0 === e.button && !1 === e.ctrlKey && (d(e),
                        e.preventDefault())
                    }
                    ),
                    onPointerup: t[2] || (t[2] = Yi(e => {
                        "touch" === e.pointerType && d(e)
                    }
                    , ["prevent"])),
                    onKeydown: t[3] || (t[3] = e => {
                        const t = "" !== Nt(i);
                        !(e.ctrlKey || e.altKey || e.metaKey) && 1 === e.key.length && t && " " === e.key || (Nt(l)(e.key, Nt(s)()),
                        Nt(Lp).includes(e.key) && (c(),
                        e.preventDefault()))
                    }
                    )
                }, {
                    default: En( () => [Wo(e.$slots, "default")]),
                    _: 3
                }, 8, ["type", "aria-controls", "aria-expanded", "aria-required", "disabled", "dir", "data-state", "data-disabled", "data-placeholder", "as-child", "as"])]
            }
            ),
            _: 3
        }, 8, ["reference"]))
    }
})
  , gf = to({
    __name: "SelectViewport",
    props: {
        nonce: {},
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = e
          , {nonce: n} = Ht(t)
          , o = function(e) {
            const t = $c({
                nonce: It()
            });
            return ms( () => {
                var n;
                return (null == e ? void 0 : e.value) || (null == (n = t.nonce) ? void 0 : n.value)
            }
            )
        }(n)
          , a = Yp()
          , r = "item-aligned" === a.position ? Zp() : void 0
          , {forwardRef: s, currentElement: i} = Uc();
        Mo( () => {
            null == a || a.onViewportChange(i.value)
        }
        );
        const l = It(0);
        function u(e) {
            const t = e.currentTarget
              , {shouldExpandOnScrollRef: n, contentWrapper: o} = r ?? {};
            if ((null == n ? void 0 : n.value) && (null == o ? void 0 : o.value)) {
                const e = Math.abs(l.value - t.scrollTop);
                if (e > 0) {
                    const n = window.innerHeight - 20
                      , a = Number.parseFloat(o.value.style.minHeight)
                      , r = Number.parseFloat(o.value.style.height)
                      , s = Math.max(a, r);
                    if (s < n) {
                        const a = s + e
                          , r = Math.min(n, a)
                          , i = a - r;
                        o.value.style.height = `${r}px`,
                        "0px" === o.value.style.bottom && (t.scrollTop = i > 0 ? i : 0,
                        o.value.style.justifyContent = "flex-end")
                    }
                }
            }
            l.value = t.scrollTop
        }
        return (e, n) => (Tr(),
        Br(_r, null, [jr(Nt(yc), Gr({
            ref: Nt(s),
            "data-reka-select-viewport": "",
            role: "presentation"
        }, {
            ...e.$attrs,
            ...t
        }, {
            style: {
                position: "relative",
                flex: 1,
                overflow: "hidden auto"
            },
            onScroll: u
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16), jr(Nt(yc), {
            as: "style",
            nonce: Nt(o)
        }, {
            default: En( () => n[0] || (n[0] = [Vr(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-select-viewport]::-webkit-scrollbar { display: none; } ")])),
            _: 1
        }, 8, ["nonce"])], 64))
    }
})
  , yf = to({
    __name: "BaseSeparator",
    props: {
        orientation: {
            default: "horizontal"
        },
        decorative: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = e
          , n = ["horizontal", "vertical"];
        const o = ms( () => {
            return e = t.orientation,
            n.includes(e) ? t.orientation : "horizontal";
            var e
        }
        )
          , a = ms( () => "vertical" === o.value ? t.orientation : void 0)
          , r = ms( () => t.decorative ? {
            role: "none"
        } : {
            "aria-orientation": a.value,
            role: "separator"
        });
        return (e, t) => (Tr(),
        Ir(Nt(yc), Gr({
            as: e.as,
            "as-child": e.asChild,
            "data-orientation": o.value
        }, r.value), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["as", "as-child", "data-orientation"]))
    }
})
  , bf = to({
    __name: "Separator",
    props: {
        orientation: {
            default: "horizontal"
        },
        decorative: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Ir(yf, Y(Fr(t)), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , wf = {
    "aria-live": "polite",
    "aria-atomic": "true",
    role: "status",
    style: {
        transform: "translateX(-100%)",
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
    }
}
  , [_f,xf] = Nc("StepperRoot")
  , kf = to({
    __name: "StepperRoot",
    props: {
        defaultValue: {
            default: 1
        },
        orientation: {
            default: "horizontal"
        },
        dir: {},
        modelValue: {},
        linear: {
            type: Boolean,
            default: !0
        },
        asChild: {
            type: Boolean
        },
        as: {}
    },
    emits: ["update:modelValue"],
    setup(e, {expose: t, emit: n}) {
        const o = e
          , a = n
          , {dir: r, orientation: s, linear: i} = Ht(o)
          , l = Hc(r)
          , u = It(new Set)
          , c = zc(o, "modelValue", a, {
            defaultValue: o.defaultValue,
            passive: void 0 === o.modelValue
        })
          , d = ms( () => Array.from(u.value))
          , p = ms( () => 1 === c.value)
          , f = ms( () => c.value === d.value.length)
          , h = ms( () => u.value.size);
        function v(e) {
            e > h.value || e < 1 || u.value.size && d.value[e] && d.value[e].getAttribute("disabled") || i.value && e > (c.value ?? 1) + 1 || (c.value = e)
        }
        function m() {
            v((c.value ?? 1) + 1)
        }
        function g() {
            v((c.value ?? 1) - 1)
        }
        function y() {
            return (c.value ?? 1) < h.value
        }
        function b() {
            return (c.value ?? 1) > 1
        }
        const w = It(null)
          , _ = It(null)
          , x = ms( () => !w.value || "" === w.value.getAttribute("disabled"))
          , k = ms( () => !_.value || "" === _.value.getAttribute("disabled"));
        return Qa(c, async () => {
            await fn( () => {
                w.value = d.value.length && c.value < d.value.length ? d.value[c.value] : null,
                _.value = d.value.length && c.value > 1 ? d.value[c.value - 2] : null
            }
            )
        }
        ),
        Qa(d, async () => {
            await fn( () => {
                w.value = d.value.length && c.value < d.value.length ? d.value[c.value] : null,
                _.value = d.value.length && c.value > 1 ? d.value[c.value - 2] : null
            }
            )
        }
        ),
        xf({
            modelValue: c,
            changeModelValue: e => {
                c.value = e
            }
            ,
            orientation: s,
            dir: l,
            linear: i,
            totalStepperItems: u
        }),
        t({
            goToStep: v,
            nextStep: m,
            prevStep: g,
            modelValue: c,
            totalSteps: h,
            isNextDisabled: x,
            isPrevDisabled: k,
            isFirstStep: p,
            isLastStep: f,
            hasNext: y,
            hasPrev: b
        }),
        Uc(),
        (e, t) => (Tr(),
        Ir(Nt(yc), {
            role: "group",
            "aria-label": "progress",
            as: e.as,
            "as-child": e.asChild,
            "data-linear": Nt(i) ? "" : void 0,
            "data-orientation": e.orientation
        }, {
            default: En( () => [Wo(e.$slots, "default", {
                modelValue: Nt(c),
                totalSteps: u.value.size,
                isNextDisabled: x.value,
                isPrevDisabled: k.value,
                isFirstStep: p.value,
                isLastStep: f.value,
                goToStep: v,
                nextStep: m,
                prevStep: g,
                hasNext: y,
                hasPrev: b
            }), Dr("div", wf, " Step " + ne(Nt(c)) + " of " + ne(u.value.size), 1)]),
            _: 3
        }, 8, ["as", "as-child", "data-linear", "data-orientation"]))
    }
})
  , [Sf,Cf] = Nc("StepperItem")
  , Ef = to({
    __name: "StepperItem",
    props: {
        step: {},
        disabled: {
            type: Boolean,
            default: !1
        },
        completed: {
            type: Boolean,
            default: !1
        },
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = e
          , {disabled: n, step: o, completed: a} = Ht(t)
          , {forwardRef: r} = Uc()
          , s = _f()
          , i = Kc(0, "reka-stepper-item-title")
          , l = Kc(0, "reka-stepper-item-description")
          , u = ms( () => a.value ? "completed" : s.modelValue.value === o.value ? "active" : s.modelValue.value > o.value ? "completed" : "inactive")
          , c = ms( () => !n.value && (!s.linear.value || (o.value <= s.modelValue.value || o.value === s.modelValue.value + 1)));
        return Cf({
            titleId: i,
            descriptionId: l,
            state: u,
            disabled: n,
            step: o,
            isFocusable: c
        }),
        (e, t) => (Tr(),
        Ir(Nt(yc), {
            ref: Nt(r),
            as: e.as,
            "as-child": e.asChild,
            "aria-current": "active" === u.value ? "true" : void 0,
            "data-state": u.value,
            disabled: Nt(n) || !c.value ? "" : void 0,
            "data-disabled": Nt(n) || !c.value ? "" : void 0,
            "data-orientation": Nt(s).orientation.value
        }, {
            default: En( () => [Wo(e.$slots, "default", {
                state: u.value
            })]),
            _: 3
        }, 8, ["as", "as-child", "aria-current", "data-state", "disabled", "data-disabled", "data-orientation"]))
    }
})
  , Tf = to({
    __name: "StepperDescription",
    props: {
        asChild: {
            type: Boolean
        },
        as: {
            default: "p"
        }
    },
    setup(e) {
        const t = e;
        Uc();
        const n = Sf();
        return (e, o) => (Tr(),
        Ir(Nt(yc), Gr(t, {
            id: Nt(n).descriptionId
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["id"]))
    }
})
  , Af = to({
    __name: "StepperSeparator",
    props: {
        orientation: {},
        decorative: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = e
          , n = _f()
          , o = Sf();
        return Uc(),
        (e, a) => (Tr(),
        Ir(Nt(bf), Gr(t, {
            decorative: "",
            orientation: Nt(n).orientation.value,
            "data-state": Nt(o).state.value
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["orientation", "data-state"]))
    }
})
  , Of = to({
    __name: "StepperTitle",
    props: {
        asChild: {
            type: Boolean
        },
        as: {
            default: "h4"
        }
    },
    setup(e) {
        const t = e
          , n = Sf();
        return Uc(),
        (e, o) => (Tr(),
        Ir(Nt(yc), Gr(t, {
            id: Nt(n).titleId
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["id"]))
    }
})
  , Mf = to({
    __name: "StepperTrigger",
    props: {
        asChild: {
            type: Boolean
        },
        as: {
            default: "button"
        }
    },
    setup(e) {
        const t = _f()
          , n = Sf()
          , o = {
            ALT: "Alt",
            ARROW_DOWN: "ArrowDown",
            ARROW_LEFT: "ArrowLeft",
            ARROW_RIGHT: "ArrowRight",
            ARROW_UP: "ArrowUp",
            BACKSPACE: "Backspace",
            CAPS_LOCK: "CapsLock",
            CONTROL: "Control",
            DELETE: "Delete",
            END: "End",
            ENTER: "Enter",
            ESCAPE: "Escape",
            F1: "F1",
            F10: "F10",
            F11: "F11",
            F12: "F12",
            F2: "F2",
            F3: "F3",
            F4: "F4",
            F5: "F5",
            F6: "F6",
            F7: "F7",
            F8: "F8",
            F9: "F9",
            HOME: "Home",
            META: "Meta",
            PAGE_DOWN: "PageDown",
            PAGE_UP: "PageUp",
            SHIFT: "Shift",
            SPACE: " ",
            TAB: "Tab",
            CTRL: "Control",
            ASTERISK: "*",
            SPACE_CODE: "Space"
        }
          , a = ms( () => Array.from(t.totalStepperItems.value));
        function r(e) {
            if (!n.disabled.value) {
                if (t.linear.value) {
                    if ((n.step.value <= t.modelValue.value || n.step.value === t.modelValue.value + 1) && !1 === e.ctrlKey)
                        return void t.changeModelValue(n.step.value)
                } else if (!1 === e.ctrlKey)
                    return void t.changeModelValue(n.step.value);
                e.preventDefault()
            }
        }
        function s(e) {
            e.preventDefault(),
            n.disabled.value || (e.key !== o.ENTER && e.key !== o.SPACE || e.ctrlKey || e.shiftKey || t.changeModelValue(n.step.value),
            [o.ARROW_LEFT, o.ARROW_RIGHT, o.ARROW_UP, o.ARROW_DOWN].includes(e.key) && qc(e, ad(), 0, {
                itemsArray: a.value,
                focus: !0,
                loop: !1,
                arrowKeyOptions: t.orientation.value,
                dir: t.dir.value
            }))
        }
        const {forwardRef: i, currentElement: l} = Uc();
        return Mo( () => {
            t.totalStepperItems.value.add(l.value)
        }
        ),
        Lo( () => {
            t.totalStepperItems.value.delete(l.value)
        }
        ),
        (e, o) => (Tr(),
        Ir(Nt(yc), {
            ref: Nt(i),
            type: "button" === e.as ? "button" : void 0,
            as: e.as,
            "as-child": e.asChild,
            "data-state": Nt(n).state.value,
            disabled: Nt(n).disabled.value || !Nt(n).isFocusable.value ? "" : void 0,
            "data-disabled": Nt(n).disabled.value || !Nt(n).isFocusable.value ? "" : void 0,
            "data-orientation": Nt(t).orientation.value,
            tabindex: Nt(n).isFocusable.value ? 0 : -1,
            "aria-describedby": Nt(n).descriptionId,
            "aria-labelledby": Nt(n).titleId,
            onMousedown: Yi(r, ["left"]),
            onKeydown: Ji(s, ["enter", "space", "left", "right", "up", "down"])
        }, {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 8, ["type", "as", "as-child", "data-state", "disabled", "data-disabled", "data-orientation", "tabindex", "aria-describedby", "aria-labelledby"]))
    }
})
  , Pf = to({
    __name: "Dialog",
    props: {
        open: {
            type: Boolean
        },
        defaultOpen: {
            type: Boolean
        },
        modal: {
            type: Boolean
        }
    },
    emits: ["update:open"],
    setup(e, {emit: t}) {
        const n = Zd(e, t);
        return (e, t) => (Tr(),
        Ir(Nt(td), Gr({
            "data-slot": "dialog"
        }, Nt(n)), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
});
const Bf = new WeakMap;
function If(e) {
    return Bt(t = ms(e)) ? bt(new Proxy({},{
        get: (e, n, o) => Nt(Reflect.get(t.value, n, o)),
        set: (e, n, o) => (Bt(t.value[n]) && !Bt(o) ? t.value[n].value = o : t.value[n] = o,
        !0),
        deleteProperty: (e, n) => Reflect.deleteProperty(t.value, n),
        has: (e, n) => Reflect.has(t.value, n),
        ownKeys: () => Object.keys(t.value),
        getOwnPropertyDescriptor: () => ({
            enumerable: !0,
            configurable: !0
        })
    })) : bt(t);
    var t
}
function Lf(e, ...t) {
    const n = t.flat()
      , o = n[0];
    return If( () => "function" == typeof o ? Object.fromEntries(Object.entries(Ht(e)).filter( ([e,t]) => !o(Dt(t), e))) : Object.fromEntries(Object.entries(Ht(e)).filter(e => !n.includes(e[0]))))
}
const Rf = "undefined" != typeof window && "undefined" != typeof document;
"undefined" != typeof WorkerGlobalScope && (globalThis,
WorkerGlobalScope);
const zf = Object.prototype.toString
  , Nf = () => {}
;
function Df(e) {
    return e.endsWith("rem") ? 16 * Number.parseFloat(e) : Number.parseFloat(e)
}
function jf(e) {
    return Array.isArray(e) ? e : [e]
}
const Ff = Rf ? window : void 0;
function $f(...e) {
    const t = []
      , n = () => {
        t.forEach(e => e()),
        t.length = 0
    }
      , o = ms( () => {
        const t = jf(Dt(e[0])).filter(e => null != e);
        return t.every(e => "string" != typeof e) ? t : void 0
    }
    )
      , a = (r = ([e,o,a,r]) => {
        if (n(),
        !(null == e ? void 0 : e.length) || !(null == o ? void 0 : o.length) || !(null == a ? void 0 : a.length))
            return;
        const s = (i = r,
        "[object Object]" === zf.call(i) ? {
            ...r
        } : r);
        var i;
        t.push(...e.flatMap(e => o.flatMap(t => a.map(n => ( (e, t, n, o) => (e.addEventListener(t, n, o),
        () => e.removeEventListener(t, n, o)))(e, t, n, s)))))
    }
    ,
    s = {
        flush: "post"
    },
    Qa( () => {
        var t, n;
        return [null != (n = null == (t = o.value) ? void 0 : t.map(e => function(e) {
            var t;
            const n = Dt(e);
            return null != (t = null == n ? void 0 : n.$el) ? t : n
        }(e))) ? n : [Ff].filter(e => null != e), jf(Dt(o.value ? e[1] : e[0])), jf(Nt(o.value ? e[2] : e[1])), Dt(o.value ? e[3] : e[2])]
    }
    , r, {
        ...s,
        immediate: !0
    }));
    var r, s;
    var i;
    return i = n,
    ue() && ce(i),
    () => {
        a(),
        n()
    }
}
function Vf(e) {
    const t = function() {
        const e = Lt(!1)
          , t = es();
        return t && Mo( () => {
            e.value = !0
        }
        , t),
        e
    }();
    return ms( () => (t.value,
    Boolean(e())))
}
const Hf = Symbol("vueuse-ssr-width");
function Uf() {
    const e = ka() ? ( (...e) => {
        var t;
        const n = e[0]
          , o = null == (t = es()) ? void 0 : t.proxy;
        if (null == o && !ka())
            throw new Error("injectLocal must be called in setup");
        return o && Bf.has(o) && n in Bf.get(o) ? Bf.get(o)[n] : xa(...e)
    }
    )(Hf, null) : null;
    return "number" == typeof e ? e : void 0
}
const Zf = {
    ctrl: "control",
    command: "meta",
    cmd: "meta",
    option: "alt",
    up: "arrowup",
    down: "arrowdown",
    left: "arrowleft",
    right: "arrowright"
};
function qf(e, t, n, o={}) {
    var a, r, s;
    const {clone: i=!1, passive: l=!1, eventName: u, deep: c=!1, defaultValue: d, shouldEmit: p} = o
      , f = es()
      , h = n || (null == f ? void 0 : f.emit) || (null == (a = null == f ? void 0 : f.$emit) ? void 0 : a.bind(f)) || (null == (s = null == (r = null == f ? void 0 : f.proxy) ? void 0 : r.$emit) ? void 0 : s.bind(null == f ? void 0 : f.proxy));
    let v = u;
    v = v || `update:${t.toString()}`;
    const m = e => {
        return i ? "function" == typeof i ? i(e) : (t = e,
        JSON.parse(JSON.stringify(t))) : e;
        var t
    }
      , g = () => void 0 !== e[t] ? m(e[t]) : d
      , y = e => {
        p ? p(e) && h(v, e) : h(v, e)
    }
    ;
    if (l) {
        const n = It(g());
        let o = !1;
        return Qa( () => e[t], e => {
            o || (o = !0,
            n.value = m(e),
            fn( () => o = !1))
        }
        ),
        Qa(n, n => {
            o || n === e[t] && !c || y(n)
        }
        , {
            deep: c
        }),
        n
    }
    return ms({
        get: () => g(),
        set(e) {
            y(e)
        }
    })
}
/**
 * @license lucide-vue-next v0.517.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Wf = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
  , Gf = e => {
    const t = (e => e.replace(/^([A-Z])|[\s-_]+(\w)/g, (e, t, n) => n ? n.toUpperCase() : t.toLowerCase()))(e);
    return t.charAt(0).toUpperCase() + t.slice(1)
}
  , Kf = (...e) => e.filter( (e, t, n) => Boolean(e) && "" !== e.trim() && n.indexOf(e) === t).join(" ").trim();
/**
 * @license lucide-vue-next v0.517.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Yf = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": 2,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
};
/**
 * @license lucide-vue-next v0.517.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Xf = ({size: e, strokeWidth: t=2, absoluteStrokeWidth: n, color: o, iconNode: a, name: r, class: s, ...i}, {slots: l}) => gs("svg", {
    ...Yf,
    width: e || Yf.width,
    height: e || Yf.height,
    stroke: o || Yf.stroke,
    "stroke-width": n ? 24 * Number(t) / Number(e) : t,
    class: Kf("lucide", ...r ? [`lucide-${Wf(Gf(r))}-icon`, `lucide-${Wf(r)}`] : ["lucide-icon"]),
    ...i
}, [...a.map(e => gs(...e)), ...l.default ? [l.default()] : []])
  , Jf = (e, t) => (n, {slots: o}) => gs(Xf, {
    ...n,
    iconNode: t,
    name: e
}, o)
  , Qf = Jf("book-user", [["path", {
    d: "M15 13a3 3 0 1 0-6 0",
    key: "10j68g"
}], ["path", {
    d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20",
    key: "k3hazp"
}], ["circle", {
    cx: "12",
    cy: "8",
    r: "2",
    key: "1822b1"
}]])
  , eh = Jf("check", [["path", {
    d: "M20 6 9 17l-5-5",
    key: "1gmf2c"
}]])
  , th = Jf("chevron-down", [["path", {
    d: "m6 9 6 6 6-6",
    key: "qrunsl"
}]])
  , nh = Jf("chevron-right", [["path", {
    d: "m9 18 6-6-6-6",
    key: "mthhwq"
}]])
  , oh = Jf("chevron-up", [["path", {
    d: "m18 15-6-6-6 6",
    key: "153udz"
}]])
  , ah = Jf("rocket", [["path", {
    d: "M4.5 16.5c-1.5 1.26-2 5-2 5s3.74-.5 5-2c.71-.84.7-2.13-.09-2.91a2.18 2.18 0 0 0-2.91-.09z",
    key: "m3kijz"
}], ["path", {
    d: "m12 15-3-3a22 22 0 0 1 2-3.95A12.88 12.88 0 0 1 22 2c0 2.72-.78 7.5-6 11a22.35 22.35 0 0 1-4 2z",
    key: "1fmvmk"
}], ["path", {
    d: "M9 12H4s.55-3.03 2-4c1.62-1.08 5 0 5 0",
    key: "1f8sc4"
}], ["path", {
    d: "M12 15v5s3.03-.55 4-2c1.08-1.62 0-5 0-5",
    key: "qeys4"
}]])
  , rh = Jf("x", [["path", {
    d: "M18 6 6 18",
    key: "1bl5f8"
}], ["path", {
    d: "m6 6 12 12",
    key: "d8bk6v"
}]]);
/**
 * @license lucide-vue-next v0.517.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
function sh(e) {
    var t, n, o = "";
    if ("string" == typeof e || "number" == typeof e)
        o += e;
    else if ("object" == typeof e)
        if (Array.isArray(e)) {
            var a = e.length;
            for (t = 0; t < a; t++)
                e[t] && (n = sh(e[t])) && (o && (o += " "),
                o += n)
        } else
            for (n in e)
                e[n] && (o && (o += " "),
                o += n);
    return o
}
function ih() {
    for (var e, t, n = 0, o = "", a = arguments.length; n < a; n++)
        (e = arguments[n]) && (t = sh(e)) && (o && (o += " "),
        o += t);
    return o
}
const lh = e => {
    const t = ph(e)
      , {conflictingClassGroups: n, conflictingClassGroupModifiers: o} = e;
    return {
        getClassGroupId: e => {
            const n = e.split("-");
            return "" === n[0] && 1 !== n.length && n.shift(),
            uh(n, t) || dh(e)
        }
        ,
        getConflictingClassGroupIds: (e, t) => {
            const a = n[e] || [];
            return t && o[e] ? [...a, ...o[e]] : a
        }
    }
}
  , uh = (e, t) => {
    var n;
    if (0 === e.length)
        return t.classGroupId;
    const o = e[0]
      , a = t.nextPart.get(o)
      , r = a ? uh(e.slice(1), a) : void 0;
    if (r)
        return r;
    if (0 === t.validators.length)
        return;
    const s = e.join("-");
    return null == (n = t.validators.find( ({validator: e}) => e(s))) ? void 0 : n.classGroupId
}
  , ch = /^\[(.+)\]$/
  , dh = e => {
    if (ch.test(e)) {
        const t = ch.exec(e)[1]
          , n = null == t ? void 0 : t.substring(0, t.indexOf(":"));
        if (n)
            return "arbitrary.." + n
    }
}
  , ph = e => {
    const {theme: t, classGroups: n} = e
      , o = {
        nextPart: new Map,
        validators: []
    };
    for (const a in n)
        fh(n[a], o, a, t);
    return o
}
  , fh = (e, t, n, o) => {
    e.forEach(e => {
        if ("string" == typeof e) {
            return void (("" === e ? t : hh(t, e)).classGroupId = n)
        }
        if ("function" == typeof e)
            return vh(e) ? void fh(e(o), t, n, o) : void t.validators.push({
                validator: e,
                classGroupId: n
            });
        Object.entries(e).forEach( ([e,a]) => {
            fh(a, hh(t, e), n, o)
        }
        )
    }
    )
}
  , hh = (e, t) => {
    let n = e;
    return t.split("-").forEach(e => {
        n.nextPart.has(e) || n.nextPart.set(e, {
            nextPart: new Map,
            validators: []
        }),
        n = n.nextPart.get(e)
    }
    ),
    n
}
  , vh = e => e.isThemeGetter
  , mh = e => {
    if (e < 1)
        return {
            get: () => {}
            ,
            set: () => {}
        };
    let t = 0
      , n = new Map
      , o = new Map;
    const a = (a, r) => {
        n.set(a, r),
        t++,
        t > e && (t = 0,
        o = n,
        n = new Map)
    }
    ;
    return {
        get(e) {
            let t = n.get(e);
            return void 0 !== t ? t : void 0 !== (t = o.get(e)) ? (a(e, t),
            t) : void 0
        },
        set(e, t) {
            n.has(e) ? n.set(e, t) : a(e, t)
        }
    }
}
  , gh = e => {
    const {prefix: t, experimentalParseClassName: n} = e;
    let o = e => {
        const t = [];
        let n, o = 0, a = 0, r = 0;
        for (let l = 0; l < e.length; l++) {
            let s = e[l];
            if (0 === o && 0 === a) {
                if (":" === s) {
                    t.push(e.slice(r, l)),
                    r = l + 1;
                    continue
                }
                if ("/" === s) {
                    n = l;
                    continue
                }
            }
            "[" === s ? o++ : "]" === s ? o-- : "(" === s ? a++ : ")" === s && a--
        }
        const s = 0 === t.length ? e : e.substring(r)
          , i = yh(s);
        return {
            modifiers: t,
            hasImportantModifier: i !== s,
            baseClassName: i,
            maybePostfixModifierPosition: n && n > r ? n - r : void 0
        }
    }
    ;
    if (t) {
        const e = t + ":"
          , n = o;
        o = t => t.startsWith(e) ? n(t.substring(e.length)) : {
            isExternal: !0,
            modifiers: [],
            hasImportantModifier: !1,
            baseClassName: t,
            maybePostfixModifierPosition: void 0
        }
    }
    if (n) {
        const e = o;
        o = t => n({
            className: t,
            parseClassName: e
        })
    }
    return o
}
  , yh = e => e.endsWith("!") ? e.substring(0, e.length - 1) : e.startsWith("!") ? e.substring(1) : e
  , bh = e => {
    const t = Object.fromEntries(e.orderSensitiveModifiers.map(e => [e, !0]));
    return e => {
        if (e.length <= 1)
            return e;
        const n = [];
        let o = [];
        return e.forEach(e => {
            "[" === e[0] || t[e] ? (n.push(...o.sort(), e),
            o = []) : o.push(e)
        }
        ),
        n.push(...o.sort()),
        n
    }
}
  , wh = /\s+/;
function _h() {
    let e, t, n = 0, o = "";
    for (; n < arguments.length; )
        (e = arguments[n++]) && (t = xh(e)) && (o && (o += " "),
        o += t);
    return o
}
const xh = e => {
    if ("string" == typeof e)
        return e;
    let t, n = "";
    for (let o = 0; o < e.length; o++)
        e[o] && (t = xh(e[o])) && (n && (n += " "),
        n += t);
    return n
}
;
function kh(e, ...t) {
    let n, o, a, r = function(i) {
        const l = t.reduce( (e, t) => t(e), e());
        return n = (e => ({
            cache: mh(e.cacheSize),
            parseClassName: gh(e),
            sortModifiers: bh(e),
            ...lh(e)
        }))(l),
        o = n.cache.get,
        a = n.cache.set,
        r = s,
        s(i)
    };
    function s(e) {
        const t = o(e);
        if (t)
            return t;
        const r = ( (e, t) => {
            const {parseClassName: n, getClassGroupId: o, getConflictingClassGroupIds: a, sortModifiers: r} = t
              , s = []
              , i = e.trim().split(wh);
            let l = "";
            for (let u = i.length - 1; u >= 0; u -= 1) {
                const e = i[u]
                  , {isExternal: t, modifiers: c, hasImportantModifier: d, baseClassName: p, maybePostfixModifierPosition: f} = n(e);
                if (t) {
                    l = e + (l.length > 0 ? " " + l : l);
                    continue
                }
                let h = !!f
                  , v = o(h ? p.substring(0, f) : p);
                if (!v) {
                    if (!h) {
                        l = e + (l.length > 0 ? " " + l : l);
                        continue
                    }
                    if (v = o(p),
                    !v) {
                        l = e + (l.length > 0 ? " " + l : l);
                        continue
                    }
                    h = !1
                }
                const m = r(c).join(":")
                  , g = d ? m + "!" : m
                  , y = g + v;
                if (s.includes(y))
                    continue;
                s.push(y);
                const b = a(v, h);
                for (let n = 0; n < b.length; ++n) {
                    const e = b[n];
                    s.push(g + e)
                }
                l = e + (l.length > 0 ? " " + l : l)
            }
            return l
        }
        )(e, n);
        return a(e, r),
        r
    }
    return function() {
        return r(_h.apply(null, arguments))
    }
}
const Sh = e => {
    const t = t => t[e] || [];
    return t.isThemeGetter = !0,
    t
}
  , Ch = /^\[(?:(\w[\w-]*):)?(.+)\]$/i
  , Eh = /^\((?:(\w[\w-]*):)?(.+)\)$/i
  , Th = /^\d+\/\d+$/
  , Ah = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/
  , Oh = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/
  , Mh = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/
  , Ph = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
  , Bh = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/
  , Ih = e => Th.test(e)
  , Lh = e => !!e && !Number.isNaN(Number(e))
  , Rh = e => !!e && Number.isInteger(Number(e))
  , zh = e => e.endsWith("%") && Lh(e.slice(0, -1))
  , Nh = e => Ah.test(e)
  , Dh = () => !0
  , jh = e => Oh.test(e) && !Mh.test(e)
  , Fh = () => !1
  , $h = e => Ph.test(e)
  , Vh = e => Bh.test(e)
  , Hh = e => !Zh(e) && !Xh(e)
  , Uh = e => av(e, lv, Fh)
  , Zh = e => Ch.test(e)
  , qh = e => av(e, uv, jh)
  , Wh = e => av(e, cv, Lh)
  , Gh = e => av(e, sv, Fh)
  , Kh = e => av(e, iv, Vh)
  , Yh = e => av(e, pv, $h)
  , Xh = e => Eh.test(e)
  , Jh = e => rv(e, uv)
  , Qh = e => rv(e, dv)
  , ev = e => rv(e, sv)
  , tv = e => rv(e, lv)
  , nv = e => rv(e, iv)
  , ov = e => rv(e, pv, !0)
  , av = (e, t, n) => {
    const o = Ch.exec(e);
    return !!o && (o[1] ? t(o[1]) : n(o[2]))
}
  , rv = (e, t, n=!1) => {
    const o = Eh.exec(e);
    return !!o && (o[1] ? t(o[1]) : n)
}
  , sv = e => "position" === e || "percentage" === e
  , iv = e => "image" === e || "url" === e
  , lv = e => "length" === e || "size" === e || "bg-size" === e
  , uv = e => "length" === e
  , cv = e => "number" === e
  , dv = e => "family-name" === e
  , pv = e => "shadow" === e
  , fv = kh( () => {
    const e = Sh("color")
      , t = Sh("font")
      , n = Sh("text")
      , o = Sh("font-weight")
      , a = Sh("tracking")
      , r = Sh("leading")
      , s = Sh("breakpoint")
      , i = Sh("container")
      , l = Sh("spacing")
      , u = Sh("radius")
      , c = Sh("shadow")
      , d = Sh("inset-shadow")
      , p = Sh("text-shadow")
      , f = Sh("drop-shadow")
      , h = Sh("blur")
      , v = Sh("perspective")
      , m = Sh("aspect")
      , g = Sh("ease")
      , y = Sh("animate")
      , b = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom", Xh, Zh]
      , w = () => [Xh, Zh, l]
      , _ = () => [Ih, "full", "auto", ...w()]
      , x = () => [Rh, "none", "subgrid", Xh, Zh]
      , k = () => ["auto", {
        span: ["full", Rh, Xh, Zh]
    }, Rh, Xh, Zh]
      , S = () => [Rh, "auto", Xh, Zh]
      , C = () => ["auto", "min", "max", "fr", Xh, Zh]
      , E = () => ["auto", ...w()]
      , T = () => [Ih, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...w()]
      , A = () => [e, Xh, Zh]
      , O = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom", ev, Gh, {
        position: [Xh, Zh]
    }]
      , M = () => ["auto", "cover", "contain", tv, Uh, {
        size: [Xh, Zh]
    }]
      , P = () => [zh, Jh, qh]
      , B = () => ["", "none", "full", u, Xh, Zh]
      , I = () => ["", Lh, Jh, qh]
      , L = () => [Lh, zh, ev, Gh]
      , R = () => ["", "none", h, Xh, Zh]
      , z = () => ["none", Lh, Xh, Zh]
      , N = () => ["none", Lh, Xh, Zh]
      , D = () => [Lh, Xh, Zh]
      , j = () => [Ih, "full", ...w()];
    return {
        cacheSize: 500,
        theme: {
            animate: ["spin", "ping", "pulse", "bounce"],
            aspect: ["video"],
            blur: [Nh],
            breakpoint: [Nh],
            color: [Dh],
            container: [Nh],
            "drop-shadow": [Nh],
            ease: ["in", "out", "in-out"],
            font: [Hh],
            "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
            "inset-shadow": [Nh],
            leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
            perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
            radius: [Nh],
            shadow: [Nh],
            spacing: ["px", Lh],
            text: [Nh],
            "text-shadow": [Nh],
            tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
        },
        classGroups: {
            aspect: [{
                aspect: ["auto", "square", Ih, Zh, Xh, m]
            }],
            container: ["container"],
            columns: [{
                columns: [Lh, Zh, Xh, i]
            }],
            "break-after": [{
                "break-after": ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
            }],
            "break-before": [{
                "break-before": ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
            }],
            "break-inside": [{
                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
            }],
            "box-decoration": [{
                "box-decoration": ["slice", "clone"]
            }],
            box: [{
                box: ["border", "content"]
            }],
            display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
            sr: ["sr-only", "not-sr-only"],
            float: [{
                float: ["right", "left", "none", "start", "end"]
            }],
            clear: [{
                clear: ["left", "right", "both", "none", "start", "end"]
            }],
            isolation: ["isolate", "isolation-auto"],
            "object-fit": [{
                object: ["contain", "cover", "fill", "none", "scale-down"]
            }],
            "object-position": [{
                object: b()
            }],
            overflow: [{
                overflow: ["auto", "hidden", "clip", "visible", "scroll"]
            }],
            "overflow-x": [{
                "overflow-x": ["auto", "hidden", "clip", "visible", "scroll"]
            }],
            "overflow-y": [{
                "overflow-y": ["auto", "hidden", "clip", "visible", "scroll"]
            }],
            overscroll: [{
                overscroll: ["auto", "contain", "none"]
            }],
            "overscroll-x": [{
                "overscroll-x": ["auto", "contain", "none"]
            }],
            "overscroll-y": [{
                "overscroll-y": ["auto", "contain", "none"]
            }],
            position: ["static", "fixed", "absolute", "relative", "sticky"],
            inset: [{
                inset: _()
            }],
            "inset-x": [{
                "inset-x": _()
            }],
            "inset-y": [{
                "inset-y": _()
            }],
            start: [{
                start: _()
            }],
            end: [{
                end: _()
            }],
            top: [{
                top: _()
            }],
            right: [{
                right: _()
            }],
            bottom: [{
                bottom: _()
            }],
            left: [{
                left: _()
            }],
            visibility: ["visible", "invisible", "collapse"],
            z: [{
                z: [Rh, "auto", Xh, Zh]
            }],
            basis: [{
                basis: [Ih, "full", "auto", i, ...w()]
            }],
            "flex-direction": [{
                flex: ["row", "row-reverse", "col", "col-reverse"]
            }],
            "flex-wrap": [{
                flex: ["nowrap", "wrap", "wrap-reverse"]
            }],
            flex: [{
                flex: [Lh, Ih, "auto", "initial", "none", Zh]
            }],
            grow: [{
                grow: ["", Lh, Xh, Zh]
            }],
            shrink: [{
                shrink: ["", Lh, Xh, Zh]
            }],
            order: [{
                order: [Rh, "first", "last", "none", Xh, Zh]
            }],
            "grid-cols": [{
                "grid-cols": x()
            }],
            "col-start-end": [{
                col: k()
            }],
            "col-start": [{
                "col-start": S()
            }],
            "col-end": [{
                "col-end": S()
            }],
            "grid-rows": [{
                "grid-rows": x()
            }],
            "row-start-end": [{
                row: k()
            }],
            "row-start": [{
                "row-start": S()
            }],
            "row-end": [{
                "row-end": S()
            }],
            "grid-flow": [{
                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
            }],
            "auto-cols": [{
                "auto-cols": C()
            }],
            "auto-rows": [{
                "auto-rows": C()
            }],
            gap: [{
                gap: w()
            }],
            "gap-x": [{
                "gap-x": w()
            }],
            "gap-y": [{
                "gap-y": w()
            }],
            "justify-content": [{
                justify: ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe", "normal"]
            }],
            "justify-items": [{
                "justify-items": ["start", "end", "center", "stretch", "center-safe", "end-safe", "normal"]
            }],
            "justify-self": [{
                "justify-self": ["auto", "start", "end", "center", "stretch", "center-safe", "end-safe"]
            }],
            "align-content": [{
                content: ["normal", "start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"]
            }],
            "align-items": [{
                items: ["start", "end", "center", "stretch", "center-safe", "end-safe", {
                    baseline: ["", "last"]
                }]
            }],
            "align-self": [{
                self: ["auto", "start", "end", "center", "stretch", "center-safe", "end-safe", {
                    baseline: ["", "last"]
                }]
            }],
            "place-content": [{
                "place-content": ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"]
            }],
            "place-items": [{
                "place-items": ["start", "end", "center", "stretch", "center-safe", "end-safe", "baseline"]
            }],
            "place-self": [{
                "place-self": ["auto", "start", "end", "center", "stretch", "center-safe", "end-safe"]
            }],
            p: [{
                p: w()
            }],
            px: [{
                px: w()
            }],
            py: [{
                py: w()
            }],
            ps: [{
                ps: w()
            }],
            pe: [{
                pe: w()
            }],
            pt: [{
                pt: w()
            }],
            pr: [{
                pr: w()
            }],
            pb: [{
                pb: w()
            }],
            pl: [{
                pl: w()
            }],
            m: [{
                m: E()
            }],
            mx: [{
                mx: E()
            }],
            my: [{
                my: E()
            }],
            ms: [{
                ms: E()
            }],
            me: [{
                me: E()
            }],
            mt: [{
                mt: E()
            }],
            mr: [{
                mr: E()
            }],
            mb: [{
                mb: E()
            }],
            ml: [{
                ml: E()
            }],
            "space-x": [{
                "space-x": w()
            }],
            "space-x-reverse": ["space-x-reverse"],
            "space-y": [{
                "space-y": w()
            }],
            "space-y-reverse": ["space-y-reverse"],
            size: [{
                size: T()
            }],
            w: [{
                w: [i, "screen", ...T()]
            }],
            "min-w": [{
                "min-w": [i, "screen", "none", ...T()]
            }],
            "max-w": [{
                "max-w": [i, "screen", "none", "prose", {
                    screen: [s]
                }, ...T()]
            }],
            h: [{
                h: ["screen", "lh", ...T()]
            }],
            "min-h": [{
                "min-h": ["screen", "lh", "none", ...T()]
            }],
            "max-h": [{
                "max-h": ["screen", "lh", ...T()]
            }],
            "font-size": [{
                text: ["base", n, Jh, qh]
            }],
            "font-smoothing": ["antialiased", "subpixel-antialiased"],
            "font-style": ["italic", "not-italic"],
            "font-weight": [{
                font: [o, Xh, Wh]
            }],
            "font-stretch": [{
                "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", zh, Zh]
            }],
            "font-family": [{
                font: [Qh, Zh, t]
            }],
            "fvn-normal": ["normal-nums"],
            "fvn-ordinal": ["ordinal"],
            "fvn-slashed-zero": ["slashed-zero"],
            "fvn-figure": ["lining-nums", "oldstyle-nums"],
            "fvn-spacing": ["proportional-nums", "tabular-nums"],
            "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
            tracking: [{
                tracking: [a, Xh, Zh]
            }],
            "line-clamp": [{
                "line-clamp": [Lh, "none", Xh, Wh]
            }],
            leading: [{
                leading: [r, ...w()]
            }],
            "list-image": [{
                "list-image": ["none", Xh, Zh]
            }],
            "list-style-position": [{
                list: ["inside", "outside"]
            }],
            "list-style-type": [{
                list: ["disc", "decimal", "none", Xh, Zh]
            }],
            "text-alignment": [{
                text: ["left", "center", "right", "justify", "start", "end"]
            }],
            "placeholder-color": [{
                placeholder: A()
            }],
            "text-color": [{
                text: A()
            }],
            "text-decoration": ["underline", "overline", "line-through", "no-underline"],
            "text-decoration-style": [{
                decoration: ["solid", "dashed", "dotted", "double", "wavy"]
            }],
            "text-decoration-thickness": [{
                decoration: [Lh, "from-font", "auto", Xh, qh]
            }],
            "text-decoration-color": [{
                decoration: A()
            }],
            "underline-offset": [{
                "underline-offset": [Lh, "auto", Xh, Zh]
            }],
            "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
            "text-wrap": [{
                text: ["wrap", "nowrap", "balance", "pretty"]
            }],
            indent: [{
                indent: w()
            }],
            "vertical-align": [{
                align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Xh, Zh]
            }],
            whitespace: [{
                whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
            }],
            break: [{
                break: ["normal", "words", "all", "keep"]
            }],
            wrap: [{
                wrap: ["break-word", "anywhere", "normal"]
            }],
            hyphens: [{
                hyphens: ["none", "manual", "auto"]
            }],
            content: [{
                content: ["none", Xh, Zh]
            }],
            "bg-attachment": [{
                bg: ["fixed", "local", "scroll"]
            }],
            "bg-clip": [{
                "bg-clip": ["border", "padding", "content", "text"]
            }],
            "bg-origin": [{
                "bg-origin": ["border", "padding", "content"]
            }],
            "bg-position": [{
                bg: O()
            }],
            "bg-repeat": [{
                bg: ["no-repeat", {
                    repeat: ["", "x", "y", "space", "round"]
                }]
            }],
            "bg-size": [{
                bg: M()
            }],
            "bg-image": [{
                bg: ["none", {
                    linear: [{
                        to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                    }, Rh, Xh, Zh],
                    radial: ["", Xh, Zh],
                    conic: [Rh, Xh, Zh]
                }, nv, Kh]
            }],
            "bg-color": [{
                bg: A()
            }],
            "gradient-from-pos": [{
                from: P()
            }],
            "gradient-via-pos": [{
                via: P()
            }],
            "gradient-to-pos": [{
                to: P()
            }],
            "gradient-from": [{
                from: A()
            }],
            "gradient-via": [{
                via: A()
            }],
            "gradient-to": [{
                to: A()
            }],
            rounded: [{
                rounded: B()
            }],
            "rounded-s": [{
                "rounded-s": B()
            }],
            "rounded-e": [{
                "rounded-e": B()
            }],
            "rounded-t": [{
                "rounded-t": B()
            }],
            "rounded-r": [{
                "rounded-r": B()
            }],
            "rounded-b": [{
                "rounded-b": B()
            }],
            "rounded-l": [{
                "rounded-l": B()
            }],
            "rounded-ss": [{
                "rounded-ss": B()
            }],
            "rounded-se": [{
                "rounded-se": B()
            }],
            "rounded-ee": [{
                "rounded-ee": B()
            }],
            "rounded-es": [{
                "rounded-es": B()
            }],
            "rounded-tl": [{
                "rounded-tl": B()
            }],
            "rounded-tr": [{
                "rounded-tr": B()
            }],
            "rounded-br": [{
                "rounded-br": B()
            }],
            "rounded-bl": [{
                "rounded-bl": B()
            }],
            "border-w": [{
                border: I()
            }],
            "border-w-x": [{
                "border-x": I()
            }],
            "border-w-y": [{
                "border-y": I()
            }],
            "border-w-s": [{
                "border-s": I()
            }],
            "border-w-e": [{
                "border-e": I()
            }],
            "border-w-t": [{
                "border-t": I()
            }],
            "border-w-r": [{
                "border-r": I()
            }],
            "border-w-b": [{
                "border-b": I()
            }],
            "border-w-l": [{
                "border-l": I()
            }],
            "divide-x": [{
                "divide-x": I()
            }],
            "divide-x-reverse": ["divide-x-reverse"],
            "divide-y": [{
                "divide-y": I()
            }],
            "divide-y-reverse": ["divide-y-reverse"],
            "border-style": [{
                border: ["solid", "dashed", "dotted", "double", "hidden", "none"]
            }],
            "divide-style": [{
                divide: ["solid", "dashed", "dotted", "double", "hidden", "none"]
            }],
            "border-color": [{
                border: A()
            }],
            "border-color-x": [{
                "border-x": A()
            }],
            "border-color-y": [{
                "border-y": A()
            }],
            "border-color-s": [{
                "border-s": A()
            }],
            "border-color-e": [{
                "border-e": A()
            }],
            "border-color-t": [{
                "border-t": A()
            }],
            "border-color-r": [{
                "border-r": A()
            }],
            "border-color-b": [{
                "border-b": A()
            }],
            "border-color-l": [{
                "border-l": A()
            }],
            "divide-color": [{
                divide: A()
            }],
            "outline-style": [{
                outline: ["solid", "dashed", "dotted", "double", "none", "hidden"]
            }],
            "outline-offset": [{
                "outline-offset": [Lh, Xh, Zh]
            }],
            "outline-w": [{
                outline: ["", Lh, Jh, qh]
            }],
            "outline-color": [{
                outline: A()
            }],
            shadow: [{
                shadow: ["", "none", c, ov, Yh]
            }],
            "shadow-color": [{
                shadow: A()
            }],
            "inset-shadow": [{
                "inset-shadow": ["none", d, ov, Yh]
            }],
            "inset-shadow-color": [{
                "inset-shadow": A()
            }],
            "ring-w": [{
                ring: I()
            }],
            "ring-w-inset": ["ring-inset"],
            "ring-color": [{
                ring: A()
            }],
            "ring-offset-w": [{
                "ring-offset": [Lh, qh]
            }],
            "ring-offset-color": [{
                "ring-offset": A()
            }],
            "inset-ring-w": [{
                "inset-ring": I()
            }],
            "inset-ring-color": [{
                "inset-ring": A()
            }],
            "text-shadow": [{
                "text-shadow": ["none", p, ov, Yh]
            }],
            "text-shadow-color": [{
                "text-shadow": A()
            }],
            opacity: [{
                opacity: [Lh, Xh, Zh]
            }],
            "mix-blend": [{
                "mix-blend": ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-darker", "plus-lighter"]
            }],
            "bg-blend": [{
                "bg-blend": ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
            }],
            "mask-clip": [{
                "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
            }, "mask-no-clip"],
            "mask-composite": [{
                mask: ["add", "subtract", "intersect", "exclude"]
            }],
            "mask-image-linear-pos": [{
                "mask-linear": [Lh]
            }],
            "mask-image-linear-from-pos": [{
                "mask-linear-from": L()
            }],
            "mask-image-linear-to-pos": [{
                "mask-linear-to": L()
            }],
            "mask-image-linear-from-color": [{
                "mask-linear-from": A()
            }],
            "mask-image-linear-to-color": [{
                "mask-linear-to": A()
            }],
            "mask-image-t-from-pos": [{
                "mask-t-from": L()
            }],
            "mask-image-t-to-pos": [{
                "mask-t-to": L()
            }],
            "mask-image-t-from-color": [{
                "mask-t-from": A()
            }],
            "mask-image-t-to-color": [{
                "mask-t-to": A()
            }],
            "mask-image-r-from-pos": [{
                "mask-r-from": L()
            }],
            "mask-image-r-to-pos": [{
                "mask-r-to": L()
            }],
            "mask-image-r-from-color": [{
                "mask-r-from": A()
            }],
            "mask-image-r-to-color": [{
                "mask-r-to": A()
            }],
            "mask-image-b-from-pos": [{
                "mask-b-from": L()
            }],
            "mask-image-b-to-pos": [{
                "mask-b-to": L()
            }],
            "mask-image-b-from-color": [{
                "mask-b-from": A()
            }],
            "mask-image-b-to-color": [{
                "mask-b-to": A()
            }],
            "mask-image-l-from-pos": [{
                "mask-l-from": L()
            }],
            "mask-image-l-to-pos": [{
                "mask-l-to": L()
            }],
            "mask-image-l-from-color": [{
                "mask-l-from": A()
            }],
            "mask-image-l-to-color": [{
                "mask-l-to": A()
            }],
            "mask-image-x-from-pos": [{
                "mask-x-from": L()
            }],
            "mask-image-x-to-pos": [{
                "mask-x-to": L()
            }],
            "mask-image-x-from-color": [{
                "mask-x-from": A()
            }],
            "mask-image-x-to-color": [{
                "mask-x-to": A()
            }],
            "mask-image-y-from-pos": [{
                "mask-y-from": L()
            }],
            "mask-image-y-to-pos": [{
                "mask-y-to": L()
            }],
            "mask-image-y-from-color": [{
                "mask-y-from": A()
            }],
            "mask-image-y-to-color": [{
                "mask-y-to": A()
            }],
            "mask-image-radial": [{
                "mask-radial": [Xh, Zh]
            }],
            "mask-image-radial-from-pos": [{
                "mask-radial-from": L()
            }],
            "mask-image-radial-to-pos": [{
                "mask-radial-to": L()
            }],
            "mask-image-radial-from-color": [{
                "mask-radial-from": A()
            }],
            "mask-image-radial-to-color": [{
                "mask-radial-to": A()
            }],
            "mask-image-radial-shape": [{
                "mask-radial": ["circle", "ellipse"]
            }],
            "mask-image-radial-size": [{
                "mask-radial": [{
                    closest: ["side", "corner"],
                    farthest: ["side", "corner"]
                }]
            }],
            "mask-image-radial-pos": [{
                "mask-radial-at": ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"]
            }],
            "mask-image-conic-pos": [{
                "mask-conic": [Lh]
            }],
            "mask-image-conic-from-pos": [{
                "mask-conic-from": L()
            }],
            "mask-image-conic-to-pos": [{
                "mask-conic-to": L()
            }],
            "mask-image-conic-from-color": [{
                "mask-conic-from": A()
            }],
            "mask-image-conic-to-color": [{
                "mask-conic-to": A()
            }],
            "mask-mode": [{
                mask: ["alpha", "luminance", "match"]
            }],
            "mask-origin": [{
                "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
            }],
            "mask-position": [{
                mask: O()
            }],
            "mask-repeat": [{
                mask: ["no-repeat", {
                    repeat: ["", "x", "y", "space", "round"]
                }]
            }],
            "mask-size": [{
                mask: M()
            }],
            "mask-type": [{
                "mask-type": ["alpha", "luminance"]
            }],
            "mask-image": [{
                mask: ["none", Xh, Zh]
            }],
            filter: [{
                filter: ["", "none", Xh, Zh]
            }],
            blur: [{
                blur: R()
            }],
            brightness: [{
                brightness: [Lh, Xh, Zh]
            }],
            contrast: [{
                contrast: [Lh, Xh, Zh]
            }],
            "drop-shadow": [{
                "drop-shadow": ["", "none", f, ov, Yh]
            }],
            "drop-shadow-color": [{
                "drop-shadow": A()
            }],
            grayscale: [{
                grayscale: ["", Lh, Xh, Zh]
            }],
            "hue-rotate": [{
                "hue-rotate": [Lh, Xh, Zh]
            }],
            invert: [{
                invert: ["", Lh, Xh, Zh]
            }],
            saturate: [{
                saturate: [Lh, Xh, Zh]
            }],
            sepia: [{
                sepia: ["", Lh, Xh, Zh]
            }],
            "backdrop-filter": [{
                "backdrop-filter": ["", "none", Xh, Zh]
            }],
            "backdrop-blur": [{
                "backdrop-blur": R()
            }],
            "backdrop-brightness": [{
                "backdrop-brightness": [Lh, Xh, Zh]
            }],
            "backdrop-contrast": [{
                "backdrop-contrast": [Lh, Xh, Zh]
            }],
            "backdrop-grayscale": [{
                "backdrop-grayscale": ["", Lh, Xh, Zh]
            }],
            "backdrop-hue-rotate": [{
                "backdrop-hue-rotate": [Lh, Xh, Zh]
            }],
            "backdrop-invert": [{
                "backdrop-invert": ["", Lh, Xh, Zh]
            }],
            "backdrop-opacity": [{
                "backdrop-opacity": [Lh, Xh, Zh]
            }],
            "backdrop-saturate": [{
                "backdrop-saturate": [Lh, Xh, Zh]
            }],
            "backdrop-sepia": [{
                "backdrop-sepia": ["", Lh, Xh, Zh]
            }],
            "border-collapse": [{
                border: ["collapse", "separate"]
            }],
            "border-spacing": [{
                "border-spacing": w()
            }],
            "border-spacing-x": [{
                "border-spacing-x": w()
            }],
            "border-spacing-y": [{
                "border-spacing-y": w()
            }],
            "table-layout": [{
                table: ["auto", "fixed"]
            }],
            caption: [{
                caption: ["top", "bottom"]
            }],
            transition: [{
                transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", Xh, Zh]
            }],
            "transition-behavior": [{
                transition: ["normal", "discrete"]
            }],
            duration: [{
                duration: [Lh, "initial", Xh, Zh]
            }],
            ease: [{
                ease: ["linear", "initial", g, Xh, Zh]
            }],
            delay: [{
                delay: [Lh, Xh, Zh]
            }],
            animate: [{
                animate: ["none", y, Xh, Zh]
            }],
            backface: [{
                backface: ["hidden", "visible"]
            }],
            perspective: [{
                perspective: [v, Xh, Zh]
            }],
            "perspective-origin": [{
                "perspective-origin": b()
            }],
            rotate: [{
                rotate: z()
            }],
            "rotate-x": [{
                "rotate-x": z()
            }],
            "rotate-y": [{
                "rotate-y": z()
            }],
            "rotate-z": [{
                "rotate-z": z()
            }],
            scale: [{
                scale: N()
            }],
            "scale-x": [{
                "scale-x": N()
            }],
            "scale-y": [{
                "scale-y": N()
            }],
            "scale-z": [{
                "scale-z": N()
            }],
            "scale-3d": ["scale-3d"],
            skew: [{
                skew: D()
            }],
            "skew-x": [{
                "skew-x": D()
            }],
            "skew-y": [{
                "skew-y": D()
            }],
            transform: [{
                transform: [Xh, Zh, "", "none", "gpu", "cpu"]
            }],
            "transform-origin": [{
                origin: b()
            }],
            "transform-style": [{
                transform: ["3d", "flat"]
            }],
            translate: [{
                translate: j()
            }],
            "translate-x": [{
                "translate-x": j()
            }],
            "translate-y": [{
                "translate-y": j()
            }],
            "translate-z": [{
                "translate-z": j()
            }],
            "translate-none": ["translate-none"],
            accent: [{
                accent: A()
            }],
            appearance: [{
                appearance: ["none", "auto"]
            }],
            "caret-color": [{
                caret: A()
            }],
            "color-scheme": [{
                scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
            }],
            cursor: [{
                cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Xh, Zh]
            }],
            "field-sizing": [{
                "field-sizing": ["fixed", "content"]
            }],
            "pointer-events": [{
                "pointer-events": ["auto", "none"]
            }],
            resize: [{
                resize: ["none", "", "y", "x"]
            }],
            "scroll-behavior": [{
                scroll: ["auto", "smooth"]
            }],
            "scroll-m": [{
                "scroll-m": w()
            }],
            "scroll-mx": [{
                "scroll-mx": w()
            }],
            "scroll-my": [{
                "scroll-my": w()
            }],
            "scroll-ms": [{
                "scroll-ms": w()
            }],
            "scroll-me": [{
                "scroll-me": w()
            }],
            "scroll-mt": [{
                "scroll-mt": w()
            }],
            "scroll-mr": [{
                "scroll-mr": w()
            }],
            "scroll-mb": [{
                "scroll-mb": w()
            }],
            "scroll-ml": [{
                "scroll-ml": w()
            }],
            "scroll-p": [{
                "scroll-p": w()
            }],
            "scroll-px": [{
                "scroll-px": w()
            }],
            "scroll-py": [{
                "scroll-py": w()
            }],
            "scroll-ps": [{
                "scroll-ps": w()
            }],
            "scroll-pe": [{
                "scroll-pe": w()
            }],
            "scroll-pt": [{
                "scroll-pt": w()
            }],
            "scroll-pr": [{
                "scroll-pr": w()
            }],
            "scroll-pb": [{
                "scroll-pb": w()
            }],
            "scroll-pl": [{
                "scroll-pl": w()
            }],
            "snap-align": [{
                snap: ["start", "end", "center", "align-none"]
            }],
            "snap-stop": [{
                snap: ["normal", "always"]
            }],
            "snap-type": [{
                snap: ["none", "x", "y", "both"]
            }],
            "snap-strictness": [{
                snap: ["mandatory", "proximity"]
            }],
            touch: [{
                touch: ["auto", "none", "manipulation"]
            }],
            "touch-x": [{
                "touch-pan": ["x", "left", "right"]
            }],
            "touch-y": [{
                "touch-pan": ["y", "up", "down"]
            }],
            "touch-pz": ["touch-pinch-zoom"],
            select: [{
                select: ["none", "text", "all", "auto"]
            }],
            "will-change": [{
                "will-change": ["auto", "scroll", "contents", "transform", Xh, Zh]
            }],
            fill: [{
                fill: ["none", ...A()]
            }],
            "stroke-w": [{
                stroke: [Lh, Jh, qh, Wh]
            }],
            stroke: [{
                stroke: ["none", ...A()]
            }],
            "forced-color-adjust": [{
                "forced-color-adjust": ["auto", "none"]
            }]
        },
        conflictingClassGroups: {
            overflow: ["overflow-x", "overflow-y"],
            overscroll: ["overscroll-x", "overscroll-y"],
            inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
            "inset-x": ["right", "left"],
            "inset-y": ["top", "bottom"],
            flex: ["basis", "grow", "shrink"],
            gap: ["gap-x", "gap-y"],
            p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
            px: ["pr", "pl"],
            py: ["pt", "pb"],
            m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
            mx: ["mr", "ml"],
            my: ["mt", "mb"],
            size: ["w", "h"],
            "font-size": ["leading"],
            "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
            "fvn-ordinal": ["fvn-normal"],
            "fvn-slashed-zero": ["fvn-normal"],
            "fvn-figure": ["fvn-normal"],
            "fvn-spacing": ["fvn-normal"],
            "fvn-fraction": ["fvn-normal"],
            "line-clamp": ["display", "overflow"],
            rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
            "rounded-s": ["rounded-ss", "rounded-es"],
            "rounded-e": ["rounded-se", "rounded-ee"],
            "rounded-t": ["rounded-tl", "rounded-tr"],
            "rounded-r": ["rounded-tr", "rounded-br"],
            "rounded-b": ["rounded-br", "rounded-bl"],
            "rounded-l": ["rounded-tl", "rounded-bl"],
            "border-spacing": ["border-spacing-x", "border-spacing-y"],
            "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
            "border-w-x": ["border-w-r", "border-w-l"],
            "border-w-y": ["border-w-t", "border-w-b"],
            "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
            "border-color-x": ["border-color-r", "border-color-l"],
            "border-color-y": ["border-color-t", "border-color-b"],
            translate: ["translate-x", "translate-y", "translate-none"],
            "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
            "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
            "scroll-mx": ["scroll-mr", "scroll-ml"],
            "scroll-my": ["scroll-mt", "scroll-mb"],
            "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
            "scroll-px": ["scroll-pr", "scroll-pl"],
            "scroll-py": ["scroll-pt", "scroll-pb"],
            touch: ["touch-x", "touch-y", "touch-pz"],
            "touch-x": ["touch"],
            "touch-y": ["touch"],
            "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
            "font-size": ["leading"]
        },
        orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
    }
}
);
function hv(...e) {
    return fv(ih(e))
}
function vv(e="") {
    return e.replace(/\D/g, "")
}
function mv(e, t) {
    "string" == typeof t && (t = [t]);
    const n = {};
    for (const o in e)
        t.includes(o) || (n[o] = e[o]);
    return n
}
const gv = to({
    __name: "DialogOverlay",
    props: {
        forceMount: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = ms( () => {
            const {class: e, ...n} = t;
            return n
        }
        );
        return (e, o) => (Tr(),
        Ir(Nt(Vd), Gr({
            "data-slot": "dialog-overlay"
        }, n.value, {
            class: Nt(hv)("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/65", t.class)
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["class"]))
    }
})
  , yv = to({
    __name: "DialogContent",
    props: {
        forceMount: {
            type: Boolean
        },
        disableOutsidePointerEvents: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = Zd(Lf(n, "class"), o);
        return (e, t) => (Tr(),
        Ir(Nt(Ep), null, {
            default: En( () => [jr(gv), jr(Nt(Bd), Gr({
                "data-slot": "dialog-content"
            }, Nt(a), {
                class: Nt(hv)("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", n.class)
            }), {
                default: En( () => [Wo(e.$slots, "default"), jr(Nt(nd), {
                    class: "!size-6 cursor-pointer z-10 active:scale-85 ring-offset-background focus-visible:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-all hover:opacity-100 focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0"
                }, {
                    default: En( () => [jr(Nt(rh)), t[0] || (t[0] = Dr("span", {
                        class: "sr-only"
                    }, "Close", -1))]),
                    _: 1,
                    __: [0]
                })]),
                _: 3
            }, 16, ["class"])]),
            _: 3
        }))
    }
})
  , bv = to({
    __name: "DialogHeader",
    props: {
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("div", {
            "data-slot": "dialog-header",
            class: K(Nt(hv)("flex flex-col gap-2 text-center sm:text-left", t.class))
        }, [Wo(e.$slots, "default")], 2))
    }
})
  , wv = to({
    __name: "DialogDescription",
    props: {
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Ud(Lf(t, "class"));
        return (e, o) => (Tr(),
        Ir(Nt(Id), Gr({
            "data-slot": "dialog-description"
        }, Nt(n), {
            class: Nt(hv)("text-muted-foreground text-sm", t.class)
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["class"]))
    }
})
  , _v = to({
    __name: "DialogTitle",
    props: {
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Ud(Lf(t, "class"));
        return (e, o) => (Tr(),
        Ir(Nt(qd), Gr({
            "data-slot": "dialog-title"
        }, Nt(n), {
            class: Nt(hv)("text-lg leading-none font-semibold", t.class)
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["class"]))
    }
})
  , xv = to({
    __name: "DialogTrigger",
    props: {
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Ir(Nt(Wd), Gr({
            "data-slot": "dialog-trigger"
        }, t), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
});
!function() {
    var e;
    try {
        if (typeof document < "u") {
            var t = document.createElement("style");
            t.nonce = null == (e = document.head.querySelector("meta[property=csp-nonce]")) ? void 0 : e.content,
            t.appendChild(document.createTextNode('[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32,.72,0,1);animation-duration:.5s;animation-timing-function:cubic-bezier(.32,.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--initial-transform, 100%),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--initial-transform, 100%),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top],[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height, 0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left],[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height, 0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(.32,.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-animate=false]{animation:none!important}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32,.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true]):after{content:"";position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]:after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]:after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]:after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]:after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not([data-state=closed]){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:hover,[data-vaul-handle]:active{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover: hover) and (pointer: fine){[data-vaul-drawer]{-webkit-user-select:none;user-select:none}}@media (pointer: fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{0%{transform:translate3d(0,var(--initial-transform, 100%),0)}to{transform:translateZ(0)}}@keyframes slideToBottom{to{transform:translate3d(0,var(--initial-transform, 100%),0)}}@keyframes slideFromTop{0%{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}to{transform:translateZ(0)}}@keyframes slideToTop{to{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}}@keyframes slideFromLeft{0%{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}to{transform:translateZ(0)}}@keyframes slideToLeft{to{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}}@keyframes slideFromRight{0%{transform:translate3d(var(--initial-transform, 100%),0,0)}to{transform:translateZ(0)}}@keyframes slideToRight{to{transform:translate3d(var(--initial-transform, 100%),0,0)}}')),
            document.head.appendChild(t)
        }
    } catch (n) {}
}();
const kv = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && (globalThis,
WorkerGlobalScope);
function Sv(e, t, n, o={}) {
    var a, r, s;
    const {clone: i=!1, passive: l=!1, eventName: u, deep: c=!1, defaultValue: d, shouldEmit: p} = o
      , f = es()
      , h = n || (null == f ? void 0 : f.emit) || (null == (a = null == f ? void 0 : f.$emit) ? void 0 : a.bind(f)) || (null == (s = null == (r = null == f ? void 0 : f.proxy) ? void 0 : r.$emit) ? void 0 : s.bind(null == f ? void 0 : f.proxy));
    let v = u;
    t || (t = "modelValue"),
    v = v || `update:${t.toString()}`;
    const m = e => i ? "function" == typeof i ? i(e) : function(e) {
        return JSON.parse(JSON.stringify(e))
    }(e) : e
      , g = () => (e => typeof e < "u")(e[t]) ? m(e[t]) : d
      , y = e => {
        p ? p(e) && h(v, e) : h(v, e)
    }
    ;
    if (l) {
        const n = It(g());
        let o = !1;
        return Qa( () => e[t], e => {
            o || (o = !0,
            n.value = m(e),
            fn( () => o = !1))
        }
        ),
        Qa(n, n => {
            !o && (n !== e[t] || c) && y(n)
        }
        , {
            deep: c
        }),
        n
    }
    return ms({
        get: () => g(),
        set(e) {
            y(e)
        }
    })
}
const [Cv,Ev] = Nc("DrawerRoot")
  , Tv = new WeakMap;
function Av(e, t, n=!1) {
    if (!(e && e instanceof HTMLElement && t))
        return;
    const o = {};
    Object.entries(t).forEach( ([t,n]) => {
        t.startsWith("--") ? e.style.setProperty(t, n) : (o[t] = e.style[t],
        e.style[t] = n)
    }
    ),
    !n && Tv.set(e, o)
}
function Ov(e, t) {
    const n = window.getComputedStyle(e)
      , o = n.transform || n.webkitTransform || n.mozTransform;
    let a = o.match(/^matrix3d\((.+)\)$/);
    return a ? Number.parseFloat(a[1].split(", ")[Mv(t) ? 13 : 12]) : (a = o.match(/^matrix\((.+)\)$/),
    a ? Number.parseFloat(a[1].split(", ")[Mv(t) ? 5 : 4]) : null)
}
function Mv(e) {
    switch (e) {
    case "top":
    case "bottom":
        return !0;
    case "left":
    case "right":
        return !1;
    default:
        return e
    }
}
function Pv(e, t) {
    if (!e)
        return () => {}
        ;
    const n = e.style.cssText;
    return Object.assign(e.style, t),
    () => {
        e.style.cssText = n
    }
}
const Bv = {
    DURATION: .5,
    EASE: [.32, .72, 0, 1]
}
  , Iv = "vaul-dragging";
function Lv() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
}
let Rv = null;
function zv(e) {
    const {isOpen: t, modal: n, nested: o, hasBeenOpened: a, preventScrollRestoration: r, noBodyStyles: s} = e
      , i = It(typeof window < "u" ? window.location.href : "")
      , l = It(0);
    function u() {
        if (Lv() && null !== Rv && !s.value) {
            const e = -Number.parseInt(document.body.style.top, 10)
              , t = -Number.parseInt(document.body.style.left, 10);
            Object.assign(document.body.style, Rv),
            window.requestAnimationFrame( () => {
                r.value && i.value !== window.location.href ? i.value = window.location.href : window.scrollTo(t, e)
            }
            ),
            Rv = null
        }
    }
    return Mo( () => {
        function e() {
            l.value = window.scrollY
        }
        e(),
        window.addEventListener("scroll", e),
        Lo( () => {
            window.removeEventListener("scroll", e)
        }
        )
    }
    ),
    Qa([t, a, i], () => {
        o.value || !a.value || (t.value ? (window.matchMedia("(display-mode: standalone)").matches || function() {
            if (Lv() && null === Rv && t.value && !s.value) {
                Rv = {
                    position: document.body.style.position,
                    top: document.body.style.top,
                    left: document.body.style.left,
                    height: document.body.style.height
                };
                const {scrollX: e, innerHeight: t} = window;
                document.body.style.setProperty("position", "fixed", "important"),
                Object.assign(document.body.style, {
                    top: -l.value + "px",
                    left: -e + "px",
                    right: "0px",
                    height: "auto"
                }),
                setTimeout( () => {
                    requestAnimationFrame( () => {
                        const e = t - window.innerHeight;
                        e && l.value >= t && (document.body.style.top = `-${l.value + e}px`)
                    }
                    )
                }
                , 300)
            }
        }(),
        n.value || setTimeout( () => {
            u()
        }
        , 500)) : u())
    }
    ),
    {
        restorePositionSetting: u
    }
}
function Nv(e) {
    const {emitDrag: t, emitRelease: n, emitClose: o, emitOpenChange: a, open: r, dismissible: s, nested: i, modal: l, shouldScaleBackground: u, setBackgroundColorOnScale: c, scrollLockTimeout: d, closeThreshold: p, activeSnapPoint: f, fadeFromIndex: h, direction: v, noBodyStyles: m, handleOnly: g, preventScrollRestoration: y} = e
      , b = It(r.value ?? !1)
      , w = It(!1)
      , _ = It(!1)
      , x = It(!1)
      , k = It(null)
      , S = It(null)
      , C = It(null)
      , E = It(null)
      , T = It(null)
      , A = It(!1)
      , O = It(null)
      , M = It(0)
      , P = It(!1);
    It(0);
    const B = It(null);
    It(0);
    const I = ms( () => {
        var e;
        return (null == (e = B.value) ? void 0 : e.$el.getBoundingClientRect().height) || 0
    }
    )
      , L = function(e, t) {
        return e && e.value ? e : t
    }(e.snapPoints, It(void 0))
      , R = ms( () => {
        var e;
        return L && ((null == (e = L.value) ? void 0 : e.length) ?? 0) > 0
    }
    )
      , z = It(null)
      , {activeSnapPointIndex: N, onRelease: D, snapPointsOffset: j, onDrag: F, shouldFade: $, getPercentageDragged: V} = function({activeSnapPoint: e, snapPoints: t, drawerRef: n, overlayRef: o, fadeFromIndex: a, onSnapPointChange: r, direction: s}) {
        const i = It(typeof window < "u" ? {
            innerWidth: window.innerWidth,
            innerHeight: window.innerHeight
        } : void 0);
        function l() {
            i.value = {
                innerWidth: window.innerWidth,
                innerHeight: window.innerHeight
            }
        }
        Mo( () => {
            typeof window < "u" && window.addEventListener("resize", l)
        }
        ),
        Io( () => {
            typeof window < "u" && window.removeEventListener("resize", l)
        }
        );
        const u = ms( () => (t.value && e.value === t.value[t.value.length - 1]) ?? null)
          , c = ms( () => t.value && t.value.length > 0 && ((null == a ? void 0 : a.value) || 0 === (null == a ? void 0 : a.value)) && !Number.isNaN(null == a ? void 0 : a.value) && t.value[(null == a ? void 0 : a.value) ?? -1] === e.value || !t.value)
          , d = ms( () => {
            var n;
            return (null == (n = t.value) ? void 0 : n.findIndex(t => t === e.value)) ?? null
        }
        )
          , p = ms( () => {
            var e;
            return (null == (e = t.value) ? void 0 : e.map(e => {
                const t = "string" == typeof e;
                let n = 0;
                if (t && (n = Number.parseInt(e, 10)),
                Mv(s.value)) {
                    const o = t ? n : i.value ? e * i.value.innerHeight : 0;
                    return i.value ? "bottom" === s.value ? i.value.innerHeight - o : -i.value.innerHeight + o : o
                }
                const o = t ? n : i.value ? e * i.value.innerWidth : 0;
                return i.value ? "right" === s.value ? i.value.innerWidth - o : -i.value.innerWidth + o : o
            }
            )) ?? []
        }
        )
          , f = ms( () => {
            var e;
            return null !== d.value ? null == (e = p.value) ? void 0 : e[d.value] : null
        }
        )
          , h = i => {
            var l, u, c, d;
            const f = (null == (l = p.value) ? void 0 : l.findIndex(e => e === i)) ?? null;
            fn( () => {
                var e;
                r(f, p.value),
                Av(null == (e = n.value) ? void 0 : e.$el, {
                    transition: `transform ${Bv.DURATION}s cubic-bezier(${Bv.EASE.join(",")})`,
                    transform: Mv(s.value) ? `translate3d(0, ${i}px, 0)` : `translate3d(${i}px, 0, 0)`
                })
            }
            ),
            p.value && f !== p.value.length - 1 && f !== (null == a ? void 0 : a.value) ? Av(null == (u = o.value) ? void 0 : u.$el, {
                transition: `opacity ${Bv.DURATION}s cubic-bezier(${Bv.EASE.join(",")})`,
                opacity: "0"
            }) : Av(null == (c = o.value) ? void 0 : c.$el, {
                transition: `opacity ${Bv.DURATION}s cubic-bezier(${Bv.EASE.join(",")})`,
                opacity: "1"
            }),
            e.value = null !== f ? (null == (d = t.value) ? void 0 : d[f]) ?? null : null
        }
        ;
        return Qa([e, p, t], () => {
            var n;
            if (e.value) {
                const o = (null == (n = t.value) ? void 0 : n.findIndex(t => t === e.value)) ?? -1;
                p.value && -1 !== o && "number" == typeof p.value[o] && h(p.value[o])
            }
        }
        , {
            immediate: !0
        }),
        {
            isLastSnapPoint: u,
            shouldFade: c,
            getPercentageDragged: function(e, n) {
                if (!t.value || "number" != typeof d.value || !p.value || void 0 === a.value)
                    return null;
                const o = d.value === a.value - 1;
                if (d.value >= a.value && n)
                    return 0;
                if (o && !n)
                    return 1;
                if (!c.value && !o)
                    return null;
                const r = o ? d.value + 1 : d.value - 1
                  , s = o ? p.value[r] - p.value[r - 1] : p.value[r + 1] - p.value[r]
                  , i = e / Math.abs(s);
                return o ? 1 - i : i
            },
            activeSnapPointIndex: d,
            onRelease: function({draggedDistance: e, closeDrawer: n, velocity: r, dismissible: i}) {
                var l, c, v;
                if (void 0 === a.value)
                    return;
                const m = "bottom" === s.value || "right" === s.value ? (f.value ?? 0) - e : (f.value ?? 0) + e
                  , g = d.value === a.value - 1
                  , y = 0 === d.value
                  , b = e > 0;
                if (g && Av(null == (l = o.value) ? void 0 : l.$el, {
                    transition: `opacity ${Bv.DURATION}s cubic-bezier(${Bv.EASE.join(",")})`
                }),
                r > 2 && !b)
                    return void (i ? n() : h(p.value[0]));
                if (r > 2 && b && p && t.value)
                    return void h(p.value[t.value.length - 1]);
                const w = null == (c = p.value) ? void 0 : c.reduce( (e, t) => "number" != typeof e || "number" != typeof t ? e : Math.abs(t - m) < Math.abs(e - m) ? t : e)
                  , _ = Mv(s.value) ? window.innerHeight : window.innerWidth;
                if (r > .4 && Math.abs(e) < .4 * _) {
                    const e = b ? 1 : -1;
                    if (e > 0 && u)
                        return void h(p.value[((null == (v = t.value) ? void 0 : v.length) ?? 0) - 1]);
                    if (y && e < 0 && i && n(),
                    null === d.value)
                        return;
                    return void h(p.value[d.value + e])
                }
                h(w)
            },
            onDrag: function({draggedDistance: e}) {
                var t;
                if (null === f.value)
                    return;
                const o = "bottom" === s.value || "right" === s.value ? f.value - e : f.value + e;
                ("bottom" === s.value || "right" === s.value) && o < p.value[p.value.length - 1] || ("top" === s.value || "left" === s.value) && o > p.value[p.value.length - 1] || Av(null == (t = n.value) ? void 0 : t.$el, {
                    transform: Mv(s.value) ? `translate3d(0, ${o}px, 0)` : `translate3d(${o}px, 0, 0)`
                })
            },
            snapPointsOffset: p
        }
    }({
        snapPoints: L,
        activeSnapPoint: f,
        drawerRef: B,
        fadeFromIndex: h,
        overlayRef: k,
        onSnapPointChange: function(e, t) {
            L.value && e === t.length - 1 && (S.value = new Date)
        },
        direction: v
    });
    function H() {
        return (window.innerWidth - 26) / window.innerWidth
    }
    function U(e, t) {
        var n;
        if (!e)
            return !1;
        let o = e;
        const a = null == (n = window.getSelection()) ? void 0 : n.toString()
          , r = B.value ? Ov(B.value.$el, v.value) : null
          , s = new Date;
        if (o.hasAttribute("data-vaul-no-drag") || o.closest("[data-vaul-no-drag]"))
            return !1;
        if ("right" === v.value || "left" === v.value)
            return !0;
        if (S.value && s.getTime() - S.value.getTime() < 500)
            return !1;
        if (null !== r && ("bottom" === v.value ? r > 0 : r < 0))
            return !0;
        if (a && a.length > 0)
            return !1;
        if (T.value && s.getTime() - T.value.getTime() < d.value && 0 === r || t)
            return T.value = s,
            !1;
        for (; o; ) {
            if (o.scrollHeight > o.clientHeight) {
                if (0 !== o.scrollTop)
                    return T.value = new Date,
                    !1;
                if ("dialog" === o.getAttribute("role"))
                    return !0
            }
            o = o.parentNode
        }
        return !0
    }
    function Z() {
        var e;
        if (!B.value)
            return;
        const t = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]")
          , n = Ov(B.value.$el, v.value);
        Av(B.value.$el, {
            transform: "translate3d(0, 0, 0)",
            transition: `transform ${Bv.DURATION}s cubic-bezier(${Bv.EASE.join(",")})`
        }),
        Av(null == (e = k.value) ? void 0 : e.$el, {
            transition: `opacity ${Bv.DURATION}s cubic-bezier(${Bv.EASE.join(",")})`,
            opacity: "1"
        }),
        u.value && n && n > 0 && b.value && Av(t, {
            borderRadius: "8px",
            overflow: "hidden",
            ...Mv(v.value) ? {
                transform: `scale(${H()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
                transformOrigin: "top"
            } : {
                transform: `scale(${H()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
                transformOrigin: "left"
            },
            transitionProperty: "transform, border-radius",
            transitionDuration: `${Bv.DURATION}s`,
            transitionTimingFunction: `cubic-bezier(${Bv.EASE.join(",")})`
        }, !0)
    }
    function q(e) {
        B.value && (o(),
        e || (b.value = !1),
        window.setTimeout( () => {
            L.value && (f.value = L.value[0])
        }
        , 1e3 * Bv.DURATION))
    }
    return zv({
        isOpen: b,
        modal: l,
        nested: i,
        hasBeenOpened: w,
        noBodyStyles: m,
        preventScrollRestoration: y
    }),
    Ya( () => {
        if (!b.value && u.value && kv) {
            const e = setTimeout( () => {
                !function(e) {
                    if (!(e && e instanceof HTMLElement))
                        return;
                    const t = Tv.get(e);
                    t && Object.entries(t).forEach( ([t,n]) => {
                        e.style[t] = n
                    }
                    )
                }(document.body)
            }
            , 200);
            return () => clearTimeout(e)
        }
    }
    ),
    Qa(r, () => {
        b.value = r.value,
        r.value || q()
    }
    ),
    Qa(b, e => {
        e && (S.value = new Date),
        a(e)
    }
    , {
        immediate: !0
    }),
    {
        open: r,
        isOpen: b,
        modal: l,
        keyboardIsOpen: P,
        hasBeenOpened: w,
        drawerRef: B,
        drawerHeightRef: I,
        overlayRef: k,
        handleRef: z,
        isDragging: _,
        dragStartTime: C,
        isAllowedToDrag: A,
        snapPoints: L,
        activeSnapPoint: f,
        hasSnapPoints: R,
        pointerStart: M,
        dismissible: s,
        snapPointsOffset: j,
        direction: v,
        shouldFade: $,
        fadeFromIndex: h,
        shouldScaleBackground: u,
        setBackgroundColorOnScale: c,
        onPress: function(e) {
            !s.value && !L.value || B.value && !B.value.$el.contains(e.target) || (_.value = !0,
            C.value = new Date,
            e.target.setPointerCapture(e.pointerId),
            M.value = Mv(v.value) ? e.clientY : e.clientX)
        },
        onDrag: function(e) {
            var n, o, a, r, i, l;
            if (B.value && _.value) {
                const c = "bottom" === v.value || "right" === v.value ? 1 : -1
                  , d = (M.value - (Mv(v.value) ? e.clientY : e.clientX)) * c
                  , p = d > 0
                  , f = L.value && !s.value && !p;
                if (f && 0 === N.value)
                    return;
                const m = Math.abs(d)
                  , g = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
                let y = m / I.value;
                const b = V(m, p);
                if (null !== b && (y = b),
                f && y >= 1 || !A.value && !U(e.target, p))
                    return;
                if (null == (n = null == B ? void 0 : B.value) || n.$el.classList.add(Iv),
                A.value = !0,
                Av(null == (o = B.value) ? void 0 : o.$el, {
                    transition: "none"
                }),
                Av(null == (a = k.value) ? void 0 : a.$el, {
                    transition: "none"
                }),
                L.value && F({
                    draggedDistance: d
                }),
                p && !L.value) {
                    const e = function(e) {
                        return 8 * (Math.log(e + 1) - 2)
                    }(d)
                      , t = Math.min(-1 * e, 0) * c;
                    return void Av(null == (r = B.value) ? void 0 : r.$el, {
                        transform: Mv(v.value) ? `translate3d(0, ${t}px, 0)` : `translate3d(${t}px, 0, 0)`
                    })
                }
                const w = 1 - y;
                if (($.value || h.value && N.value === h.value - 1) && (t(y),
                Av(null == (i = k.value) ? void 0 : i.$el, {
                    opacity: `${w}`,
                    transition: "none"
                }, !0)),
                g && k.value && u.value) {
                    const e = Math.min(H() + y * (1 - H()), 1)
                      , t = 8 - 8 * y
                      , n = Math.max(0, 14 - 14 * y);
                    Av(g, {
                        borderRadius: `${t}px`,
                        transform: Mv(v.value) ? `scale(${e}) translate3d(0, ${n}px, 0)` : `scale(${e}) translate3d(${n}px, 0, 0)`,
                        transition: "none"
                    }, !0)
                }
                if (!L.value) {
                    const e = m * c;
                    Av(null == (l = B.value) ? void 0 : l.$el, {
                        transform: Mv(v.value) ? `translate3d(0, ${e}px, 0)` : `translate3d(${e}px, 0, 0)`
                    })
                }
            }
        },
        onRelease: function(e) {
            if (!_.value || !B.value)
                return;
            B.value.$el.classList.remove(Iv),
            A.value = !1,
            _.value = !1,
            E.value = new Date;
            const t = Ov(B.value.$el, v.value);
            if (!U(e.target, !1) || !t || Number.isNaN(t) || null === C.value)
                return;
            const o = E.value.getTime() - C.value.getTime()
              , a = M.value - (Mv(v.value) ? e.clientY : e.clientX)
              , r = Math.abs(a) / o;
            if (r > .05 && (x.value = !0,
            window.setTimeout( () => {
                x.value = !1
            }
            , 200)),
            L.value) {
                const e = "bottom" === v.value || "right" === v.value ? 1 : -1;
                return D({
                    draggedDistance: a * e,
                    closeDrawer: q,
                    velocity: r,
                    dismissible: s.value
                }),
                void n(!0)
            }
            if ("bottom" === v.value || "right" === v.value ? a > 0 : a < 0)
                return Z(),
                void n(!0);
            if (r > .4)
                return q(),
                void n(!1);
            if (t >= Math.min(B.value.$el.getBoundingClientRect().height ?? 0, window.innerHeight) * p.value)
                return q(),
                void n(!1);
            n(!0),
            Z()
        },
        closeDrawer: q,
        onNestedDrag: function(e) {
            var t;
            if (e < 0)
                return;
            const n = Mv(v.value) ? window.innerHeight : window.innerWidth
              , o = (n - 16) / n
              , a = o + e * (1 - o)
              , r = 16 * e - 16;
            Av(null == (t = B.value) ? void 0 : t.$el, {
                transform: Mv(v.value) ? `scale(${a}) translate3d(0, ${r}px, 0)` : `scale(${a}) translate3d(${r}px, 0, 0)`,
                transition: "none"
            })
        },
        onNestedRelease: function(e) {
            var t;
            const n = Mv(v.value) ? window.innerHeight : window.innerWidth
              , o = e ? (n - 16) / n : 1
              , a = e ? -16 : 0;
            e && Av(null == (t = B.value) ? void 0 : t.$el, {
                transition: `transform ${Bv.DURATION}s cubic-bezier(${Bv.EASE.join(",")})`,
                transform: Mv(v.value) ? `scale(${o}) translate3d(0, ${a}px, 0)` : `scale(${o}) translate3d(${a}px, 0, 0)`
            })
        },
        onNestedOpenChange: function(e) {
            var t, n;
            const o = e ? (window.innerWidth - 16) / window.innerWidth : 1
              , a = e ? -16 : 0;
            O.value && window.clearTimeout(O.value),
            Av(null == (t = B.value) ? void 0 : t.$el, {
                transition: `transform ${Bv.DURATION}s cubic-bezier(${Bv.EASE.join(",")})`,
                transform: `scale(${o}) translate3d(0, ${a}px, 0)`
            }),
            !e && null != (n = B.value) && n.$el && (O.value = window.setTimeout( () => {
                var e, t;
                const n = Ov(null == (e = B.value) ? void 0 : e.$el, v.value);
                Av(null == (t = B.value) ? void 0 : t.$el, {
                    transition: "none",
                    transform: Mv(v.value) ? `translate3d(0, ${n}px, 0)` : `translate3d(${n}px, 0, 0)`
                })
            }
            , 500))
        },
        emitClose: o,
        emitDrag: t,
        emitRelease: n,
        emitOpenChange: a,
        nested: i,
        handleOnly: g,
        noBodyStyles: m
    }
}
const Dv = to({
    __name: "DrawerRoot",
    props: {
        activeSnapPoint: {
            default: void 0
        },
        closeThreshold: {
            default: .25
        },
        shouldScaleBackground: {
            type: Boolean,
            default: void 0
        },
        setBackgroundColorOnScale: {
            type: Boolean,
            default: !0
        },
        scrollLockTimeout: {
            default: 100
        },
        fixed: {
            type: Boolean,
            default: void 0
        },
        dismissible: {
            type: Boolean,
            default: !0
        },
        modal: {
            type: Boolean,
            default: !0
        },
        open: {
            type: Boolean,
            default: void 0
        },
        defaultOpen: {
            type: Boolean,
            default: void 0
        },
        nested: {
            type: Boolean,
            default: !1
        },
        direction: {
            default: "bottom"
        },
        noBodyStyles: {
            type: Boolean
        },
        handleOnly: {
            type: Boolean,
            default: !1
        },
        preventScrollRestoration: {
            type: Boolean
        },
        snapPoints: {
            default: void 0
        },
        fadeFromIndex: {
            default: void 0
        }
    },
    emits: ["drag", "release", "close", "update:open", "update:activeSnapPoint", "animationEnd"],
    setup(e, {expose: t, emit: n}) {
        const o = e
          , a = n;
        ea();
        const r = ms( () => o.fadeFromIndex ?? (o.snapPoints && o.snapPoints.length - 1))
          , s = Sv(o, "open", a, {
            defaultValue: o.defaultOpen,
            passive: void 0 === o.open
        })
          , i = Sv(o, "activeSnapPoint", a, {
            passive: void 0 === o.activeSnapPoint
        })
          , l = {
            emitDrag: e => a("drag", e),
            emitRelease: e => a("release", e),
            emitClose: () => a("close"),
            emitOpenChange: e => {
                a("update:open", e),
                setTimeout( () => {
                    a("animationEnd", e)
                }
                , 1e3 * Bv.DURATION)
            }
        }
          , {closeDrawer: u, hasBeenOpened: c, modal: d, isOpen: p} = Ev(Nv({
            ...l,
            ...Ht(o),
            activeSnapPoint: i,
            fadeFromIndex: r,
            open: s
        }));
        function f(e) {
            void 0 === s.value ? (p.value = e,
            e ? c.value = !0 : u()) : l.emitOpenChange(e)
        }
        return t({
            open: p
        }),
        (e, t) => (Tr(),
        Ir(Nt(td), {
            open: Nt(p),
            modal: Nt(d),
            "onUpdate:open": f
        }, {
            default: En( () => [Wo(e.$slots, "default", {
                open: Nt(p)
            })]),
            _: 3
        }, 8, ["open", "modal"]))
    }
})
  , jv = to({
    __name: "DrawerOverlay",
    setup(e) {
        const {overlayRef: t, hasSnapPoints: n, isOpen: o, shouldFade: a} = Cv();
        return (e, r) => (Tr(),
        Ir(Nt(Vd), {
            ref_key: "overlayRef",
            ref: t,
            "data-vaul-overlay": "",
            "data-vaul-snap-points": Nt(o) && Nt(n) ? "true" : "false",
            "data-vaul-snap-points-overlay": Nt(o) && Nt(a) ? "true" : "false"
        }, null, 8, ["data-vaul-snap-points", "data-vaul-snap-points-overlay"]))
    }
});
const Fv = to({
    __name: "DrawerContent",
    setup(e) {
        const {open: t, isOpen: n, snapPointsOffset: o, hasSnapPoints: a, drawerRef: r, onPress: s, onDrag: i, onRelease: l, modal: u, emitOpenChange: c, dismissible: d, keyboardIsOpen: p, closeDrawer: f, direction: h, handleOnly: v} = Cv();
        !function() {
            const {direction: e, isOpen: t, shouldScaleBackground: n, setBackgroundColorOnScale: o, noBodyStyles: a} = Cv()
              , r = It(null)
              , s = It(document.body.style.backgroundColor);
            function i() {
                return (window.innerWidth - 26) / window.innerWidth
            }
            Ya(l => {
                if (t.value && n.value) {
                    r.value && clearTimeout(r.value);
                    const t = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
                    if (!t)
                        return;
                    o.value && !a.value && Pv(document.body, {
                        background: "black"
                    }),
                    Pv(t, {
                        transformOrigin: Mv(e.value) ? "top" : "left",
                        transitionProperty: "transform, border-radius",
                        transitionDuration: `${Bv.DURATION}s`,
                        transitionTimingFunction: `cubic-bezier(${Bv.EASE.join(",")})`
                    });
                    const n = Pv(t, {
                        borderRadius: "8px",
                        overflow: "hidden",
                        ...Mv(e.value) ? {
                            transform: `scale(${i()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
                        } : {
                            transform: `scale(${i()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
                        }
                    });
                    l( () => {
                        n(),
                        r.value = window.setTimeout( () => {
                            s.value ? document.body.style.background = s.value : document.body.style.removeProperty("background")
                        }
                        , 1e3 * Bv.DURATION)
                    }
                    )
                }
            }
            , {
                flush: "pre"
            })
        }();
        const m = It(!1)
          , g = ms( () => o.value && o.value.length > 0 ? `${o.value[0]}px` : "0");
        function y(e) {
            u.value && !e.defaultPrevented ? (p.value && (p.value = !1),
            d.value ? c(!1) : e.preventDefault()) : e.preventDefault()
        }
        function b(e) {
            v.value || s(e)
        }
        function w(e) {
            v.value || i(e)
        }
        return Ya( () => {
            a.value && window.requestAnimationFrame( () => {
                m.value = !0
            }
            )
        }
        ),
        (e, t) => (Tr(),
        Ir(Nt(Bd), {
            ref_key: "drawerRef",
            ref: r,
            "data-vaul-drawer": "",
            "data-vaul-drawer-direction": Nt(h),
            "data-vaul-delayed-snap-points": m.value ? "true" : "false",
            "data-vaul-snap-points": Nt(n) && Nt(a) ? "true" : "false",
            style: U({
                "--snap-point-height": g.value
            }),
            onPointerdown: b,
            onPointermove: w,
            onPointerup: Nt(l),
            onPointerDownOutside: y,
            onOpenAutoFocus: t[0] || (t[0] = Yi( () => {}
            , ["prevent"])),
            onEscapeKeyDown: t[1] || (t[1] = e => {
                Nt(d) || e.preventDefault()
            }
            )
        }, {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 8, ["data-vaul-drawer-direction", "data-vaul-delayed-snap-points", "data-vaul-snap-points", "style", "onPointerup"]))
    }
})
  , $v = to({
    __name: "Drawer",
    props: {
        activeSnapPoint: {},
        closeThreshold: {},
        shouldScaleBackground: {
            type: Boolean,
            default: !0
        },
        setBackgroundColorOnScale: {
            type: Boolean
        },
        scrollLockTimeout: {},
        fixed: {
            type: Boolean
        },
        dismissible: {
            type: Boolean
        },
        modal: {
            type: Boolean
        },
        open: {
            type: Boolean
        },
        defaultOpen: {
            type: Boolean
        },
        nested: {
            type: Boolean
        },
        direction: {},
        noBodyStyles: {
            type: Boolean
        },
        handleOnly: {
            type: Boolean
        },
        preventScrollRestoration: {
            type: Boolean
        },
        snapPoints: {},
        fadeFromIndex: {}
    },
    emits: ["drag", "release", "close", "update:open", "update:activeSnapPoint", "animationEnd"],
    setup(e, {emit: t}) {
        const n = Zd(e, t);
        return (e, t) => (Tr(),
        Ir(Nt(Dv), Gr({
            "data-slot": "drawer"
        }, Nt(n)), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , Vv = to({
    __name: "DrawerOverlay",
    props: {
        forceMount: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Lf(t, "class");
        return (e, o) => (Tr(),
        Ir(Nt(jv), Gr({
            "data-slot": "drawer-overlay"
        }, Nt(n), {
            class: Nt(hv)("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80", t.class)
        }), null, 16, ["class"]))
    }
})
  , Hv = to({
    __name: "DrawerContent",
    props: {
        forceMount: {
            type: Boolean
        },
        disableOutsidePointerEvents: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
    setup(e, {emit: t}) {
        const n = e
          , o = Zd(n, t);
        return (e, t) => (Tr(),
        Ir(Nt(Ep), null, {
            default: En( () => [jr(Vv), jr(Nt(Fv), Gr({
                "data-slot": "drawer-content"
            }, Nt(o), {
                class: Nt(hv)("group/drawer-content bg-background fixed z-50 flex h-auto flex-col", "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg", "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg", "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:sm:max-w-sm", "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:sm:max-w-sm", n.class)
            }), {
                default: En( () => [t[0] || (t[0] = Dr("div", {
                    class: "bg-muted mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full group-data-[vaul-drawer-direction=bottom]/drawer-content:block"
                }, null, -1)), Wo(e.$slots, "default")]),
                _: 3,
                __: [0]
            }, 16, ["class"])]),
            _: 3
        }))
    }
})
  , Uv = to({
    __name: "DrawerHeader",
    props: {
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("div", {
            "data-slot": "drawer-header",
            class: K(Nt(hv)("flex flex-col gap-1.5 p-4", t.class))
        }, [Wo(e.$slots, "default")], 2))
    }
})
  , Zv = to({
    __name: "DrawerDescription",
    props: {
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Lf(t, "class");
        return (e, o) => (Tr(),
        Ir(Nt(Id), Gr({
            "data-slot": "drawer-description"
        }, Nt(n), {
            class: Nt(hv)("text-muted-foreground text-sm", t.class)
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["class"]))
    }
})
  , qv = to({
    __name: "DrawerTitle",
    props: {
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Lf(t, "class");
        return (e, o) => (Tr(),
        Ir(Nt(qd), Gr({
            "data-slot": "drawer-title"
        }, Nt(n), {
            class: Nt(hv)("text-foreground font-semibold", t.class)
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["class"]))
    }
})
  , Wv = to({
    __name: "DrawerTrigger",
    props: {
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Ir(Nt(Wd), Gr({
            "data-slot": "drawer-trigger"
        }, t), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , Gv = to({
    __name: "Modal",
    props: {
        modalClass: {},
        modelValue: {
            type: Boolean
        }
    },
    emits: ["update:modelValue"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = function(e, t={}) {
            const {window: n=Ff, ssrWidth: o=Uf()} = t
              , a = Vf( () => n && "matchMedia"in n && "function" == typeof n.matchMedia)
              , r = Lt("number" == typeof o)
              , s = Lt()
              , i = Lt(!1);
            return Ya( () => {
                if (r.value) {
                    r.value = !a.value;
                    const t = Dt(e).split(",");
                    return void (i.value = t.some(e => {
                        const t = e.includes("not all")
                          , n = e.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/)
                          , a = e.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
                        let r = Boolean(n || a);
                        return n && r && (r = o >= Df(n[1])),
                        a && r && (r = o <= Df(a[1])),
                        t ? !r : r
                    }
                    ))
                }
                a.value && (s.value = n.matchMedia(Dt(e)),
                i.value = s.value.matches)
            }
            ),
            $f(s, "change", e => {
                i.value = e.matches
            }
            , {
                passive: !0
            }),
            ms( () => i.value)
        }("(max-width: 768px)")
          , r = e => o("update:modelValue", e);
        function s(e) {
            e.target.closest("[data-sonner-toaster]") && e.preventDefault()
        }
        return (e, t) => {
            const o = Wv
              , i = qv
              , l = Zv
              , u = Uv
              , c = Hv
              , d = $v
              , p = xv
              , f = _v
              , h = wv
              , v = bv
              , m = yv
              , g = Pf;
            return Nt(a) ? (Tr(),
            Ir(d, {
                key: 0,
                open: n.modelValue,
                "onUpdate:open": r
            }, {
                default: En( () => [e.$slots.trigger ? (Tr(),
                Ir(o, {
                    key: 0,
                    "as-child": ""
                }, {
                    default: En( () => [Wo(e.$slots, "trigger")]),
                    _: 3
                })) : Ur("", !0), jr(c, {
                    class: "pb-6 px-5",
                    onInteractOutside: s
                }, {
                    default: En( () => [jr(u, {
                        class: "text-center -mt-1"
                    }, {
                        default: En( () => [e.$slots.heading ? (Tr(),
                        Ir(i, {
                            key: 0,
                            class: "text-xl sm:text-2xl/8"
                        }, {
                            default: En( () => [Wo(e.$slots, "heading")]),
                            _: 3
                        })) : Ur("", !0), e.$slots.description ? (Tr(),
                        Ir(l, {
                            key: 1,
                            class: "!text-base"
                        }, {
                            default: En( () => [Wo(e.$slots, "description")]),
                            _: 3
                        })) : Ur("", !0)]),
                        _: 3
                    }), Wo(e.$slots, "content")]),
                    _: 3
                })]),
                _: 3
            }, 8, ["open"])) : (Tr(),
            Ir(g, {
                key: 1,
                open: n.modelValue,
                "onUpdate:open": r
            }, {
                default: En( () => [e.$slots.trigger ? (Tr(),
                Ir(p, {
                    key: 0,
                    "as-child": ""
                }, {
                    default: En( () => [Wo(e.$slots, "trigger")]),
                    _: 3
                })) : Ur("", !0), jr(m, {
                    class: K(["not-sm:p-4 px-10 py-11 sm:max-w-[510px] outline-none overflow-auto max-h-[92dvh]", n.modalClass]),
                    onInteractOutside: s
                }, {
                    default: En( () => [jr(v, null, {
                        default: En( () => [e.$slots.heading ? (Tr(),
                        Ir(f, {
                            key: 0,
                            class: "!text-2xl/8 flex items-center gap-1.5 justify-center"
                        }, {
                            default: En( () => [Wo(e.$slots, "heading")]),
                            _: 3
                        })) : Ur("", !0), e.$slots.description ? (Tr(),
                        Ir(h, {
                            key: 1,
                            class: "!text-base"
                        }, {
                            default: En( () => [Wo(e.$slots, "description")]),
                            _: 3
                        })) : Ur("", !0)]),
                        _: 3
                    }), Wo(e.$slots, "content")]),
                    _: 3
                }, 8, ["class"])]),
                _: 3
            }, 8, ["open"]))
        }
    }
})
  , Kv = e => "boolean" == typeof e ? `${e}` : 0 === e ? "0" : e
  , Yv = ih
  , Xv = (e, t) => n => {
    var o;
    if (null == (null == t ? void 0 : t.variants))
        return Yv(e, null == n ? void 0 : n.class, null == n ? void 0 : n.className);
    const {variants: a, defaultVariants: r} = t
      , s = Object.keys(a).map(e => {
        const t = null == n ? void 0 : n[e]
          , o = null == r ? void 0 : r[e];
        if (null === t)
            return null;
        const s = Kv(t) || Kv(o);
        return a[e][s]
    }
    )
      , i = n && Object.entries(n).reduce( (e, t) => {
        let[n,o] = t;
        return void 0 === o || (e[n] = o),
        e
    }
    , {})
      , l = null == t || null === (o = t.compoundVariants) || void 0 === o ? void 0 : o.reduce( (e, t) => {
        let {class: n, className: o, ...a} = t;
        return Object.entries(a).every(e => {
            let[t,n] = e;
            return Array.isArray(n) ? n.includes({
                ...r,
                ...i
            }[t]) : {
                ...r,
                ...i
            }[t] === n
        }
        ) ? [...e, n, o] : e
    }
    , []);
    return Yv(e, s, l, null == n ? void 0 : n.class, null == n ? void 0 : n.className)
}
  , Jv = Xv("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", {
    variants: {
        variant: {
            default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
            destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
            outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
            secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
            ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
            link: "text-primary underline-offset-4 hover:underline"
        },
        size: {
            default: "h-9 px-4 py-2 has-[>svg]:px-3",
            sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
            lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
            icon: "size-9"
        }
    },
    defaultVariants: {
        variant: "default",
        size: "default"
    }
})
  , Qv = to({
    __name: "Button",
    props: {
        variant: {},
        size: {},
        class: {},
        asChild: {
            type: Boolean
        },
        as: {
            default: "button"
        }
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Ir(Nt(yc), {
            "data-slot": "button",
            as: e.as,
            "as-child": e.asChild,
            class: K(Nt(hv)(Nt(Jv)({
                variant: e.variant,
                size: e.size
            }), t.class))
        }, {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 8, ["as", "as-child", "class"]))
    }
});
var em = /[a-zA-Z0-9:_-]/
  , tm = /[\s\t\r\n]/
  , nm = /['"]/;
function om(e) {
    var t = ""
      , n = []
      , o = i
      , a = null
      , r = null;
    function s(t) {
        var n = function(e, t, n) {
            return function(e, t) {
                void 0 === t && (t = {});
                var n = t.offsetLine || 0
                  , o = t.offsetColumn || 0
                  , a = e.split("\n")
                  , r = 0
                  , s = a.map(function(e, t) {
                    var n = r + e.length + 1
                      , o = {
                        start: r,
                        end: n,
                        line: t
                    };
                    return r = n,
                    o
                })
                  , i = 0;
                function l(e, t) {
                    return e.start <= t && t < e.end
                }
                function u(e, t) {
                    return {
                        line: n + e.line,
                        column: o + t - e.start,
                        character: t
                    }
                }
                return function(t, n) {
                    "string" == typeof t && (t = e.indexOf(t, n || 0));
                    for (var o = s[i], a = t >= o.end ? 1 : -1; o; ) {
                        if (l(o, t))
                            return u(o, t);
                        o = s[i += a]
                    }
                }
            }(e, n)(t, n)
        }(e, m)
          , o = n.line
          , a = n.column
          , r = e.slice(0, m)
          , s = /(^|\n).*$/.exec(r)[0].replace(/\t/g, "  ")
          , i = e.slice(m)
          , l = "" + s + /.*(\n|$)/.exec(i)[0] + "\n" + function(e, t) {
            for (var n = ""; t--; )
                n += e;
            return n
        }(" ", s.length) + "^";
        throw new Error(t + " (" + o + ":" + a + "). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues  thanks!\n\n" + l)
    }
    function i() {
        for (; m < e.length && "<" !== e[m] || !em.test(e[m + 1]); )
            t += e[m++];
        return l()
    }
    function l() {
        for (var t = ""; m < e.length && "<" !== e[m]; )
            t += e[m++];
        return /\S/.test(t) && a.children.push({
            type: "text",
            value: t
        }),
        "<" === e[m] ? u : l
    }
    function u() {
        var t = e[m];
        if ("?" === t)
            return l;
        if ("!" === t) {
            if ("--" === e.slice(m + 1, m + 3))
                return c;
            if ("[CDATA[" === e.slice(m + 1, m + 8))
                return d;
            if (/doctype/i.test(e.slice(m + 1, m + 8)))
                return l
        }
        if ("/" === t)
            return p;
        var o, i = {
            type: "element",
            tagName: f(),
            properties: {},
            children: []
        };
        for (a ? a.children.push(i) : r = i; m < e.length && (o = h()); )
            i.properties[o.name] = o.value;
        var u = !1;
        return "/" === e[m] && (m += 1,
        u = !0),
        ">" !== e[m] && s("Expected >"),
        u || (a = i,
        n.push(i)),
        l
    }
    function c() {
        var t = e.indexOf("--\x3e", m);
        return ~t || s("expected --\x3e"),
        m = t + 2,
        l
    }
    function d() {
        var t = e.indexOf("]]>", m);
        return ~t || s("expected ]]>"),
        a.children.push(e.slice(m + 7, t)),
        m = t + 2,
        l
    }
    function p() {
        var t = f();
        return t || s("Expected tag name"),
        t !== a.tagName && s("Expected closing tag </" + t + "> to match opening tag <" + a.tagName + ">"),
        v(),
        ">" !== e[m] && s("Expected >"),
        n.pop(),
        a = n[n.length - 1],
        l
    }
    function f() {
        for (var t = ""; m < e.length && em.test(e[m]); )
            t += e[m++];
        return t
    }
    function h() {
        if (!tm.test(e[m]))
            return null;
        v();
        var t = f();
        if (!t)
            return null;
        var n = !0;
        return v(),
        "=" === e[m] && (m += 1,
        v(),
        n = nm.test(e[m]) ? function() {
            for (var t = e[m++], n = "", o = !1; m < e.length; ) {
                var a = e[m++];
                if (a === t && !o)
                    return n;
                "\\" !== a || o || (o = !0),
                n += o ? "\\" + a : a,
                o = !1
            }
        }() : function() {
            var t = "";
            do {
                var n = e[m];
                if (" " === n || ">" === n || "/" === n)
                    return t;
                t += n,
                m += 1
            } while (m < e.length);
            return t
        }(),
        isNaN(n) || "" === n.trim() || (n = +n)),
        {
            name: t,
            value: n
        }
    }
    function v() {
        for (; m < e.length && tm.test(e[m]); )
            m += 1
    }
    for (var m = i.length; m < e.length; )
        o || s("Unexpected character"),
        o = o(),
        m += 1;
    return o !== l && s("Unexpected end of input"),
    "svg" === r.tagName && (r.metadata = t),
    {
        type: "root",
        children: [r]
    }
}
function am(e, t) {
    const n = om(t).children[0]
      , {multicolor: o, pathfill: a, twotone: r, width: s, height: i, viewBox: l} = n.properties;
    if (n.properties.width = "1em",
    n.properties.height = "1em",
    n.properties.xmlns = "http://www.w3.org/2000/svg",
    void 0 === l) {
        if (void 0 === s || void 0 === i)
            throw new Error("Width and height must be set if viewBox is not set");
        n.properties.viewBox = `0 0 ${s} ${i}`
    }
    const u = function(t) {
        const {tagName: n, properties: s, children: i} = t;
        if ("true" !== o && (t.properties = function(t) {
            const {fill: n, stroke: o, style: s} = t
              , i = !r && n && !1 === ["none", "white", "#fff"].includes(n);
            if ("true" === r && void 0 === n ? t.fill = "currentColor" : (i || void 0 !== a) && (t.fill = void 0 === e.color ? "currentColor" : e.color),
            void 0 !== o && "none" !== o && (t.stroke = void 0 === e.color ? "currentColor" : e.color),
            void 0 !== s) {
                const e = s.split(";").reduce( (e, t) => {
                    let[n,o] = t.split(":");
                    return "fill" === n && "none" !== o && (o = "currentColor"),
                    "stroke" === n && "none" !== o && (o = "currentColor"),
                    e[n] = o,
                    e
                }
                , {});
                (t = {
                    ...t,
                    ...e
                }).style = ""
            }
            return t
        }(s)),
        i.length > 0) {
            const {properties: e} = t;
            return "title" === n ? gs(n, e) : gs(n, e, i.map(u))
        }
        return gs(n, t.properties)
    };
    return u(n)
}
const rm = e => am(e, '<svg width="16" height="16" fill="currentColor" class="bi bi-fire" viewBox="0 0 16 16"><path d="M8 16c3.314 0 6-2 6-5.5 0-1.5-.5-4-2.5-6 .25 1.5-1.25 2-1.25 2C11 4 9 .5 6 0c.357 2 .5 4-2 6-1.25 1-2 2.729-2 4.5C2 14 4.686 16 8 16m0-1c-1.657 0-3-1-3-2.75 0-.75.25-2 1.25-3C6.125 10 7 10.5 7 10.5c-.375-1.25.5-3.25 2-3.5-.179 1-.25 2 1 3 .625.5 1 1.364 1 2.25C11 14 9.657 15 8 15"/></svg>')
  , sm = {
    UserPin: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M19 2H5a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2h4l3 3 3-3h4a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2zm-7 3c1.727 0 3 1.272 3 3s-1.273 3-3 3c-1.726 0-3-1.272-3-3s1.274-3 3-3zM7.177 16c.558-1.723 2.496-3 4.823-3s4.266 1.277 4.823 3z"/></svg>'),
    Sad: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" pathfill="currentColor"><path fill="#212121" d="M22.002 12.002C22.002 6.478 17.524 2 12 2S2 6.478 2 12.002c0 5.523 4.477 10.001 10.001 10.001s10.002-4.478 10.002-10.001Zm-14.25-2a1.25 1.25 0 1 1 2.498 0 1.25 1.25 0 0 1-2.499 0Zm6 0a1.25 1.25 0 1 1 2.498 0 1.25 1.25 0 0 1-2.499 0ZM15.75 14h.6a.75.75 0 0 1 0 1.5h-.6c-.618 0-1.337.16-1.998.418-.669.26-1.197.588-1.472.862a.75.75 0 1 1-1.06-1.06c.475-.476 1.212-.898 1.989-1.2.784-.306 1.69-.52 2.541-.52Z"/></svg>'),
    MoneyBag: e => am(e, '<svg width="48" height="48" fill="none" viewBox="0 0 48 48"><path fill="currentColor" fill-rule="evenodd" d="M28.772 24.667A4 4 0 0 0 25 22v-1h-2v1a4 4 0 1 0 0 8v4c-.87 0-1.611-.555-1.887-1.333a1 1 0 1 0-1.885.666A4 4 0 0 0 23 36v1h2v-1a4 4 0 0 0 0-8v-4c.87 0 1.611.555 1.886 1.333a1 1 0 1 0 1.886-.666ZM23 24a2 2 0 1 0 0 4zm2 10a2 2 0 1 0 0-4z" clip-rule="evenodd"/><path fill="currentColor" fill-rule="evenodd" d="M13.153 8.621C15.607 7.42 19.633 6 24.039 6c4.314 0 8.234 1.361 10.675 2.546l.138.067c.736.364 1.33.708 1.748.987L32.906 15C41.422 23.706 48 41.997 24.039 41.997S6.479 24.038 15.069 15l-3.67-5.4c.283-.185.642-.4 1.07-.628q.318-.171.684-.35Zm17.379 6.307 2.957-4.323c-2.75.198-6.022.844-9.172 1.756-2.25.65-4.75.551-7.065.124a25 25 0 0 1-1.737-.386l1.92 2.827c4.115 1.465 8.981 1.465 13.097.002ZM16.28 16.63c4.815 1.86 10.602 1.86 15.417-.002a29.3 29.3 0 0 1 4.988 7.143c1.352 2.758 2.088 5.515 1.968 7.891-.116 2.293-1.018 4.252-3.078 5.708-2.147 1.517-5.758 2.627-11.537 2.627-5.785 0-9.413-1.091-11.58-2.591-2.075-1.437-2.986-3.37-3.115-5.632-.135-2.35.585-5.093 1.932-7.87 1.285-2.648 3.078-5.197 5.005-7.274Zm-1.15-6.714c.8.238 1.636.445 2.484.602 2.15.396 4.306.454 6.146-.079a54 54 0 0 1 6.53-1.471C28.45 8.414 26.298 8 24.038 8c-3.445 0-6.658.961-8.908 1.916Z" clip-rule="evenodd"/></svg>'),
    UserGroup: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20c0-1.657-2.239-3-5-3s-5 1.343-5 3m14-3c0-1.23-1.234-2.287-3-2.75M3 17c0-1.23 1.234-2.287 3-2.75m12-4.014a3 3 0 1 0-4-4.472m-8 4.472a3 3 0 0 1 4-4.472M12 14a3 3 0 1 1 0-6 3 3 0 0 1 0 6Z"/></svg>'),
    UserMoney: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" pathfill="currentColor"><path fill="#212121" d="M17.755 14c.78 0 1.467.397 1.87 1H13.5c-.563 0-1.082.186-1.5.5H6.253a.75.75 0 0 0-.75.75v.577c0 .535.192 1.053.54 1.46C7.138 19.57 8.777 20.303 11 20.467V21.5q0 .243.045.472c-2.677-.169-4.74-1.066-6.143-2.71a3.75 3.75 0 0 1-.898-2.435v-.578A2.25 2.25 0 0 1 6.253 14zM12 2.005a5 5 0 1 1 0 10 5 5 0 0 1 0-10Zm0 1.5a3.5 3.5 0 1 0 0 7 3.5 3.5 0 0 0 0-7ZM12 17.5a1.5 1.5 0 0 1 1.5-1.5h8a1.5 1.5 0 0 1 1.5 1.5v4a1.5 1.5 0 0 1-1.5 1.5h-8a1.5 1.5 0 0 1-1.5-1.5zm10 .5a1 1 0 0 1-1-1h-1a2 2 0 0 0 2 2zm0 2a2 2 0 0 0-2 2h1a1 1 0 0 1 1-1zm-8-3a1 1 0 0 1-1 1v1a2 2 0 0 0 2-2zm1 5a2 2 0 0 0-2-2v1a1 1 0 0 1 1 1zm4.25-2.5a1.75 1.75 0 1 0-3.5 0 1.75 1.75 0 0 0 3.5 0Z"/></svg>'),
    RoundArrow: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 6v1.79c0 .45.54.67.85.35l2.79-2.79c.2-.2.2-.51 0-.71l-2.79-2.79a.5.5 0 0 0-.85.36V4c-4.42 0-8 3.58-8 8 0 1.04.2 2.04.57 2.95.27.67 1.13.85 1.64.34.27-.27.38-.68.23-1.04C6.15 13.56 6 12.79 6 12c0-3.31 2.69-6 6-6zm5.79 2.71c-.27.27-.38.69-.23 1.04.28.7.44 1.46.44 2.25 0 3.31-2.69 6-6 6v-1.79c0-.45-.54-.67-.85-.35l-2.79 2.79c-.2.2-.2.51 0 .71l2.79 2.79a.5.5 0 0 0 .85-.35V20c4.42 0 8-3.58 8-8 0-1.04-.2-2.04-.57-2.95-.27-.67-1.13-.85-1.64-.34z"/></svg>'),
    Thunder: e => am(e, '<svg class="icon" viewBox="0 0 1024 1024" fill="currentColor"><path d="M848 359.3H627.7L825.8 109c4.1-5.3.4-13-6.3-13H436c-2.8 0-5.5 1.5-6.9 4L170 547.5c-3.1 5.3.7 12 6.9 12h174.4l-89.4 357.6c-1.9 7.8 7.5 13.3 13.3 7.7L853.5 373c5.2-4.9 1.7-13.7-5.5-13.7z"/></svg>'),
    GiftCard: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" pathfill="currentColor"><path fill="#212121" d="M9.5 19H19a3 3 0 0 0 3-3v-4.5H10.56l1.72 1.72a.75.75 0 1 1-1.06 1.06L9.5 12.56zM8 10V9q0 0 0 0a1 1 0 1 0-1 1zm1.5-1v1h1a1 1 0 1 0-1-1Zm0-2.292V4H19a3 3 0 0 1 3 3v3h-9.208A2.5 2.5 0 0 0 9.5 6.708ZM8 4v2.708A2.5 2.5 0 0 0 4.708 10H2V7a3 3 0 0 1 3-3zm0 8.56V19H5a3 3 0 0 1-3-3v-4.5h4.94l-1.72 1.72a.75.75 0 1 0 1.06 1.06z"/></svg>'),
    CoinVertical: e => am(e, '<svg fill="currentColor" viewBox="0 0 256 256"><path d="M198.51 56.09C186.44 35.4 169.92 24 152 24h-48c-17.92 0-34.44 11.4-46.51 32.09C46.21 75.42 40 101 40 128s6.21 52.58 17.49 71.91C69.56 220.6 86.08 232 104 232h48c17.92 0 34.44-11.4 46.51-32.09C209.79 180.58 216 155 216 128s-6.21-52.58-17.49-71.91Zm1.28 63.91h-32a152.8 152.8 0 0 0-9.68-48h30.59c6.12 13.38 10.16 30 11.09 48Zm-20.6-64h-28.73a83 83 0 0 0-12-16H152c10 0 19.4 6 27.19 16ZM152 216h-13.51a83 83 0 0 0 12-16h28.73C171.4 210 162 216 152 216Zm36.7-32h-30.58a152.8 152.8 0 0 0 9.68-48h32c-.94 18-4.98 34.62-11.1 48Z"/></svg>'),
    Coin: e => am(e, '<svg fill="currentColor" viewBox="0 0 256 256"><path d="M16 152h32v56H16a8 8 0 0 1-8-8v-40a8 8 0 0 1 8-8Zm188-96a28 28 0 0 0-12 2.71h0a28 28 0 1 0-16 26.58h0A28 28 0 1 0 204 56Z" opacity=".2"/><path d="M230.33 141.06a24.43 24.43 0 0 0-21.24-4.23l-41.84 9.62A28 28 0 0 0 140 112H89.94a31.82 31.82 0 0 0-22.63 9.37L44.69 144H16a16 16 0 0 0-16 16v40a16 16 0 0 0 16 16h104a8 8 0 0 0 1.94-.24l64-16a7 7 0 0 0 1.19-.4L226 182.82l.44-.2a24.6 24.6 0 0 0 3.93-41.56ZM16 160h24v40H16Zm203.43 8.21-38 16.18L119 200H56v-44.69l22.63-22.62A15.86 15.86 0 0 1 89.94 128H140a12 12 0 0 1 0 24h-28a8 8 0 0 0 0 16h32a8.3 8.3 0 0 0 1.79-.2l67-15.41.31-.08a8.6 8.6 0 0 1 6.3 15.9ZM164 96a36 36 0 0 0 5.9-.48 36 36 0 1 0 28.22-47A36 36 0 1 0 164 96Zm60-12a20 20 0 1 1-20-20 20 20 0 0 1 20 20Zm-60-44a20 20 0 0 1 19.25 14.61 36 36 0 0 0-15 24.93A20.4 20.4 0 0 1 164 80a20 20 0 0 1 0-40Z"/></svg>'),
    ClickPointer: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" pathfill="currentColor"><path fill="#212121" d="M9.25 2a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-2.5A.75.75 0 0 1 9.25 2ZM4.47 3.97a.75.75 0 0 1 1.06 0l1.75 1.75a.75.75 0 1 1-1.06 1.06L4.47 5.03a.75.75 0 0 1 0-1.06Zm9.56 0a.75.75 0 0 1 0 1.06l-1.75 1.75a.75.75 0 1 1-1.06-1.06l1.75-1.75a.75.75 0 0 1 1.06 0ZM2.5 8.75A.75.75 0 0 1 3.25 8h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Zm6 .737c0-1.127 1.322-1.735 2.177-1.001l8.461 7.252c.91.78.392 2.271-.805 2.32l-3.84.153c-.413.016-.801.2-1.077.507l-2.614 2.922c-.807.903-2.302.331-2.302-.88z"/></svg>'),
    UserPlus: e => am(e, '<svg viewBox="0 0 640 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M96 128a128 128 0 1 1 256 0 128 128 0 1 1-256 0zM0 482.3C0 383.8 79.8 304 178.3 304h91.4c98.5 0 178.3 79.8 178.3 178.3 0 16.4-13.3 29.7-29.7 29.7H29.7C13.3 512 0 498.7 0 482.3zM504 312v-64h-64c-13.3 0-24-10.7-24-24s10.7-24 24-24h64v-64c0-13.3 10.7-24 24-24s24 10.7 24 24v64h64c13.3 0 24 10.7 24 24s-10.7 24-24 24h-64v64c0 13.3-10.7 24-24 24s-24-10.7-24-24z"/></svg>'),
    User: e => am(e, '<svg viewBox="0 0 448 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M224 256a128 128 0 1 0 0-256 128 128 0 1 0 0 256zm-45.7 48C79.8 304 0 383.8 0 482.3 0 498.7 13.3 512 29.7 512h388.6c16.4 0 29.7-13.3 29.7-29.7 0-98.5-79.8-178.3-178.3-178.3z"/></svg>'),
    Help: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm1 16h-2v-2h2zm.976-4.885c-.196.158-.385.309-.535.459-.408.407-.44.777-.441.793v.133h-2v-.167c0-.118.029-1.177 1.026-2.174.195-.195.437-.393.691-.599.734-.595 1.216-1.029 1.216-1.627a1.934 1.934 0 0 0-3.867.001h-2C8.066 7.765 9.831 6 12 6s3.934 1.765 3.934 3.934c0 1.597-1.179 2.55-1.958 3.181z"/></svg>'),
    Ticket: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path fill="#0F172A" fill-rule="evenodd" d="M1.5 6.375c0-1.036.84-1.875 1.875-1.875h17.25c1.035 0 1.875.84 1.875 1.875v3.026a.75.75 0 0 1-.375.65 2.249 2.249 0 0 0 0 3.898.75.75 0 0 1 .375.65v3.026c0 1.035-.84 1.875-1.875 1.875H3.375A1.875 1.875 0 0 1 1.5 17.625v-3.026a.75.75 0 0 1 .374-.65 2.249 2.249 0 0 0 0-3.898.75.75 0 0 1-.374-.65zm15-1.125a.75.75 0 0 1 .75.75v.75a.75.75 0 0 1-1.5 0V6a.75.75 0 0 1 .75-.75Zm.75 4.5a.75.75 0 0 0-1.5 0v.75a.75.75 0 0 0 1.5 0zm-.75 3a.75.75 0 0 1 .75.75v.75a.75.75 0 0 1-1.5 0v-.75a.75.75 0 0 1 .75-.75Zm.75 4.5a.75.75 0 0 0-1.5 0V18a.75.75 0 0 0 1.5 0zM6 12a.75.75 0 0 1 .75-.75H12a.75.75 0 0 1 0 1.5H6.75A.75.75 0 0 1 6 12Zm.75 2.25a.75.75 0 0 0 0 1.5h3a.75.75 0 0 0 0-1.5z" clip-rule="evenodd"/></svg>'),
    TicketPerforated: e => am(e, '<svg width="16" height="16" fill="currentColor" class="bi bi-ticket-perforated-fill" viewBox="0 0 16 16"><path d="M0 4.5A1.5 1.5 0 0 1 1.5 3h13A1.5 1.5 0 0 1 16 4.5V6a.5.5 0 0 1-.5.5 1.5 1.5 0 0 0 0 3 .5.5 0 0 1 .5.5v1.5a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 11.5V10a.5.5 0 0 1 .5-.5 1.5 1.5 0 1 0 0-3A.5.5 0 0 1 0 6zm4-1v1h1v-1zm1 3v-1H4v1zm7 0v-1h-1v1zm-1-2h1v-1h-1zm-6 3H4v1h1zm7 1v-1h-1v1zm-7 1H4v1h1zm7 1v-1h-1v1zm-8 1v1h1v-1zm7 1h1v-1h-1z"/></svg>'),
    Gift: e => am(e, '<svg viewBox="0 0 512 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="m190.5 68.8 34.8 59.2H152c-22.1 0-40-17.9-40-40s17.9-40 40-40h2.2c14.9 0 28.8 7.9 36.3 20.8zM64 88c0 14.4 3.5 28 9.6 40H32c-17.7 0-32 14.3-32 32v64c0 17.7 14.3 32 32 32h448c17.7 0 32-14.3 32-32v-64c0-17.7-14.3-32-32-32h-41.6c6.1-12 9.6-25.6 9.6-40 0-48.6-39.4-88-88-88h-2.2c-31.9 0-61.5 16.9-77.7 44.4L256 85.5l-24.1-41C215.7 16.9 186.1 0 154.2 0H152c-48.6 0-88 39.4-88 88zm336 0c0 22.1-17.9 40-40 40h-73.3l34.8-59.2c7.6-12.9 21.4-20.8 36.3-20.8h2.2c22.1 0 40 17.9 40 40zM32 288v176c0 26.5 21.5 48 48 48h144V288zm256 224h144c26.5 0 48-21.5 48-48V288H288z"/></svg>'),
    Joystick: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="m21.986 9.74-.008-.088A5.003 5.003 0 0 0 17 5H7a4.97 4.97 0 0 0-4.987 4.737q-.014.117-.013.253v6.51c0 .925.373 1.828 1.022 2.476A3.52 3.52 0 0 0 5.5 20c1.8 0 2.504-1 3.5-3 .146-.292.992-2 3-2 1.996 0 2.853 1.707 3 2 1.004 2 1.7 3 3.5 3 .925 0 1.828-.373 2.476-1.022A3.52 3.52 0 0 0 22 16.5V10q0-.141-.014-.26zM7 12.031a2 2 0 1 1-.001-3.999A2 2 0 0 1 7 12.031zm10-5a1 1 0 1 1 0 2 1 1 0 1 1 0-2zm-2 4a1 1 0 1 1 0-2 1 1 0 1 1 0 2zm2 2a1 1 0 1 1 0-2 1 1 0 1 1 0 2zm2-2a1 1 0 1 1 0-2 1 1 0 1 1 0 2z"/></svg>'),
    Right: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m8 4 8 8-8 8"/></svg>'),
    Left: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m15 4-8 8 8 8"/></svg>'),
    Down: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m4 9 8 8 8-8"/></svg>'),
    Up: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m4 15 8-8 8 8"/></svg>'),
    Account: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 4c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6zm0 14c-2.03 0-4.43-.82-6.14-2.88a9.95 9.95 0 0 1 12.28 0C16.43 19.18 14.03 20 12 20z"/></svg>'),
    ArrowUp: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 20V4M5 11l7-7 7 7"/></svg>'),
    ArrowDown: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 20V4M5 13l7 7 7-7"/></svg>'),
    ArrowLeft: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m11 5-7 7 7 7M4 12h16"/></svg>'),
    ArrowRight: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12h16M13 5l7 7-7 7"/></svg>'),
    Close: e => am(e, '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path fill-rule="evenodd" d="M4.28 3.22a.75.75 0 0 0-1.06 1.06L6.94 8l-3.72 3.72a.75.75 0 1 0 1.06 1.06L8 9.06l3.72 3.72a.75.75 0 1 0 1.06-1.06L9.06 8l3.72-3.72a.75.75 0 0 0-1.06-1.06L8 6.94z" clip-rule="evenodd"/></svg>'),
    Loading: e => am(e, '<svg width="24" height="24"><g fill="none" fill-rule="evenodd"><path d="M24 0v24H0V0zM12.593 23.258l-.011.002-.071.035-.02.004-.014-.004-.071-.035q-.016-.005-.024.005l-.004.01-.017.428.005.02.01.013.104.074.015.004.012-.004.104-.074.012-.016.004-.017-.017-.427q-.004-.016-.017-.018m.265-.113-.013.002-.185.093-.01.01-.003.011.018.43.005.012.008.007.201.093q.019.005.029-.008l.004-.014-.034-.614q-.005-.018-.02-.022m-.715.002a.02.02 0 0 0-.027.006l-.006.014-.034.614q.001.018.017.024l.015-.002.201-.093.01-.008.004-.011.017-.43-.003-.012-.01-.01z"/><path fill="#09244B" d="M12 4.5a7.5 7.5 0 1 0 0 15 7.5 7.5 0 0 0 0-15M1.5 12C1.5 6.201 6.201 1.5 12 1.5S22.5 6.201 22.5 12 17.799 22.5 12 22.5 1.5 17.799 1.5 12" opacity=".1"/><path fill="#09244B" d="M12 4.5a7.46 7.46 0 0 0-5.187 2.083 1.5 1.5 0 0 1-2.075-2.166A10.46 10.46 0 0 1 12 1.5a1.5 1.5 0 0 1 0 3"/></g></svg>'),
    Lock: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9zm4 10.723V20h-2v-2.277a1.993 1.993 0 0 1 .567-3.677A2 2 0 0 1 14 16a1.99 1.99 0 0 1-1 1.723z"/></svg>'),
    Truck: e => am(e, '<svg viewBox="0 0 640 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M112 0C85.5 0 64 21.5 64 48v48H16c-8.8 0-16 7.2-16 16s7.2 16 16 16h256c8.8 0 16 7.2 16 16s-7.2 16-16 16H48c-8.8 0-16 7.2-16 16s7.2 16 16 16h192c8.8 0 16 7.2 16 16s-7.2 16-16 16H16c-8.8 0-16 7.2-16 16s7.2 16 16 16h192c8.8 0 16 7.2 16 16s-7.2 16-16 16H64v128c0 53 43 96 96 96s96-43 96-96h128c0 53 43 96 96 96s96-43 96-96h32c17.7 0 32-14.3 32-32s-14.3-32-32-32V237.3c0-17-6.7-33.3-18.7-45.3L512 114.7c-12-12-28.3-18.7-45.3-18.7H416V48c0-26.5-21.5-48-48-48zm432 237.3V256H416v-96h50.7zM160 368a48 48 0 1 1 0 96 48 48 0 1 1 0-96zm272 48a48 48 0 1 1 96 0 48 48 0 1 1-96 0z"/></svg>'),
    Mail: e => am(e, '<svg width="48" height="48" fill="none" viewBox="0 0 48 48" pathfill="currentColor"><path fill="#212121" d="M4.02 13.747A6.25 6.25 0 0 1 10.25 8h27.5a6.25 6.25 0 0 1 6.236 5.828L24.002 24.35zM4 16.567V33.75A6.25 6.25 0 0 0 10.25 40h27.5A6.25 6.25 0 0 0 44 33.75V16.646L24.582 26.87a1.25 1.25 0 0 1-1.168-.002z"/></svg>'),
    Person: e => am(e, '<svg width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16"><path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6"/></svg>'),
    People: e => am(e, '<svg width="16" height="16" fill="currentColor" class="bi bi-people-fill" viewBox="0 0 16 16"><path d="M7 14s-1 0-1-1 1-4 5-4 5 3 5 4-1 1-1 1zm4-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6m-5.784 6A2.24 2.24 0 0 1 5 13c0-1.355.68-2.75 1.936-3.72A6.3 6.3 0 0 0 5 9c-4 0-5 3-5 4s1 1 1 1zM4.5 8a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5"/></svg>'),
    Home: e => am(e, '<svg width="512" height="512" viewBox="0 0 512 512" fill="currentColor"><path d="M416 174.74V48h-80v58.45L256 32 0 272h64v208h144V320h96v160h144V272h64z"/></svg>'),
    Deposit: e => am(e, '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 12a3 3 0 1 0 3 3 3 3 0 0 0-3-3Zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1Zm-.71-6.29a1 1 0 0 0 .33.21.94.94 0 0 0 .76 0 1 1 0 0 0 .33-.21L15 7.46A1 1 0 1 0 13.54 6l-.54.59V3a1 1 0 0 0-2 0v3.59L10.46 6A1 1 0 0 0 9 7.46ZM19 15a1 1 0 1 0-1 1 1 1 0 0 0 1-1Zm1-7h-3a1 1 0 0 0 0 2h3a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1v-8a1 1 0 0 1 1-1h3a1 1 0 0 0 0-2H4a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h16a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3ZM5 15a1 1 0 1 0 1-1 1 1 0 0 0-1 1Z"/></svg>'),
    Withdraw: e => am(e, '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M22 2H2a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h3v9a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-9h3a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1ZM7 20v-2a2 2 0 0 1 2 2Zm10 0h-2a2 2 0 0 1 2-2Zm0-4a4 4 0 0 0-4 4h-2a4 4 0 0 0-4-4V8h10Zm4-6h-2V7a1 1 0 0 0-1-1H6a1 1 0 0 0-1 1v3H3V4h18Zm-9 5a3 3 0 1 0-3-3 3 3 0 0 0 3 3Zm0-4a1 1 0 1 1-1 1 1 1 0 0 1 1-1Z"/></svg>'),
    Transfer: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" pathfill="currentColor"><path fill="#212121" d="M12 8a4 4 0 1 1-8 0 4 4 0 0 1 8 0Zm8 1a3 3 0 1 1-6 0 3 3 0 0 1 6 0ZM2 16.25A2.25 2.25 0 0 1 4.25 14h7.5c.37 0 .72.09 1.027.248l-2.264 2.265a1.75 1.75 0 0 0 0 2.474l1.186 1.187C10.833 20.664 9.641 21 8 21c-6 0-6-4.5-6-4.5zm18.28-1.53a.75.75 0 0 0-1.06 1.06L20.44 17h-6.88l1.22-1.22a.75.75 0 0 0-1.06-1.06l-2.5 2.5a.75.75 0 0 0 0 1.06l2.5 2.5a.75.75 0 0 0 1.06-1.06l-1.22-1.22h6.88l-1.22 1.22a.75.75 0 0 0 1.06 1.06l2.5-2.5a.75.75 0 0 0 0-1.06z"/></svg>'),
    MoneyTransfer: e => am(e, '<svg viewBox="0 0 640 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M535 41c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l64 64c4.5 4.5 7 10.6 7 17s-2.5 12.5-7 17l-64 64c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l23-23-174-.2c-13.3 0-24-10.7-24-24s10.7-24 24-24h174.1zM105 377l-23 23h174c13.3 0 24 10.7 24 24s-10.7 24-24 24H81.9l23 23c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0L7 441c-4.5-4.5-7-10.6-7-17s2.5-12.5 7-17l64-64c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9zM96 64h241.9c-3.7 7.2-5.9 15.3-5.9 24 0 28.7 23.3 52 52 52h117.4c-4 17 .6 35.5 13.8 48.8 20.3 20.3 53.2 20.3 73.5 0l19.3-19.3V384c0 35.3-28.7 64-64 64H302.1c3.7-7.2 5.9-15.3 5.9-24 0-28.7-23.3-52-52-52H138.6c4-17-.6-35.5-13.8-48.8-20.3-20.3-53.2-20.3-73.5 0L32 342.5V128c0-35.3 28.7-64 64-64zm64 64H96v64c35.3 0 64-28.7 64-64zm384 192c-35.3 0-64 28.7-64 64h64zm-224 32a96 96 0 1 0 0-192 96 96 0 1 0 0 192z"/></svg>'),
    MoneyPlus: e => am(e, '<svg fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18 15v3m0 3v-3m0 0h-3m3 0h3"/><path fill="currentColor" fill-rule="evenodd" d="M5 5a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h7.083A6 6 0 0 1 12 18c0-1.148.322-2.22.881-3.131A3 3 0 0 1 9 12a3 3 0 1 1 5.869.881A5.97 5.97 0 0 1 18 12c1.537 0 2.939.578 4 1.528V8a3 3 0 0 0-3-3zm7 6a1 1 0 1 0 0 2 1 1 0 0 0 0-2z" clip-rule="evenodd"/></svg>'),
    Split: e => am(e, '<svg viewBox="0 0 512 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M246.6 150.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l96-96c12.5-12.5 32.8-12.5 45.3 0l96 96c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L352 109.3V384c0 35.3 28.7 64 64 64h64c17.7 0 32 14.3 32 32s-14.3 32-32 32h-64c-70.7 0-128-57.3-128-128 0-35.3-28.7-64-64-64H109.3l41.4 41.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0l-96-96c-12.5-12.5-12.5-32.8 0-45.3l96-96c12.5-12.5 32.8-12.5 45.3 0s12.5 32.8 0 45.3L109.3 256H224c23.3 0 45.2 6.2 64 17.1V109.2z"/></svg>'),
    Asterisk: e => am(e, '<svg width="16" height="16" fill="currentColor" class="bi bi-asterisk" viewBox="0 0 16 16"><path d="M8 0a1 1 0 0 1 1 1v5.268l4.562-2.634a1 1 0 1 1 1 1.732L10 8l4.562 2.634a1 1 0 1 1-1 1.732L9 9.732V15a1 1 0 1 1-2 0V9.732l-4.562 2.634a1 1 0 1 1-1-1.732L6 8 1.438 5.366a1 1 0 0 1 1-1.732L7 6.268V1a1 1 0 0 1 1-1"/></svg>'),
    Document: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path fill="#0F172A" fill-rule="evenodd" d="M4.5 3.75a3 3 0 0 0-3 3v10.5a3 3 0 0 0 3 3h15a3 3 0 0 0 3-3V6.75a3 3 0 0 0-3-3zm4.125 3a2.25 2.25 0 1 0 0 4.5 2.25 2.25 0 0 0 0-4.5Zm-3.873 8.703a4.126 4.126 0 0 1 7.746 0 .75.75 0 0 1-.351.92 7.5 7.5 0 0 1-3.522.877 7.5 7.5 0 0 1-3.522-.877.75.75 0 0 1-.351-.92ZM15 8.25a.75.75 0 0 0 0 1.5h3.75a.75.75 0 0 0 0-1.5zM14.25 12a.75.75 0 0 1 .75-.75h3.75a.75.75 0 0 1 0 1.5H15a.75.75 0 0 1-.75-.75Zm.75 2.25a.75.75 0 0 0 0 1.5h3.75a.75.75 0 0 0 0-1.5z" clip-rule="evenodd"/></svg>'),
    Phone: e => am(e, '<svg viewBox="0 0 32 32" fill="currentColor"><path d="m20.33 21.48 2.24-2.24a2.19 2.19 0 0 1 2.34-.48l2.73 1.09a2.18 2.18 0 0 1 1.36 2v5A2.17 2.17 0 0 1 26.72 29C7.59 27.81 3.73 11.61 3 5.41A2.17 2.17 0 0 1 5.17 3H10a2.16 2.16 0 0 1 2 1.36l1.09 2.73a2.16 2.16 0 0 1-.47 2.34l-2.24 2.24s1.29 8.73 9.95 9.81Z"/><path d="M0 0h32v32H0z" style="fill:none"/></svg>'),
    Location: e => am(e, '<svg viewBox="0 0 384 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M215.7 499.2C267 435 384 279.4 384 192 384 86 298 0 192 0S0 86 0 192c0 87.4 117 243 168.3 307.2 12.3 15.3 35.1 15.3 47.4 0zM192 128a64 64 0 1 1 0 128 64 64 0 1 1 0-128z"/></svg>'),
    Filter: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 3h16a1 1 0 0 1 1 1v1.586a1 1 0 0 1-.293.707l-6.414 6.414a1 1 0 0 0-.293.707v6.305a1 1 0 0 1-1.242.97l-2-.5a1 1 0 0 1-.758-.97v-5.805a1 1 0 0 0-.293-.707L3.293 6.293A1 1 0 0 1 3 5.586V4a1 1 0 0 1 1-1Z"/></svg>'),
    CashBag: e => am(e, '<svg width="48" height="48" fill="none" viewBox="0 0 48 48"><path fill="currentColor" fill-rule="evenodd" d="M24.039 6c-4.517 0-8.632 1.492-11.067 2.711q-.33.165-.616.322c-.378.206-.7.398-.956.567l2.77 4.078 1.304.519c5.096 2.571 11.93 2.571 17.027 0l1.48-.768L36.6 9.6a16 16 0 0 0-1.689-.957C32.488 7.437 28.471 6 24.04 6Zm-6.442 4.616a25 25 0 0 1-2.901-.728c2.281-1.013 5.68-2.088 9.343-2.088 2.537 0 4.936.516 6.92 1.17-2.325.327-4.806.882-7.17 1.565-1.86.538-4.034.48-6.192.081Zm15.96 5.064-.246.124c-5.606 2.828-13.042 2.828-18.648 0l-.233-.118C6.008 24.927-.422 41.997 24.039 41.997S41.913 24.61 33.557 15.68ZM23 24a2 2 0 1 0 0 4zm2-2v-1h-2v1a4 4 0 0 0 0 8v4c-.87 0-1.611-.555-1.887-1.333a1 1 0 1 0-1.885.666A4 4 0 0 0 23 36v1h2v-1a4 4 0 0 0 0-8v-4c.87 0 1.611.555 1.887 1.333a1 1 0 1 0 1.885-.666A4 4 0 0 0 25 22Zm0 8v4a2 2 0 1 0 0-4Z" clip-rule="evenodd"/></svg>'),
    Wallet: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2 6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6ZM2 8h20"/><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2 12h7c0 1 .6 3 3 3s3-2 3-3h7"/></svg>'),
    ListCount: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" pathfill="currentColor"><path fill="#212121" d="M2 5.75A.75.75 0 0 1 2.75 5h18.5a.75.75 0 0 1 0 1.5H2.75A.75.75 0 0 1 2 5.75Zm0 6.5a.75.75 0 0 1 .75-.75h18.5a.75.75 0 0 1 0 1.5H2.75a.75.75 0 0 1-.75-.75Zm17 6.5a.75.75 0 0 1 .75-.75h1.5a.75.75 0 0 1 0 1.5h-1.5a.75.75 0 0 1-.75-.75Zm-16.584-.012c.21-.14.415-.3.607-.475v3.987a.75.75 0 0 0 1.5 0v-6.5a.75.75 0 0 0-1.483-.16c-.126.578-.692 1.39-1.456 1.9a.75.75 0 0 0 .832 1.248ZM8 17.523c0-.528.444-1.023.986-1.023.407 0 .735.19.893.434.136.21.218.566-.093 1.095-.15.255-.376.482-.682.724-.152.12-.316.237-.493.363l-.074.052c-.152.107-.315.222-.472.34-.744.56-1.565 1.346-1.565 2.742 0 .414.336.75.75.75h3.451a.75.75 0 0 0 0-1.5H8.188c.16-.282.423-.525.779-.793.137-.103.279-.203.432-.312l.078-.054c.178-.127.37-.264.557-.41.372-.295.76-.658 1.045-1.142.557-.948.546-1.921.057-2.672C10.67 15.4 9.842 15 8.987 15 7.508 15 6.5 16.278 6.5 17.523a.75.75 0 0 0 1.5 0Zm6.471-.385a.86.86 0 0 1 .251-.397c.128-.113.356-.241.778-.241.761 0 1 .5 1 .727 0 .245-.052.49-.19.664-.111.14-.378.359-1.102.359a.75.75 0 0 0 0 1.5c.274 0 .652.036.935.17a.65.65 0 0 1 .264.2c.045.064.093.167.093.357 0 .488-.152.704-.28.812-.152.128-.396.211-.72.211-.362 0-.567-.063-.693-.142-.11-.07-.24-.204-.345-.524a.75.75 0 0 0-1.424.469c.186.566.495 1.023.967 1.322.458.29.982.375 1.495.375.551 0 1.182-.138 1.687-.565.528-.445.813-1.116.813-1.958 0-.474-.13-.888-.371-1.227a2 2 0 0 0-.258-.294 2 2 0 0 0 .113-.132c.438-.55.516-1.192.516-1.597C18 16.154 17.072 15 15.5 15c-.765 0-1.351.247-1.77.616-.405.357-.61.789-.701 1.11a.75.75 0 1 0 1.442.412Z"/></svg>'),
    Terminal: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M20 4H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zM6.414 15.707 5 14.293 7.293 12 5 9.707l1.414-1.414L10.121 12zM19 16h-7v-2h7z"/></svg>'),
    Search: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m15 15 6 6m-11-4a7 7 0 1 1 0-14 7 7 0 0 1 0 14Z"/></svg>'),
    Bell: e => am(e, '<svg viewBox="0 0 448 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M224 0c-17.7 0-32 14.3-32 32v19.2C119 66 64 130.6 64 208v18.8c0 47-17.3 92.4-48.5 127.6l-7.4 8.3c-8.4 9.4-10.4 22.9-5.3 34.4S19.4 416 32 416h384c12.6 0 24-7.4 29.2-18.9s3.1-25-5.3-34.4l-7.4-8.3c-31.2-35.2-48.5-80.5-48.5-127.6V208c0-77.4-55-142-128-156.8V32c0-17.7-14.3-32-32-32zm45.3 493.3c12-12 18.7-28.3 18.7-45.3H160c0 17 6.7 33.3 18.7 45.3S207 512 224 512s33.3-6.7 45.3-18.7z"/></svg>'),
    BellSlash: e => am(e, '<svg viewBox="0 0 640 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2s-6.3 25.5 4.1 33.7l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7l-90.2-70.7c.2-.4.4-.9.6-1.3 5.2-11.5 3.1-25-5.3-34.4l-7.4-8.3c-31.2-35.2-48.5-80.5-48.5-127.6V208c0-77.4-55-142-128-156.8V32c0-17.7-14.3-32-32-32s-32 14.3-32 32v19.2c-42.6 8.6-79 34.2-102 69.3zM406.2 416 160 222.1v4.8c0 47-17.3 92.4-48.5 127.6l-7.4 8.3c-8.4 9.4-10.4 22.9-5.3 34.4S115.4 416 128 416zm-40.9 77.3c12-12 18.7-28.3 18.7-45.3H256c0 17 6.7 33.3 18.7 45.3S303 512 320 512s33.3-6.7 45.3-18.7z"/></svg>'),
    Settings: e => am(e, '<svg width="512" height="512" viewBox="0 0 512 512" fill="currentColor"><path d="M256 176a80 80 0 1 0 80 80 80.24 80.24 0 0 0-80-80Zm172.72 80a165.5 165.5 0 0 1-1.64 22.34l48.69 38.12a11.59 11.59 0 0 1 2.63 14.78l-46.06 79.52a11.64 11.64 0 0 1-14.14 4.93l-57.25-23a176.6 176.6 0 0 1-38.82 22.67l-8.56 60.78a11.93 11.93 0 0 1-11.51 9.86h-92.12a12 12 0 0 1-11.51-9.53l-8.56-60.78A169.3 169.3 0 0 1 151.05 393L93.8 416a11.64 11.64 0 0 1-14.14-4.92L33.6 331.57a11.59 11.59 0 0 1 2.63-14.78l48.69-38.12A175 175 0 0 1 83.28 256a165.5 165.5 0 0 1 1.64-22.34l-48.69-38.12a11.59 11.59 0 0 1-2.63-14.78l46.06-79.52a11.64 11.64 0 0 1 14.14-4.93l57.25 23a176.6 176.6 0 0 1 38.82-22.67l8.56-60.78A11.93 11.93 0 0 1 209.94 26h92.12a12 12 0 0 1 11.51 9.53l8.56 60.78A169.3 169.3 0 0 1 361 119l57.2-23a11.64 11.64 0 0 1 14.14 4.92l46.06 79.52a11.59 11.59 0 0 1-2.63 14.78l-48.69 38.12a175 175 0 0 1 1.64 22.66Z"/></svg>'),
    Moon: e => am(e, '<svg width="24" height="24" fill="none" stroke-width="1.5" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke="currentColor"/><path stroke="currentColor" d="M7.633 3.067A3.001 3.001 0 1 1 4.017 6.32M22 13.05a3.5 3.5 0 1 0-3 5.914"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m14.5 8.51.01-.011M10 17a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"/></svg>'),
    Sun: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path fill="#000" d="M12 7a5 5 0 1 0 0 10 5 5 0 0 0 0-10Z"/><path fill="#000" fill-rule="evenodd" d="M12 1a1 1 0 0 1 1 1v1a1 1 0 1 1-2 0V2a1 1 0 0 1 1-1ZM3.293 3.293a1 1 0 0 1 1.414 0l1.5 1.5a1 1 0 0 1-1.414 1.414l-1.5-1.5a1 1 0 0 1 0-1.414Zm17.414 0a1 1 0 0 1 0 1.414l-1.5 1.5a1 1 0 1 1-1.414-1.414l1.5-1.5a1 1 0 0 1 1.414 0ZM1 12a1 1 0 0 1 1-1h1a1 1 0 1 1 0 2H2a1 1 0 0 1-1-1Zm19 0a1 1 0 0 1 1-1h1a1 1 0 1 1 0 2h-1a1 1 0 0 1-1-1ZM6.207 17.793a1 1 0 0 1 0 1.414l-1.5 1.5a1 1 0 0 1-1.414-1.414l1.5-1.5a1 1 0 0 1 1.414 0Zm11.586 0a1 1 0 0 1 1.414 0l1.5 1.5a1 1 0 0 1-1.414 1.414l-1.5-1.5a1 1 0 0 1 0-1.414ZM12 20a1 1 0 0 1 1 1v1a1 1 0 1 1-2 0v-1a1 1 0 0 1 1-1Z" clip-rule="evenodd"/></svg>'),
    Trending: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" pathfill="currentColor"><path fill="#212121" d="M14.003 5.5H21a1 1 0 0 1 .993.883L22 6.5v7a1 1 0 0 1-1.994.117L20 13.5l-.001-4.586-7.292 7.293a1 1 0 0 1-1.32.084l-.094-.083-2.296-2.292-5.288 5.29a1 1 0 0 1-1.497-1.32l.083-.095 5.994-5.996a1 1 0 0 1 1.32-.084l.094.083 2.296 2.292L18.584 7.5h-4.581a1 1 0 0 1-.993-.883l-.007-.117a1 1 0 0 1 .883-.993zH21z"/></svg>'),
    HistoryClock: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.266 16.06a8.92 8.92 0 0 0 3.915 3.978 8.7 8.7 0 0 0 5.471.832 8.8 8.8 0 0 0 4.887-2.64 9.07 9.07 0 0 0 2.388-5.079 9.14 9.14 0 0 0-1.044-5.53 8.9 8.9 0 0 0-4.069-3.815 8.7 8.7 0 0 0-5.5-.608c-1.85.401-3.366 1.313-4.62 2.755-.151.16-.735.806-1.22 1.781M7.5 8l-3.609.72L3 5m9 4v4l3 2"/></svg>'),
    HamburguerMenu: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path fill="currentColor" d="M2 6a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1ZM2 12.032a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1ZM3 17.065a1 1 0 1 0 0 2h18a1 1 0 0 0 0-2z"/></svg>'),
    Pix: e => am(e, '<svg viewBox="0 0 512 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M242.4 292.5c5.4-5.4 14.7-5.4 20.1 0l77 77c14.2 14.2 33.1 22 53.1 22h15.1l-97.1 97.1c-30.3 29.5-79.5 29.5-109.8 0l-97.5-97.4h9.3c20 0 38.9-7.8 53.1-22zm20.1-73.6c-6.4 5.5-14.6 5.6-20.1 0l-76.7-76.7c-14.2-15.1-33.1-22-53.1-22h-9.3l97.4-97.44c30.4-30.346 79.6-30.346 109.9 0l97.2 97.14h-15.2c-20 0-38.9 7.8-53.1 22zm-149.9-76.2c13.8 0 26.5 5.6 37.1 15.4l76.7 76.7c7.2 6.3 16.6 10.8 26.1 10.8 9.4 0 18.8-4.5 26-10.8l77-77c9.8-9.7 23.3-15.3 37.1-15.3h37.7l58.3 58.3c30.3 30.3 30.3 79.5 0 109.8l-58.3 58.3h-37.7c-13.8 0-27.3-5.6-37.1-15.4l-77-77c-13.9-13.9-38.2-13.9-52.1.1l-76.7 76.6c-10.6 9.8-23.3 15.4-37.1 15.4H80.78l-58.02-58c-30.346-30.3-30.346-79.5 0-109.8l58.02-58.1z"/></svg>'),
    Check: e => am(e, '<svg width="16" height="16" fill="currentColor" class="bi bi-check-lg" viewBox="0 0 16 16"><path d="M12.736 3.97a.733.733 0 0 1 1.047 0c.286.289.29.756.01 1.05L7.88 12.01a.733.733 0 0 1-1.065.02L3.217 8.384a.757.757 0 0 1 0-1.06.733.733 0 0 1 1.047 0l3.052 3.093 5.4-6.425z"/></svg>'),
    Clock: e => am(e, '<svg viewBox="0 0 512 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M464 256a208 208 0 1 1-416 0 208 208 0 1 1 416 0zM0 256a256 256 0 1 0 512 0 256 256 0 1 0-512 0zm232-136v136c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/></svg>'),
    Return: e => am(e, '<svg fill="currentColor" viewBox="0 0 24 24"><path d="m5.828 7 2.536 2.535L6.95 10.95 2 6l4.95-4.95 1.414 1.415L5.828 5H13a8 8 0 1 1 0 16H4v-2h9a6 6 0 0 0 0-12z"/></svg>'),
    Calendar: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><rect width="20" height="18" x="2" y="4" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" rx="4"/><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 2v4M16 2v4M2 10h20"/></svg>'),
    Instagram: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path fill="#000" fill-rule="evenodd" d="M7.465 1.066C8.638 1.012 9.012 1 12 1s3.362.013 4.534.066 1.972.24 2.672.511c.733.277 1.398.71 1.948 1.27.56.549.992 1.213 1.268 1.947.272.7.458 1.5.512 2.67C22.988 8.639 23 9.013 23 12s-.013 3.362-.066 4.535c-.053 1.17-.24 1.97-.512 2.67a5.4 5.4 0 0 1-1.268 1.949c-.55.56-1.215.992-1.948 1.268-.7.272-1.5.458-2.67.512-1.174.054-1.548.066-4.536.066s-3.362-.013-4.535-.066c-1.17-.053-1.97-.24-2.67-.512a5.4 5.4 0 0 1-1.949-1.268 5.4 5.4 0 0 1-1.269-1.948c-.271-.7-.457-1.5-.511-2.67C1.012 15.361 1 14.987 1 12s.013-3.362.066-4.534.24-1.972.511-2.672a5.4 5.4 0 0 1 1.27-1.948 5.4 5.4 0 0 1 1.947-1.269c.7-.271 1.5-.457 2.67-.511Zm8.98 1.98c-1.16-.053-1.508-.064-4.445-.064s-3.285.011-4.445.064c-1.073.049-1.655.228-2.043.379-.513.2-.88.437-1.265.822a3.4 3.4 0 0 0-.822 1.265c-.151.388-.33.97-.379 2.043-.053 1.16-.064 1.508-.064 4.445s.011 3.285.064 4.445c.049 1.073.228 1.655.379 2.043.176.477.457.91.822 1.265.355.365.788.646 1.265.822.388.151.97.33 2.043.379 1.16.053 1.507.064 4.445.064s3.285-.011 4.445-.064c1.073-.049 1.655-.228 2.043-.379.513-.2.88-.437 1.265-.822.365-.355.646-.788.822-1.265.151-.388.33-.97.379-2.043.053-1.16.064-1.508.064-4.445s-.011-3.285-.064-4.445c-.049-1.073-.228-1.655-.379-2.043-.2-.513-.437-.88-.822-1.265a3.4 3.4 0 0 0-1.265-.822c-.388-.151-.97-.33-2.043-.379Zm-5.85 12.345a3.669 3.669 0 0 0 4-5.986 3.67 3.67 0 1 0-4 5.986ZM8.002 8.002a5.654 5.654 0 1 1 7.996 7.996 5.654 5.654 0 0 1-7.996-7.996Zm10.906-.814a1.337 1.337 0 1 0-1.89-1.89 1.337 1.337 0 0 0 1.89 1.89Z" clip-rule="evenodd"/></svg>'),
    WhatsApp: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><g clip-path="url(#a)"><path fill="#000" fill-rule="evenodd" d="M17.415 14.382c-.298-.149-1.759-.867-2.031-.967s-.47-.148-.669.15c-.198.297-.767.966-.94 1.164-.174.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.019-.458.13-.606.134-.133.297-.347.446-.52s.198-.298.297-.497c.1-.198.05-.371-.025-.52-.074-.149-.668-1.612-.916-2.207-.241-.579-.486-.5-.668-.51-.174-.008-.372-.01-.57-.01s-.52.074-.792.372c-.273.297-1.04 1.016-1.04 2.479 0 1.462 1.064 2.875 1.213 3.074s2.095 3.2 5.076 4.487c.71.306 1.263.489 1.694.625.712.227 1.36.195 1.872.118.57-.085 1.758-.719 2.006-1.413s.247-1.289.173-1.413-.272-.198-.57-.347Zm-5.422 7.403h-.004a9.87 9.87 0 0 1-5.032-1.378l-.36-.214-3.742.982.999-3.648-.235-.374a9.86 9.86 0 0 1-1.511-5.26c.002-5.45 4.436-9.884 9.889-9.884 2.64 0 5.122 1.03 6.988 2.899a9.82 9.82 0 0 1 2.892 6.992c-.002 5.45-4.436 9.885-9.884 9.885Zm8.412-18.297A11.82 11.82 0 0 0 11.992 0C5.438 0 .102 5.335.1 11.892c-.001 2.096.546 4.142 1.587 5.945L0 24l6.304-1.654a11.9 11.9 0 0 0 5.684 1.448h.005c6.554 0 11.89-5.335 11.892-11.893a11.82 11.82 0 0 0-3.48-8.413" clip-rule="evenodd"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h24v24H0z"/></clipPath></defs></svg>'),
    Discord: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path fill="#000" d="M20.317 4.492c-1.53-.69-3.17-1.2-4.885-1.49a.075.075 0 0 0-.079.036c-.21.369-.444.85-.608 1.23a18.6 18.6 0 0 0-5.487 0 12 12 0 0 0-.617-1.23A.08.08 0 0 0 8.562 3c-1.714.29-3.354.8-4.885 1.491a.1.1 0 0 0-.032.027C.533 9.093-.32 13.555.099 17.961a.08.08 0 0 0 .031.055 20 20 0 0 0 5.993 2.98.08.08 0 0 0 .084-.026c.462-.62.874-1.275 1.226-1.963.021-.04.001-.088-.041-.104a13 13 0 0 1-1.872-.878.075.075 0 0 1-.008-.125q.19-.14.372-.287a.08.08 0 0 1 .078-.01c3.927 1.764 8.18 1.764 12.061 0a.08.08 0 0 1 .079.009q.18.148.372.288a.075.075 0 0 1-.006.125q-.895.515-1.873.877a.075.075 0 0 0-.041.105c.36.687.772 1.341 1.225 1.962a.08.08 0 0 0 .084.028 20 20 0 0 0 6.002-2.981.08.08 0 0 0 .032-.054c.5-5.094-.838-9.52-3.549-13.442a.06.06 0 0 0-.031-.028ZM8.02 15.278c-1.182 0-2.157-1.069-2.157-2.38 0-1.312.956-2.38 2.157-2.38 1.21 0 2.176 1.077 2.157 2.38 0 1.312-.956 2.38-2.157 2.38Zm7.975 0c-1.183 0-2.157-1.069-2.157-2.38 0-1.312.955-2.38 2.157-2.38 1.21 0 2.176 1.077 2.157 2.38 0 1.312-.946 2.38-2.157 2.38Z"/></svg>'),
    GitHub: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><g clip-path="url(#a)"><path fill="#000" fill-rule="evenodd" d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0 0 24 12c0-6.63-5.37-12-12-12Z" clip-rule="evenodd"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h24v24H0z"/></clipPath></defs></svg>'),
    QrCode: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" pathfill="currentColor"><path fill="#212121" d="M8 6H6v2h2zm-5-.75A2.25 2.25 0 0 1 5.25 3h3.5A2.25 2.25 0 0 1 11 5.25v3.5A2.25 2.25 0 0 1 8.75 11h-3.5A2.25 2.25 0 0 1 3 8.75zm2.25-.75a.75.75 0 0 0-.75.75v3.5c0 .414.336.75.75.75h3.5a.75.75 0 0 0 .75-.75v-3.5a.75.75 0 0 0-.75-.75zM6 16h2v2H6zm-3-.75A2.25 2.25 0 0 1 5.25 13h3.5A2.25 2.25 0 0 1 11 15.25v3.5A2.25 2.25 0 0 1 8.75 21h-3.5A2.25 2.25 0 0 1 3 18.75zm2.25-.75a.75.75 0 0 0-.75.75v3.5c0 .414.336.75.75.75h3.5a.75.75 0 0 0 .75-.75v-3.5a.75.75 0 0 0-.75-.75zM18 6h-2v2h2zm-2.75-3A2.25 2.25 0 0 0 13 5.25v3.5A2.25 2.25 0 0 0 15.25 11h3.5A2.25 2.25 0 0 0 21 8.75v-3.5A2.25 2.25 0 0 0 18.75 3zm-.75 2.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-.75.75h-3.5a.75.75 0 0 1-.75-.75zM13 13h2.75v2.75H13zm5.25 2.75h-2.5v2.5H13V21h2.75v-2.75h2.5V21H21v-2.75h-2.75zm0 0V13H21v2.75z"/></svg>'),
    Info: e => am(e, '<svg width="16" height="16" fill="currentColor" class="bi bi-info-circle-fill" viewBox="0 0 16 16"><path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.93-9.412-1 4.705c-.07.34.029.533.304.533.194 0 .487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703 0-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381 2.29-.287zM8 5.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2"/></svg>'),
    Copy: e => am(e, '<svg viewBox="0 0 448 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M384 336H192c-8.8 0-16-7.2-16-16V64c0-8.8 7.2-16 16-16h140.1l67.9 67.9V320c0 8.8-7.2 16-16 16zm-192 48h192c35.3 0 64-28.7 64-64V115.9c0-12.7-5.1-24.9-14.1-33.9l-67.8-67.9c-9-9-21.2-14.1-33.9-14.1H192c-35.3 0-64 28.7-64 64v256c0 35.3 28.7 64 64 64zM64 128c-35.3 0-64 28.7-64 64v256c0 35.3 28.7 64 64 64h192c35.3 0 64-28.7 64-64v-32h-48v32c0 8.8-7.2 16-16 16H64c-8.8 0-16-7.2-16-16V192c0-8.8 7.2-16 16-16h32v-48z"/></svg>'),
    Download: e => am(e, '<svg width="24" height="24"><g fill="none"><path d="M24 0v24H0V0zM12.593 23.258l-.011.002-.071.035-.02.004-.014-.004-.071-.035q-.016-.005-.024.005l-.004.01-.017.428.005.02.01.013.104.074.015.004.012-.004.104-.074.012-.016.004-.017-.017-.427q-.004-.016-.017-.018m.265-.113-.013.002-.185.093-.01.01-.003.011.018.43.005.012.008.007.201.093q.019.005.029-.008l.004-.014-.034-.614q-.005-.018-.02-.022m-.715.002a.02.02 0 0 0-.027.006l-.006.014-.034.614q.001.018.017.024l.015-.002.201-.093.01-.008.004-.011.017-.43-.003-.012-.01-.01z"/><path fill="#09244B" d="M8 5v2H5v13h14V7h-3V5h3a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2zm4-3a1 1 0 0 1 1 1v10.828L14.828 12a1 1 0 1 1 1.415 1.414l-3.36 3.359a1.25 1.25 0 0 1-1.767 0l-3.359-3.359A1 1 0 1 1 9.172 12L11 13.828V3a1 1 0 0 1 1-1"/></g></svg>'),
    Pdf: e => am(e, '<svg viewBox="0 0 512 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M64 464h48v48H64c-35.3 0-64-28.7-64-64V64C0 28.7 28.7 0 64 0h165.5c17 0 33.3 6.7 45.3 18.7l90.5 90.5c12 12 18.7 28.3 18.7 45.3V304h-48V160h-80c-17.7 0-32-14.3-32-32V48H64c-8.8 0-16 7.2-16 16v384c0 8.8 7.2 16 16 16zm112-112h32c30.9 0 56 25.1 56 56s-25.1 56-56 56h-16v32c0 8.8-7.2 16-16 16s-16-7.2-16-16V368c0-8.8 7.2-16 16-16zm32 80c13.3 0 24-10.7 24-24s-10.7-24-24-24h-16v48zm96-80h32c26.5 0 48 21.5 48 48v64c0 26.5-21.5 48-48 48h-32c-8.8 0-16-7.2-16-16V368c0-8.8 7.2-16 16-16zm32 128c8.8 0 16-7.2 16-16v-64c0-8.8-7.2-16-16-16h-16v96zm80-112c0-8.8 7.2-16 16-16h48c8.8 0 16 7.2 16 16s-7.2 16-16 16h-32v32h32c8.8 0 16 7.2 16 16s-7.2 16-16 16h-32v48c0 8.8-7.2 16-16 16s-16-7.2-16-16V368z"/></svg>'),
    Eye: e => am(e, '<svg viewBox="0 0 576 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4 142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1 3.3-7.9 3.3-16.7 0-24.6-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM144 256a144 144 0 1 1 288 0 144 144 0 1 1-288 0zm144-64c0 35.3-28.7 64-64 64-7.1 0-13.9-1.2-20.3-3.3-5.5-1.8-11.9 1.6-11.7 7.4.3 6.9 1.3 13.8 3.2 20.7 13.7 51.2 66.4 81.6 117.6 67.9s81.6-66.4 67.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1-5.8-.2-9.2 6.1-7.4 11.7 2.1 6.4 3.3 13.2 3.3 20.3z"/></svg>'),
    EyeClosed: e => am(e, '<svg viewBox="0 0 640 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2s-6.3 25.5 4.1 33.7l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7l-105.2-82.4c39.6-40.6 66.4-86.1 79.9-118.4 3.3-7.9 3.3-16.7 0-24.6-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8zm184.3 144.4c25.5-23.3 59.6-37.5 96.9-37.5 79.5 0 144 64.5 144 144 0 24.9-6.3 48.3-17.4 68.7L408 294.5c8.4-19.3 10.6-41.4 4.8-63.3-11.1-41.5-47.8-69.4-88.6-71.1-5.8-.2-9.2 6.1-7.4 11.7 2.1 6.4 3.3 13.2 3.3 20.3 0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zM373 389.9c-16.4 6.5-34.3 10.1-53 10.1-79.5 0-144-64.5-144-144 0-6.9.5-13.6 1.4-20.2l-94.3-74.3c-22.8 29.7-39.1 59.3-48.6 82.2-3.3 7.9-3.3 16.7 0 24.6 14.9 35.7 46.2 87.7 93 131.1 47 43.8 111.7 80.6 192.5 80.6 47.8 0 89.9-12.9 126.2-32.5z"/></svg>'),
    Percent: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 19 19 5"/><circle cx="7" cy="7" r="3" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/><circle cx="17" cy="17" r="3" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/></svg>'),
    Login: e => am(e, '<svg width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24"><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4M10 17l5-5-5-5M15 12H3"/></svg>'),
    Logout: e => am(e, '<svg width="32" height="32" viewBox="0 0 32 32" fill="currentColor"><path d="M6 30h12a2 2 0 0 0 2-2v-3h-2v3H6V4h12v3h2V4a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v24a2 2 0 0 0 2 2Z"/><path d="M20.586 20.586 24.172 17H10v-2h14.172l-3.586-3.586L22 10l6 6-6 6z"/><path d="M0 0h32v32H0z" style="fill:none"/></svg>'),
    SecurityShield: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="m11.19 1.36-7 3.11C3.47 4.79 3 5.51 3 6.3V11c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V6.3c0-.79-.47-1.51-1.19-1.83l-7-3.11c-.51-.23-1.11-.23-1.62 0zM12 11.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11z"/></svg>'),
    LockShield: e => am(e, '<svg width="16" height="16" fill="currentColor" class="bi bi-shield-lock-fill" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0c-.69 0-1.843.265-2.928.56-1.11.3-2.229.655-2.887.87a1.54 1.54 0 0 0-1.044 1.262c-.596 4.477.787 7.795 2.465 9.99a11.8 11.8 0 0 0 2.517 2.453c.386.273.744.482 1.048.625.28.132.581.24.829.24s.548-.108.829-.24a7 7 0 0 0 1.048-.625 11.8 11.8 0 0 0 2.517-2.453c1.678-2.195 3.061-5.513 2.465-9.99a1.54 1.54 0 0 0-1.044-1.263 63 63 0 0 0-2.887-.87C9.843.266 8.69 0 8 0m0 5a1.5 1.5 0 0 1 .5 2.915l.385 1.99a.5.5 0 0 1-.491.595h-.788a.5.5 0 0 1-.49-.595l.384-1.99A1.5 1.5 0 0 1 8 5"/></svg>'),
    Password: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 17h18c.55 0 1 .45 1 1v0c0 .55-.45 1-1 1H3c-.55 0-1-.45-1-1v0c0-.55.45-1 1-1zm-.5-4.43c.36.21.82.08 1.03-.28l.47-.82.48.83c.21.36.67.48 1.03.28h0c.36-.21.48-.66.28-1.02l-.49-.84h.95c.41 0 .75-.34.75-.75v0c0-.41-.34-.75-.75-.75H5.3l.47-.82c.21-.36.09-.82-.27-1.03h0a.764.764 0 0 0-1.03.28L4 8.47l-.47-.82a.764.764 0 0 0-1.03-.28h0c-.36.21-.48.67-.27 1.03l.47.82h-.95c-.41 0-.75.34-.75.75v0c0 .41.34.75.75.75h.95l-.48.83c-.2.36-.08.82.28 1.02zm8 0zc.36.21.82.08 1.03-.28l.47-.82.48.83c.21.36.67.48 1.03.28h0c.36-.21.48-.66.28-1.02l-.48-.83h.95c.41 0 .75-.34.75-.75v0c0-.41-.34-.75-.75-.75h-.96l.47-.82a.76.76 0 0 0-.27-1.03h0a.746.746 0 0 0-1.02.27l-.48.82-.47-.82a.74.74 0 0 0-1.02-.27h0c-.36.21-.48.67-.27 1.03l.47.82h-.96a.74.74 0 0 0-.75.74v0c0 .41.34.75.75.75h.95l-.48.83c-.2.36-.08.82.28 1.02zM23 9.97c0-.41-.34-.75-.75-.75h-.95l.47-.82a.76.76 0 0 0-.27-1.03h0a.746.746 0 0 0-1.02.27l-.48.83-.47-.82a.74.74 0 0 0-1.02-.27h0c-.36.21-.48.67-.27 1.03l.47.82h-.95a.743.743 0 0 0-.76.74v0c0 .41.34.75.75.75h.95l-.48.83a.74.74 0 0 0 .28 1.02h0c.36.21.82.08 1.03-.28l.47-.82.48.83c.21.36.67.48 1.03.28h0c.36-.21.48-.66.28-1.02l-.48-.83h.95c.4-.01.74-.35.74-.76z"/></svg>'),
    Exclamation: e => am(e, '<svg width="16" height="16" fill="currentColor" class="bi bi-exclamation-lg" viewBox="0 0 16 16"><path d="M7.005 3.1a1 1 0 1 1 1.99 0l-.388 6.35a.61.61 0 0 1-1.214 0zM7 12a1 1 0 1 1 2 0 1 1 0 0 1-2 0"/></svg>'),
    ExclamationCircle: e => am(e, '<svg width="16" height="16" fill="currentColor" class="bi bi-exclamation-circle-fill" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0M8 4a.905.905 0 0 0-.9.995l.35 3.507a.552.552 0 0 0 1.1 0l.35-3.507A.905.905 0 0 0 8 4m.002 6a1 1 0 1 0 0 2 1 1 0 0 0 0-2"/></svg>'),
    ExclamationTriangle: e => am(e, '<svg width="16" height="16" fill="currentColor" class="bi bi-exclamation-triangle-fill" viewBox="0 0 16 16"><path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5m.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2"/></svg>'),
    Add: e => am(e, '<svg width="32" height="32" viewBox="0 0 32 32" fill="currentColor"><path d="M17 15V5h-2v10H5v2h10v10h2V17h10v-2z"/><path d="M0 0h32v32H0z" style="fill:none"/></svg>'),
    Key: e => am(e, '<svg viewBox="0 0 512 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M336 352c97.2 0 176-78.8 176-176S433.2 0 336 0 160 78.8 160 176c0 18.7 2.9 36.8 8.3 53.7L7 391c-4.5 4.5-7 10.6-7 17v80c0 13.3 10.7 24 24 24h80c13.3 0 24-10.7 24-24v-40h40c13.3 0 24-10.7 24-24v-40h40c6.4 0 12.5-2.5 17-7l33.3-33.3c16.9 5.4 35 8.3 53.7 8.3zm40-256a40 40 0 1 1 0 80 40 40 0 1 1 0-80z"/></svg>'),
    Webhook: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 15h5.88c.27-.31.67-.5 1.12-.5.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5c-.44 0-.84-.19-1.12-.5H11.9A5 5 0 1 1 6 11.1v2.07c-1.16.41-2 1.53-2 2.83 0 1.65 1.35 3 3 3s3-1.35 3-3zm2.5-11c1.65 0 3 1.35 3 3h2c0-2.76-2.24-5-5-5h0a5.002 5.002 0 0 0-3.45 8.62l-2.35 3.9c-.68.14-1.2.75-1.2 1.48 0 .83.67 1.5 1.5 1.5a1.498 1.498 0 0 0 1.43-1.95l3.38-5.63A3 3 0 0 1 9.5 7c0-1.65 1.35-3 3-3zm4.5 9c-.64 0-1.23.2-1.72.54l-3.05-5.07C11.53 8.35 11 7.74 11 7c0-.83.67-1.5 1.5-1.5S14 6.17 14 7c0 .15-.02.29-.06.43l2.19 3.65c.28-.05.57-.08.87-.08h0c2.76 0 5 2.24 5 5s-2.24 5-5 5a5 5 0 0 1-4.33-2.5h2.67c.48.32 1.05.5 1.66.5 1.65 0 3-1.35 3-3s-1.35-3-3-3z"/></svg>'),
    Overview: e => am(e, '<svg width="200" height="200" class="icon" viewBox="0 0 1024 1024" fill="currentColor"><path d="m956 686.5-.1-.1-.1-.1C911.7 593 843.4 545 752.5 545s-159.2 48.1-203.4 141.3v.1c-5.4 11.5-5.4 24.9 0 36.4C593.3 816 661.6 864 752.5 864s159.2-48.1 203.4-141.3c5.4-11.5 5.4-24.8.1-36.2zM752.5 800c-62.1 0-107.4-30-141.1-95.5C645 639 690.4 609 752.5 609s107.4 30 141.1 95.5C860 770 814.6 800 752.5 800z"/><path d="M697 705a56 56 0 1 0 112 0 56 56 0 1 0-112 0ZM136 232h704v253h72V192c0-17.7-14.3-32-32-32H96c-17.7 0-32 14.3-32 32v520c0 17.7 14.3 32 32 32h352v-72H136z"/><path d="m724.9 338.1-36.8-36.8c-3.1-3.1-8.2-3.1-11.3 0L493 485.3l-86.1-86.2c-3.1-3.1-8.2-3.1-11.3 0L251.3 543.4c-3.1 3.1-3.1 8.2 0 11.3l36.8 36.8c3.1 3.1 8.2 3.1 11.3 0l101.8-101.8 86.1 86.2c3.1 3.1 8.2 3.1 11.3 0l226.3-226.5c3.2-3.1 3.2-8.2 0-11.3z"/></svg>'),
    Link: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.544 10.456a4.37 4.37 0 0 0-6.176 0l-3.089 3.088a4.367 4.367 0 1 0 6.177 6.177L12 18.177"/><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.456 13.544a4.37 4.37 0 0 0 6.176 0l3.089-3.088a4.367 4.367 0 1 0-6.177-6.177L12 5.823"/></svg>'),
    Sparkles: e => am(e, '<svg viewBox="0 0 512 512" fill="currentColor"><path d="M208 512a24.84 24.84 0 0 1-23.34-16l-39.84-103.6a16.06 16.06 0 0 0-9.19-9.19L32 343.34a25 25 0 0 1 0-46.68l103.6-39.84a16.06 16.06 0 0 0 9.19-9.19L184.66 144a25 25 0 0 1 46.68 0l39.84 103.6a16.06 16.06 0 0 0 9.19 9.19l103 39.63a25.49 25.49 0 0 1 16.63 24.1 24.82 24.82 0 0 1-16 22.82l-103.6 39.84a16.06 16.06 0 0 0-9.19 9.19L231.34 496A24.84 24.84 0 0 1 208 512Zm66.85-254.84zM88 176a14.67 14.67 0 0 1-13.69-9.4l-16.86-43.84a7.28 7.28 0 0 0-4.21-4.21L9.4 101.69a14.67 14.67 0 0 1 0-27.38l43.84-16.86a7.3 7.3 0 0 0 4.21-4.21L74.16 9.79A15 15 0 0 1 86.23.11a14.67 14.67 0 0 1 15.46 9.29l16.86 43.84a7.3 7.3 0 0 0 4.21 4.21l43.84 16.86a14.67 14.67 0 0 1 0 27.38l-43.84 16.86a7.28 7.28 0 0 0-4.21 4.21l-16.86 43.84A14.67 14.67 0 0 1 88 176ZM400 256a16 16 0 0 1-14.93-10.26l-22.84-59.37a8 8 0 0 0-4.6-4.6l-59.37-22.84a16 16 0 0 1 0-29.86l59.37-22.84a8 8 0 0 0 4.6-4.6l22.67-58.95a16.45 16.45 0 0 1 13.17-10.57 16 16 0 0 1 16.86 10.15l22.84 59.37a8 8 0 0 0 4.6 4.6l59.37 22.84a16 16 0 0 1 0 29.86l-59.37 22.84a8 8 0 0 0-4.6 4.6l-22.84 59.37A16 16 0 0 1 400 256Z"/></svg>'),
    Upload: e => am(e, '<svg fill="currentColor" viewBox="0 0 256 256"><path d="M238 136v64a14 14 0 0 1-14 14H32a14 14 0 0 1-14-14v-64a14 14 0 0 1 14-14h48a6 6 0 0 1 0 12H32a2 2 0 0 0-2 2v64a2 2 0 0 0 2 2h192a2 2 0 0 0 2-2v-64a2 2 0 0 0-2-2h-48a6 6 0 0 1 0-12h48a14 14 0 0 1 14 14ZM84.24 76.24 122 38.49V128a6 6 0 0 0 12 0V38.49l37.76 37.75a6 6 0 0 0 8.48-8.48l-48-48a6 6 0 0 0-8.48 0l-48 48a6 6 0 0 0 8.48 8.48ZM198 168a10 10 0 1 0-10 10 10 10 0 0 0 10-10Z"/></svg>'),
    StatusHealth: e => am(e, '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path fill-rule="evenodd" d="M7.999 1a.75.75 0 0 1 .715.521L12 11.79l1.286-4.018A.75.75 0 0 1 14 7.25h1.25a.75.75 0 0 1 0 1.5h-.703l-1.833 5.729a.75.75 0 0 1-1.428 0L8.005 4.226l-2.29 7.25a.75.75 0 0 1-1.42.03L3.031 8.03l-.07.208a.75.75 0 0 1-.711.513H.75a.75.75 0 0 1 0-1.5h.96l.578-1.737a.75.75 0 0 1 1.417-.02L4.95 8.919l2.335-7.394A.75.75 0 0 1 7.999 1Z" clip-rule="evenodd"/></svg>'),
    Ban: e => am(e, '<svg width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="m4.9 4.9 14.2 14.2"/></svg>'),
    TestTube: e => am(e, '<svg viewBox="0 0 32 32" fill="currentColor"><path d="M17 0c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1Zm-3 3c-.55 0-1 .45-1 1h-3v2h1v7.656l-6.156 7.938A3.98 3.98 0 0 0 4 24.03 3.98 3.98 0 0 0 7.969 28H24.03A3.98 3.98 0 0 0 28 24.031c0-.883-.3-1.738-.844-2.437L21 13.656V6h1V4h-7c0-.55-.45-1-1-1Zm-1 3h6v8.344L21.844 18H10.156L13 14.344Zm4 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1ZM8.594 20h14.812l2.188 2.813c.27.347.406.78.406 1.218A1.946 1.946 0 0 1 24.031 26H7.97A1.946 1.946 0 0 1 6 24.031c0-.437.137-.87.406-1.218Z"/></svg>'),
    BarGraph: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path fill="#0F172A" d="M18.375 2.25c-1.035 0-1.875.84-1.875 1.875v15.75c0 1.035.84 1.875 1.875 1.875h.75c1.035 0 1.875-.84 1.875-1.875V4.125c0-1.036-.84-1.875-1.875-1.875zM9.75 8.625c0-1.036.84-1.875 1.875-1.875h.75c1.036 0 1.875.84 1.875 1.875v11.25c0 1.035-.84 1.875-1.875 1.875h-.75a1.875 1.875 0 0 1-1.875-1.875zM3 13.125c0-1.036.84-1.875 1.875-1.875h.75c1.036 0 1.875.84 1.875 1.875v6.75c0 1.035-.84 1.875-1.875 1.875h-.75A1.875 1.875 0 0 1 3 19.875z"/></svg>'),
    Hashtag: e => am(e, '<svg width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 3 6 21M18 3l-4 18M4 8h17M3 16h17"/></svg>'),
    Business: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M21 7h-6a1 1 0 0 0-1 1v3h-2V4a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V8a1 1 0 0 0-1-1zM8 6h2v2H8zM6 16H4v-2h2zm0-4H4v-2h2zm0-4H4V6h2zm4 8H8v-2h2zm0-4H8v-2h2zm9 4h-2v-2h2zm0-4h-2v-2h2z"/></svg>'),
    Equal: e => am(e, '<svg viewBox="0 0 448 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M48 128c-17.7 0-32 14.3-32 32s14.3 32 32 32h352c17.7 0 32-14.3 32-32s-14.3-32-32-32zm0 192c-17.7 0-32 14.3-32 32s14.3 32 32 32h352c17.7 0 32-14.3 32-32s-14.3-32-32-32z"/></svg>'),
    CollapseHorizontal: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M19.95 5.64 13.59 12l6.36 6.36 1.41-1.41L16.41 12l4.95-4.95zM2.64 7.05 7.59 12l-4.95 4.95 1.41 1.41L10.41 12 4.05 5.64z"/></svg>'),
    Currency: e => am(e, '<svg width="32" height="32" viewBox="0 0 32 32" fill="currentColor"><path d="M23 20.515c0-4.615-3.78-5.141-6.817-5.563-3.31-.46-5.183-.86-5.183-3.71C11 8.85 13.507 8 15.654 8a6.75 6.75 0 0 1 5.568 2.628l1.556-1.256A8.65 8.65 0 0 0 17 6.096V3h-2v3.022c-3.615.22-6 2.26-6 5.22 0 4.73 3.83 5.263 6.908 5.69 3.252.453 5.092.842 5.092 3.583C21 23.547 17.867 24 16 24c-3.43 0-4.878-.964-6.222-2.628l-1.556 1.256A8.44 8.44 0 0 0 15 25.965V29h2v-3.045c3.726-.304 6-2.327 6-5.44Z"/><path d="M0 0h32v32H0z" style="fill:none"/></svg>'),
    Receipt: e => am(e, '<svg viewBox="0 0 384 512" fill="currentColor">\x3c!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--\x3e<path d="M14 2.2c8.5-3.9 18.5-2.5 25.6 3.6L80 40.4l40.4-34.6c9-7.7 22.3-7.7 31.2 0L192 40.4l40.4-34.6c9-7.7 22.3-7.7 31.2 0L304 40.4l40.4-34.6c7.1-6.1 17.1-7.5 25.6-3.6s14 12.4 14 21.8v464c0 9.4-5.5 17.9-14 21.8s-18.5 2.5-25.6-3.6L304 471.6l-40.4 34.6c-9 7.7-22.3 7.7-31.2 0L192 471.6l-40.4 34.6c-9 7.7-22.3 7.7-31.2 0L80 471.6l-40.4 34.6c-7.1 6.1-17.1 7.5-25.6 3.6S0 497.4 0 488V24C0 14.6 5.5 6.1 14 2.2zM96 144c-8.8 0-16 7.2-16 16s7.2 16 16 16h192c8.8 0 16-7.2 16-16s-7.2-16-16-16zM80 352c0 8.8 7.2 16 16 16h192c8.8 0 16-7.2 16-16s-7.2-16-16-16H96c-8.8 0-16 7.2-16 16zm16-112c-8.8 0-16 7.2-16 16s7.2 16 16 16h192c8.8 0 16-7.2 16-16s-7.2-16-16-16z"/></svg>'),
    SolidReceipt: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M20 12v6a1 1 0 0 1-2 0V4a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v14c0 1.654 1.346 3 3 3h14c1.654 0 3-1.346 3-3v-6zm-6-1v2H6v-2zM6 9V7h8v2zm8 6v2h-3v-2z"/></svg>'),
    ThreeDotsVertical: e => am(e, '<svg width="16" height="16" fill="currentColor" class="bi bi-three-dots-vertical" viewBox="0 0 16 16"><path d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0"/></svg>'),
    Share: e => am(e, '<svg width="512" height="512" viewBox="0 0 512 512" fill="currentColor"><path d="M336 192h40a40 40 0 0 1 40 40v192a40 40 0 0 1-40 40H136a40 40 0 0 1-40-40V232a40 40 0 0 1 40-40h40M336 128l-80-80-80 80M256 321V48" style="fill:none;stroke:#000;stroke-linecap:round;stroke-linejoin:round;stroke-width:32px"/></svg>'),
    Megaphone: e => am(e, '<svg class="icon" viewBox="0 0 1024 1024" fill="currentColor"><path d="M880 112c-3.8 0-7.7.7-11.6 2.3L292 345.9H128c-8.8 0-16 7.4-16 16.6v299c0 9.2 7.2 16.6 16 16.6h101.6c-3.7 11.6-5.6 23.9-5.6 36.4 0 65.9 53.8 119.5 120 119.5 55.4 0 102.1-37.6 115.9-88.4l408.6 164.2c3.9 1.5 7.8 2.3 11.6 2.3 16.9 0 32-14.2 32-33.2V145.2C912 126.2 897 112 880 112zM344 762.3c-26.5 0-48-21.4-48-47.8 0-11.2 3.9-21.9 11-30.4l84.9 34.1c-2 24.6-22.7 44.1-47.9 44.1z"/></svg>'),
    Adjusts: e => am(e, '<svg xml:space="preserve" width="32" height="32" viewBox="0 0 32 32" fill="currentColor"><path d="M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30zm-9 4c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3zM2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2zm9-4c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3 1.3-3 3-3z"/><path d="M0 0h32v32H0z" style="fill:none"/></svg>'),
    Edit: e => am(e, '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8.707 19.707 18 10.414 13.586 6l-9.293 9.293a1 1 0 0 0-.263.464L3 21l5.242-1.03c.176-.044.337-.135.465-.263zM21 7.414a2 2 0 0 0 0-2.828L19.414 3a2 2 0 0 0-2.828 0L15 4.586 19.414 9z"/></svg>')
}
  , im = to({
    __name: "CheckButton",
    props: {
        loading: {
            type: Boolean
        },
        success: {
            type: Boolean
        }
    },
    setup: e => (e, t) => {
        const n = Qv;
        return Tr(),
        Ir(n, {
            primary: "",
            size: "lg",
            class: K(["w-full mx-auto mt-4 relative overflow-hidden !transition-all !duration-700 ease-out !py-6 cursor-pointer", e.success ? "[clip-path:circle(24px)]" : "[clip-path:circle(100%)]"]),
            disabled: e.loading && !e.success
        }, {
            default: En( () => [e.loading || e.success ? (Tr(),
            Br("div", {
                key: 0,
                class: K(["relative transition-transform duration-500 ease-in-out", e.success ? "-translate-y-10 delay-700" : "translate-y-0"])
            }, [jr(Nt(sm).Loading, {
                class: "size-7 animate-spin"
            }), jr(Nt(sm).Check, {
                class: "size-7 absolute left-0 top-full mt-3"
            })], 2)) : Wo(e.$slots, "default", {
                key: 1
            }), Dr("span", {
                class: K(["bg-black/20 absolute left-0 top-0 bottom-0 w-0", {
                    "w-[92%] transition-all duration-[5000ms] ease-linear": e.loading || e.success,
                    "opacity-0 !duration-700": e.success
                }])
            }, null, 2)]),
            _: 3
        }, 8, ["class", "disabled"])
    }
})
  , lm = {
    key: 0,
    class: "mt-1 text-xs text-rose-600/90 dark:text-rose-700"
}
  , um = to({
    __name: "ValidationError",
    props: {
        message: {
            type: [String, Boolean]
        }
    },
    setup: e => (e, t) => e.message ? (Tr(),
    Br("div", lm, ne(e.message), 1)) : Ur("", !0)
})
  , cm = to({
    __name: "Input",
    props: {
        defaultValue: {},
        modelValue: {},
        class: {}
    },
    emits: ["update:modelValue"],
    setup(e, {emit: t}) {
        const n = e
          , o = qf(n, "modelValue", t, {
            passive: !0,
            defaultValue: n.defaultValue
        });
        return (e, t) => Tn((Tr(),
        Br("input", {
            "onUpdate:modelValue": t[0] || (t[0] = e => Bt(o) ? o.value = e : null),
            "data-slot": "input",
            class: K(Nt(hv)("file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", n.class))
        }, null, 2)), [[Ni, Nt(o)]])
    }
})
  , dm = Ol("modal", {
    state: () => ({
        activeModal: null,
        payload: {}
    }),
    actions: {
        open(e, t={}) {
            this.activeModal = e,
            this.payload = t
        },
        close() {
            this.activeModal = null,
            this.payload = {}
        },
        isOpen(e) {
            return this.activeModal === e
        }
    }
});
function pm(e) {
    const t = dm();
    return ms({
        get: () => t.activeModal === e,
        set: n => {
            n ? t.open(e) : t.close()
        }
    })
}
var fm, hm, vm;
(hm = fm || (fm = {})).assertEqual = e => {}
,
hm.assertIs = function(e) {}
,
hm.assertNever = function(e) {
    throw new Error
}
,
hm.arrayToEnum = e => {
    const t = {};
    for (const n of e)
        t[n] = n;
    return t
}
,
hm.getValidEnumValues = e => {
    const t = hm.objectKeys(e).filter(t => "number" != typeof e[e[t]])
      , n = {};
    for (const o of t)
        n[o] = e[o];
    return hm.objectValues(n)
}
,
hm.objectValues = e => hm.objectKeys(e).map(function(t) {
    return e[t]
}),
hm.objectKeys = "function" == typeof Object.keys ? e => Object.keys(e) : e => {
    const t = [];
    for (const n in e)
        Object.prototype.hasOwnProperty.call(e, n) && t.push(n);
    return t
}
,
hm.find = (e, t) => {
    for (const n of e)
        if (t(n))
            return n
}
,
hm.isInteger = "function" == typeof Number.isInteger ? e => Number.isInteger(e) : e => "number" == typeof e && Number.isFinite(e) && Math.floor(e) === e,
hm.joinValues = function(e, t=" | ") {
    return e.map(e => "string" == typeof e ? `'${e}'` : e).join(t)
}
,
hm.jsonStringifyReplacer = (e, t) => "bigint" == typeof t ? t.toString() : t,
(vm || (vm = {})).mergeShapes = (e, t) => ({
    ...e,
    ...t
});
const mm = fm.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
  , gm = e => {
    switch (typeof e) {
    case "undefined":
        return mm.undefined;
    case "string":
        return mm.string;
    case "number":
        return Number.isNaN(e) ? mm.nan : mm.number;
    case "boolean":
        return mm.boolean;
    case "function":
        return mm.function;
    case "bigint":
        return mm.bigint;
    case "symbol":
        return mm.symbol;
    case "object":
        return Array.isArray(e) ? mm.array : null === e ? mm.null : e.then && "function" == typeof e.then && e.catch && "function" == typeof e.catch ? mm.promise : "undefined" != typeof Map && e instanceof Map ? mm.map : "undefined" != typeof Set && e instanceof Set ? mm.set : "undefined" != typeof Date && e instanceof Date ? mm.date : mm.object;
    default:
        return mm.unknown
    }
}
  , ym = fm.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
class bm extends Error {
    get errors() {
        return this.issues
    }
    constructor(e) {
        super(),
        this.issues = [],
        this.addIssue = e => {
            this.issues = [...this.issues, e]
        }
        ,
        this.addIssues = (e=[]) => {
            this.issues = [...this.issues, ...e]
        }
        ;
        const t = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t,
        this.name = "ZodError",
        this.issues = e
    }
    format(e) {
        const t = e || function(e) {
            return e.message
        }
          , n = {
            _errors: []
        }
          , o = e => {
            for (const a of e.issues)
                if ("invalid_union" === a.code)
                    a.unionErrors.map(o);
                else if ("invalid_return_type" === a.code)
                    o(a.returnTypeError);
                else if ("invalid_arguments" === a.code)
                    o(a.argumentsError);
                else if (0 === a.path.length)
                    n._errors.push(t(a));
                else {
                    let e = n
                      , o = 0;
                    for (; o < a.path.length; ) {
                        const n = a.path[o];
                        o === a.path.length - 1 ? (e[n] = e[n] || {
                            _errors: []
                        },
                        e[n]._errors.push(t(a))) : e[n] = e[n] || {
                            _errors: []
                        },
                        e = e[n],
                        o++
                    }
                }
        }
        ;
        return o(this),
        n
    }
    static assert(e) {
        if (!(e instanceof bm))
            throw new Error(`Not a ZodError: ${e}`)
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, fm.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return 0 === this.issues.length
    }
    flatten(e=e => e.message) {
        const t = {}
          , n = [];
        for (const o of this.issues)
            o.path.length > 0 ? (t[o.path[0]] = t[o.path[0]] || [],
            t[o.path[0]].push(e(o))) : n.push(e(o));
        return {
            formErrors: n,
            fieldErrors: t
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
bm.create = e => new bm(e);
const wm = (e, t) => {
    let n;
    switch (e.code) {
    case ym.invalid_type:
        n = e.received === mm.undefined ? "Required" : `Expected ${e.expected}, received ${e.received}`;
        break;
    case ym.invalid_literal:
        n = `Invalid literal value, expected ${JSON.stringify(e.expected, fm.jsonStringifyReplacer)}`;
        break;
    case ym.unrecognized_keys:
        n = `Unrecognized key(s) in object: ${fm.joinValues(e.keys, ", ")}`;
        break;
    case ym.invalid_union:
        n = "Invalid input";
        break;
    case ym.invalid_union_discriminator:
        n = `Invalid discriminator value. Expected ${fm.joinValues(e.options)}`;
        break;
    case ym.invalid_enum_value:
        n = `Invalid enum value. Expected ${fm.joinValues(e.options)}, received '${e.received}'`;
        break;
    case ym.invalid_arguments:
        n = "Invalid function arguments";
        break;
    case ym.invalid_return_type:
        n = "Invalid function return type";
        break;
    case ym.invalid_date:
        n = "Invalid date";
        break;
    case ym.invalid_string:
        "object" == typeof e.validation ? "includes"in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`,
        "number" == typeof e.validation.position && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith"in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith"in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : fm.assertNever(e.validation) : n = "regex" !== e.validation ? `Invalid ${e.validation}` : "Invalid";
        break;
    case ym.too_small:
        n = "array" === e.type ? `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : "string" === e.type ? `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : "number" === e.type ? `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : "date" === e.type ? `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : "Invalid input";
        break;
    case ym.too_big:
        n = "array" === e.type ? `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : "string" === e.type ? `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : "number" === e.type ? `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : "bigint" === e.type ? `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : "date" === e.type ? `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : "Invalid input";
        break;
    case ym.custom:
        n = "Invalid input";
        break;
    case ym.invalid_intersection_types:
        n = "Intersection results could not be merged";
        break;
    case ym.not_multiple_of:
        n = `Number must be a multiple of ${e.multipleOf}`;
        break;
    case ym.not_finite:
        n = "Number must be finite";
        break;
    default:
        n = t.defaultError,
        fm.assertNever(e)
    }
    return {
        message: n
    }
}
;
let _m = wm;
function xm(e, t) {
    const n = _m
      , o = (e => {
        const {data: t, path: n, errorMaps: o, issueData: a} = e
          , r = [...n, ...a.path || []]
          , s = {
            ...a,
            path: r
        };
        if (void 0 !== a.message)
            return {
                ...a,
                path: r,
                message: a.message
            };
        let i = "";
        const l = o.filter(e => !!e).slice().reverse();
        for (const u of l)
            i = u(s, {
                data: t,
                defaultError: i
            }).message;
        return {
            ...a,
            path: r,
            message: i
        }
    }
    )({
        issueData: t,
        data: e.data,
        path: e.path,
        errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, n, n === wm ? void 0 : wm].filter(e => !!e)
    });
    e.common.issues.push(o)
}
class km {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        "valid" === this.value && (this.value = "dirty")
    }
    abort() {
        "aborted" !== this.value && (this.value = "aborted")
    }
    static mergeArray(e, t) {
        const n = [];
        for (const o of t) {
            if ("aborted" === o.status)
                return Sm;
            "dirty" === o.status && e.dirty(),
            n.push(o.value)
        }
        return {
            status: e.value,
            value: n
        }
    }
    static async mergeObjectAsync(e, t) {
        const n = [];
        for (const o of t) {
            const e = await o.key
              , t = await o.value;
            n.push({
                key: e,
                value: t
            })
        }
        return km.mergeObjectSync(e, n)
    }
    static mergeObjectSync(e, t) {
        const n = {};
        for (const o of t) {
            const {key: t, value: a} = o;
            if ("aborted" === t.status)
                return Sm;
            if ("aborted" === a.status)
                return Sm;
            "dirty" === t.status && e.dirty(),
            "dirty" === a.status && e.dirty(),
            "__proto__" === t.value || void 0 === a.value && !o.alwaysSet || (n[t.value] = a.value)
        }
        return {
            status: e.value,
            value: n
        }
    }
}
const Sm = Object.freeze({
    status: "aborted"
})
  , Cm = e => ({
    status: "dirty",
    value: e
})
  , Em = e => ({
    status: "valid",
    value: e
})
  , Tm = e => "aborted" === e.status
  , Am = e => "dirty" === e.status
  , Om = e => "valid" === e.status
  , Mm = e => "undefined" != typeof Promise && e instanceof Promise;
var Pm, Bm;
(Bm = Pm || (Pm = {})).errToObj = e => "string" == typeof e ? {
    message: e
} : e || {},
Bm.toString = e => "string" == typeof e ? e : null == e ? void 0 : e.message;
class Im {
    constructor(e, t, n, o) {
        this._cachedPath = [],
        this.parent = e,
        this.data = t,
        this._path = n,
        this._key = o
    }
    get path() {
        return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
    }
}
const Lm = (e, t) => {
    if (Om(t))
        return {
            success: !0,
            data: t.value
        };
    if (!e.common.issues.length)
        throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error() {
            if (this._error)
                return this._error;
            const t = new bm(e.common.issues);
            return this._error = t,
            this._error
        }
    }
}
;
function Rm(e) {
    if (!e)
        return {};
    const {errorMap: t, invalid_type_error: n, required_error: o, description: a} = e;
    if (t && (n || o))
        throw new Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.');
    if (t)
        return {
            errorMap: t,
            description: a
        };
    return {
        errorMap: (t, a) => {
            const {message: r} = e;
            return "invalid_enum_value" === t.code ? {
                message: r ?? a.defaultError
            } : void 0 === a.data ? {
                message: r ?? o ?? a.defaultError
            } : "invalid_type" !== t.code ? {
                message: a.defaultError
            } : {
                message: r ?? n ?? a.defaultError
            }
        }
        ,
        description: a
    }
}
class zm {
    get description() {
        return this._def.description
    }
    _getType(e) {
        return gm(e.data)
    }
    _getOrReturnCtx(e, t) {
        return t || {
            common: e.parent.common,
            data: e.data,
            parsedType: gm(e.data),
            schemaErrorMap: this._def.errorMap,
            path: e.path,
            parent: e.parent
        }
    }
    _processInputParams(e) {
        return {
            status: new km,
            ctx: {
                common: e.parent.common,
                data: e.data,
                parsedType: gm(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent
            }
        }
    }
    _parseSync(e) {
        const t = this._parse(e);
        if (Mm(t))
            throw new Error("Synchronous parse encountered promise.");
        return t
    }
    _parseAsync(e) {
        const t = this._parse(e);
        return Promise.resolve(t)
    }
    parse(e, t) {
        const n = this.safeParse(e, t);
        if (n.success)
            return n.data;
        throw n.error
    }
    safeParse(e, t) {
        const n = {
            common: {
                issues: [],
                async: (null == t ? void 0 : t.async) ?? !1,
                contextualErrorMap: null == t ? void 0 : t.errorMap
            },
            path: (null == t ? void 0 : t.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: gm(e)
        }
          , o = this._parseSync({
            data: e,
            path: n.path,
            parent: n
        });
        return Lm(n, o)
    }
    "~validate"(e) {
        var t, n;
        const o = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: gm(e)
        };
        if (!this["~standard"].async)
            try {
                const t = this._parseSync({
                    data: e,
                    path: [],
                    parent: o
                });
                return Om(t) ? {
                    value: t.value
                } : {
                    issues: o.common.issues
                }
            } catch (a) {
                (null == (n = null == (t = null == a ? void 0 : a.message) ? void 0 : t.toLowerCase()) ? void 0 : n.includes("encountered")) && (this["~standard"].async = !0),
                o.common = {
                    issues: [],
                    async: !0
                }
            }
        return this._parseAsync({
            data: e,
            path: [],
            parent: o
        }).then(e => Om(e) ? {
            value: e.value
        } : {
            issues: o.common.issues
        })
    }
    async parseAsync(e, t) {
        const n = await this.safeParseAsync(e, t);
        if (n.success)
            return n.data;
        throw n.error
    }
    async safeParseAsync(e, t) {
        const n = {
            common: {
                issues: [],
                contextualErrorMap: null == t ? void 0 : t.errorMap,
                async: !0
            },
            path: (null == t ? void 0 : t.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: gm(e)
        }
          , o = this._parse({
            data: e,
            path: n.path,
            parent: n
        })
          , a = await (Mm(o) ? o : Promise.resolve(o));
        return Lm(n, a)
    }
    refine(e, t) {
        const n = e => "string" == typeof t || void 0 === t ? {
            message: t
        } : "function" == typeof t ? t(e) : t;
        return this._refinement( (t, o) => {
            const a = e(t)
              , r = () => o.addIssue({
                code: ym.custom,
                ...n(t)
            });
            return "undefined" != typeof Promise && a instanceof Promise ? a.then(e => !!e || (r(),
            !1)) : !!a || (r(),
            !1)
        }
        )
    }
    refinement(e, t) {
        return this._refinement( (n, o) => !!e(n) || (o.addIssue("function" == typeof t ? t(n, o) : t),
        !1))
    }
    _refinement(e) {
        return new Lg({
            schema: this,
            typeName: Hg.ZodEffects,
            effect: {
                type: "refinement",
                refinement: e
            }
        })
    }
    superRefine(e) {
        return this._refinement(e)
    }
    constructor(e) {
        this.spa = this.safeParseAsync,
        this._def = e,
        this.parse = this.parse.bind(this),
        this.safeParse = this.safeParse.bind(this),
        this.parseAsync = this.parseAsync.bind(this),
        this.safeParseAsync = this.safeParseAsync.bind(this),
        this.spa = this.spa.bind(this),
        this.refine = this.refine.bind(this),
        this.refinement = this.refinement.bind(this),
        this.superRefine = this.superRefine.bind(this),
        this.optional = this.optional.bind(this),
        this.nullable = this.nullable.bind(this),
        this.nullish = this.nullish.bind(this),
        this.array = this.array.bind(this),
        this.promise = this.promise.bind(this),
        this.or = this.or.bind(this),
        this.and = this.and.bind(this),
        this.transform = this.transform.bind(this),
        this.brand = this.brand.bind(this),
        this.default = this.default.bind(this),
        this.catch = this.catch.bind(this),
        this.describe = this.describe.bind(this),
        this.pipe = this.pipe.bind(this),
        this.readonly = this.readonly.bind(this),
        this.isNullable = this.isNullable.bind(this),
        this.isOptional = this.isOptional.bind(this),
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: e => this["~validate"](e)
        }
    }
    optional() {
        return Rg.create(this, this._def)
    }
    nullable() {
        return zg.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return bg.create(this)
    }
    promise() {
        return Ig.create(this, this._def)
    }
    or(e) {
        return xg.create([this, e], this._def)
    }
    and(e) {
        return Sg.create(this, e, this._def)
    }
    transform(e) {
        return new Lg({
            ...Rm(this._def),
            schema: this,
            typeName: Hg.ZodEffects,
            effect: {
                type: "transform",
                transform: e
            }
        })
    }
    default(e) {
        const t = "function" == typeof e ? e : () => e;
        return new Ng({
            ...Rm(this._def),
            innerType: this,
            defaultValue: t,
            typeName: Hg.ZodDefault
        })
    }
    brand() {
        return new Fg({
            typeName: Hg.ZodBranded,
            type: this,
            ...Rm(this._def)
        })
    }
    catch(e) {
        const t = "function" == typeof e ? e : () => e;
        return new Dg({
            ...Rm(this._def),
            innerType: this,
            catchValue: t,
            typeName: Hg.ZodCatch
        })
    }
    describe(e) {
        return new (0,
        this.constructor)({
            ...this._def,
            description: e
        })
    }
    pipe(e) {
        return $g.create(this, e)
    }
    readonly() {
        return Vg.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
const Nm = /^c[^\s-]{8,}$/i
  , Dm = /^[0-9a-z]+$/
  , jm = /^[0-9A-HJKMNP-TV-Z]{26}$/i
  , Fm = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
  , $m = /^[a-z0-9_-]{21}$/i
  , Vm = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
  , Hm = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
  , Um = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
let Zm;
const qm = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
  , Wm = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/
  , Gm = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/
  , Km = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/
  , Ym = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
  , Xm = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/
  , Jm = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
  , Qm = new RegExp(`^${Jm}$`);
function eg(e) {
    let t = "[0-5]\\d";
    e.precision ? t = `${t}\\.\\d{${e.precision}}` : null == e.precision && (t = `${t}(\\.\\d+)?`);
    return `([01]\\d|2[0-3]):[0-5]\\d(:${t})${e.precision ? "+" : "?"}`
}
function tg(e) {
    return new RegExp(`^${eg(e)}$`)
}
function ng(e) {
    let t = `${Jm}T${eg(e)}`;
    const n = [];
    return n.push(e.local ? "Z?" : "Z"),
    e.offset && n.push("([+-]\\d{2}:?\\d{2})"),
    t = `${t}(${n.join("|")})`,
    new RegExp(`^${t}$`)
}
function og(e, t) {
    return !("v4" !== t && t || !qm.test(e)) || !("v6" !== t && t || !Gm.test(e))
}
function ag(e, t) {
    if (!Vm.test(e))
        return !1;
    try {
        const [n] = e.split(".")
          , o = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "=")
          , a = JSON.parse(atob(o));
        return "object" == typeof a && null !== a && ((!("typ"in a) || "JWT" === (null == a ? void 0 : a.typ)) && (!!a.alg && (!t || a.alg === t)))
    } catch {
        return !1
    }
}
function rg(e, t) {
    return !("v4" !== t && t || !Wm.test(e)) || !("v6" !== t && t || !Km.test(e))
}
class sg extends zm {
    _parse(e) {
        this._def.coerce && (e.data = String(e.data));
        if (this._getType(e) !== mm.string) {
            const t = this._getOrReturnCtx(e);
            return xm(t, {
                code: ym.invalid_type,
                expected: mm.string,
                received: t.parsedType
            }),
            Sm
        }
        const t = new km;
        let n;
        for (const o of this._def.checks)
            if ("min" === o.kind)
                e.data.length < o.value && (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    code: ym.too_small,
                    minimum: o.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: o.message
                }),
                t.dirty());
            else if ("max" === o.kind)
                e.data.length > o.value && (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    code: ym.too_big,
                    maximum: o.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: o.message
                }),
                t.dirty());
            else if ("length" === o.kind) {
                const a = e.data.length > o.value
                  , r = e.data.length < o.value;
                (a || r) && (n = this._getOrReturnCtx(e, n),
                a ? xm(n, {
                    code: ym.too_big,
                    maximum: o.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: o.message
                }) : r && xm(n, {
                    code: ym.too_small,
                    minimum: o.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: o.message
                }),
                t.dirty())
            } else if ("email" === o.kind)
                Um.test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "email",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty());
            else if ("emoji" === o.kind)
                Zm || (Zm = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$","u")),
                Zm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "emoji",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty());
            else if ("uuid" === o.kind)
                Fm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "uuid",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty());
            else if ("nanoid" === o.kind)
                $m.test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "nanoid",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty());
            else if ("cuid" === o.kind)
                Nm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "cuid",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty());
            else if ("cuid2" === o.kind)
                Dm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "cuid2",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty());
            else if ("ulid" === o.kind)
                jm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "ulid",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty());
            else if ("url" === o.kind)
                try {
                    new URL(e.data)
                } catch {
                    n = this._getOrReturnCtx(e, n),
                    xm(n, {
                        validation: "url",
                        code: ym.invalid_string,
                        message: o.message
                    }),
                    t.dirty()
                }
            else if ("regex" === o.kind) {
                o.regex.lastIndex = 0;
                o.regex.test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "regex",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty())
            } else if ("trim" === o.kind)
                e.data = e.data.trim();
            else if ("includes" === o.kind)
                e.data.includes(o.value, o.position) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    code: ym.invalid_string,
                    validation: {
                        includes: o.value,
                        position: o.position
                    },
                    message: o.message
                }),
                t.dirty());
            else if ("toLowerCase" === o.kind)
                e.data = e.data.toLowerCase();
            else if ("toUpperCase" === o.kind)
                e.data = e.data.toUpperCase();
            else if ("startsWith" === o.kind)
                e.data.startsWith(o.value) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    code: ym.invalid_string,
                    validation: {
                        startsWith: o.value
                    },
                    message: o.message
                }),
                t.dirty());
            else if ("endsWith" === o.kind)
                e.data.endsWith(o.value) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    code: ym.invalid_string,
                    validation: {
                        endsWith: o.value
                    },
                    message: o.message
                }),
                t.dirty());
            else if ("datetime" === o.kind) {
                ng(o).test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    code: ym.invalid_string,
                    validation: "datetime",
                    message: o.message
                }),
                t.dirty())
            } else if ("date" === o.kind) {
                Qm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    code: ym.invalid_string,
                    validation: "date",
                    message: o.message
                }),
                t.dirty())
            } else if ("time" === o.kind) {
                tg(o).test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    code: ym.invalid_string,
                    validation: "time",
                    message: o.message
                }),
                t.dirty())
            } else
                "duration" === o.kind ? Hm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "duration",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty()) : "ip" === o.kind ? og(e.data, o.version) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "ip",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty()) : "jwt" === o.kind ? ag(e.data, o.alg) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "jwt",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty()) : "cidr" === o.kind ? rg(e.data, o.version) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "cidr",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty()) : "base64" === o.kind ? Ym.test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "base64",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty()) : "base64url" === o.kind ? Xm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                xm(n, {
                    validation: "base64url",
                    code: ym.invalid_string,
                    message: o.message
                }),
                t.dirty()) : fm.assertNever(o);
        return {
            status: t.value,
            value: e.data
        }
    }
    _regex(e, t, n) {
        return this.refinement(t => e.test(t), {
            validation: t,
            code: ym.invalid_string,
            ...Pm.errToObj(n)
        })
    }
    _addCheck(e) {
        return new sg({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    email(e) {
        return this._addCheck({
            kind: "email",
            ...Pm.errToObj(e)
        })
    }
    url(e) {
        return this._addCheck({
            kind: "url",
            ...Pm.errToObj(e)
        })
    }
    emoji(e) {
        return this._addCheck({
            kind: "emoji",
            ...Pm.errToObj(e)
        })
    }
    uuid(e) {
        return this._addCheck({
            kind: "uuid",
            ...Pm.errToObj(e)
        })
    }
    nanoid(e) {
        return this._addCheck({
            kind: "nanoid",
            ...Pm.errToObj(e)
        })
    }
    cuid(e) {
        return this._addCheck({
            kind: "cuid",
            ...Pm.errToObj(e)
        })
    }
    cuid2(e) {
        return this._addCheck({
            kind: "cuid2",
            ...Pm.errToObj(e)
        })
    }
    ulid(e) {
        return this._addCheck({
            kind: "ulid",
            ...Pm.errToObj(e)
        })
    }
    base64(e) {
        return this._addCheck({
            kind: "base64",
            ...Pm.errToObj(e)
        })
    }
    base64url(e) {
        return this._addCheck({
            kind: "base64url",
            ...Pm.errToObj(e)
        })
    }
    jwt(e) {
        return this._addCheck({
            kind: "jwt",
            ...Pm.errToObj(e)
        })
    }
    ip(e) {
        return this._addCheck({
            kind: "ip",
            ...Pm.errToObj(e)
        })
    }
    cidr(e) {
        return this._addCheck({
            kind: "cidr",
            ...Pm.errToObj(e)
        })
    }
    datetime(e) {
        return "string" == typeof e ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: e
        }) : this._addCheck({
            kind: "datetime",
            precision: void 0 === (null == e ? void 0 : e.precision) ? null : null == e ? void 0 : e.precision,
            offset: (null == e ? void 0 : e.offset) ?? !1,
            local: (null == e ? void 0 : e.local) ?? !1,
            ...Pm.errToObj(null == e ? void 0 : e.message)
        })
    }
    date(e) {
        return this._addCheck({
            kind: "date",
            message: e
        })
    }
    time(e) {
        return "string" == typeof e ? this._addCheck({
            kind: "time",
            precision: null,
            message: e
        }) : this._addCheck({
            kind: "time",
            precision: void 0 === (null == e ? void 0 : e.precision) ? null : null == e ? void 0 : e.precision,
            ...Pm.errToObj(null == e ? void 0 : e.message)
        })
    }
    duration(e) {
        return this._addCheck({
            kind: "duration",
            ...Pm.errToObj(e)
        })
    }
    regex(e, t) {
        return this._addCheck({
            kind: "regex",
            regex: e,
            ...Pm.errToObj(t)
        })
    }
    includes(e, t) {
        return this._addCheck({
            kind: "includes",
            value: e,
            position: null == t ? void 0 : t.position,
            ...Pm.errToObj(null == t ? void 0 : t.message)
        })
    }
    startsWith(e, t) {
        return this._addCheck({
            kind: "startsWith",
            value: e,
            ...Pm.errToObj(t)
        })
    }
    endsWith(e, t) {
        return this._addCheck({
            kind: "endsWith",
            value: e,
            ...Pm.errToObj(t)
        })
    }
    min(e, t) {
        return this._addCheck({
            kind: "min",
            value: e,
            ...Pm.errToObj(t)
        })
    }
    max(e, t) {
        return this._addCheck({
            kind: "max",
            value: e,
            ...Pm.errToObj(t)
        })
    }
    length(e, t) {
        return this._addCheck({
            kind: "length",
            value: e,
            ...Pm.errToObj(t)
        })
    }
    nonempty(e) {
        return this.min(1, Pm.errToObj(e))
    }
    trim() {
        return new sg({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new sg({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new sg({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find(e => "datetime" === e.kind)
    }
    get isDate() {
        return !!this._def.checks.find(e => "date" === e.kind)
    }
    get isTime() {
        return !!this._def.checks.find(e => "time" === e.kind)
    }
    get isDuration() {
        return !!this._def.checks.find(e => "duration" === e.kind)
    }
    get isEmail() {
        return !!this._def.checks.find(e => "email" === e.kind)
    }
    get isURL() {
        return !!this._def.checks.find(e => "url" === e.kind)
    }
    get isEmoji() {
        return !!this._def.checks.find(e => "emoji" === e.kind)
    }
    get isUUID() {
        return !!this._def.checks.find(e => "uuid" === e.kind)
    }
    get isNANOID() {
        return !!this._def.checks.find(e => "nanoid" === e.kind)
    }
    get isCUID() {
        return !!this._def.checks.find(e => "cuid" === e.kind)
    }
    get isCUID2() {
        return !!this._def.checks.find(e => "cuid2" === e.kind)
    }
    get isULID() {
        return !!this._def.checks.find(e => "ulid" === e.kind)
    }
    get isIP() {
        return !!this._def.checks.find(e => "ip" === e.kind)
    }
    get isCIDR() {
        return !!this._def.checks.find(e => "cidr" === e.kind)
    }
    get isBase64() {
        return !!this._def.checks.find(e => "base64" === e.kind)
    }
    get isBase64url() {
        return !!this._def.checks.find(e => "base64url" === e.kind)
    }
    get minLength() {
        let e = null;
        for (const t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
        return e
    }
    get maxLength() {
        let e = null;
        for (const t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
        return e
    }
}
function ig(e, t) {
    const n = (e.toString().split(".")[1] || "").length
      , o = (t.toString().split(".")[1] || "").length
      , a = n > o ? n : o;
    return Number.parseInt(e.toFixed(a).replace(".", "")) % Number.parseInt(t.toFixed(a).replace(".", "")) / 10 ** a
}
sg.create = e => new sg({
    checks: [],
    typeName: Hg.ZodString,
    coerce: (null == e ? void 0 : e.coerce) ?? !1,
    ...Rm(e)
});
class lg extends zm {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte,
        this.step = this.multipleOf
    }
    _parse(e) {
        this._def.coerce && (e.data = Number(e.data));
        if (this._getType(e) !== mm.number) {
            const t = this._getOrReturnCtx(e);
            return xm(t, {
                code: ym.invalid_type,
                expected: mm.number,
                received: t.parsedType
            }),
            Sm
        }
        let t;
        const n = new km;
        for (const o of this._def.checks)
            if ("int" === o.kind)
                fm.isInteger(e.data) || (t = this._getOrReturnCtx(e, t),
                xm(t, {
                    code: ym.invalid_type,
                    expected: "integer",
                    received: "float",
                    message: o.message
                }),
                n.dirty());
            else if ("min" === o.kind) {
                (o.inclusive ? e.data < o.value : e.data <= o.value) && (t = this._getOrReturnCtx(e, t),
                xm(t, {
                    code: ym.too_small,
                    minimum: o.value,
                    type: "number",
                    inclusive: o.inclusive,
                    exact: !1,
                    message: o.message
                }),
                n.dirty())
            } else if ("max" === o.kind) {
                (o.inclusive ? e.data > o.value : e.data >= o.value) && (t = this._getOrReturnCtx(e, t),
                xm(t, {
                    code: ym.too_big,
                    maximum: o.value,
                    type: "number",
                    inclusive: o.inclusive,
                    exact: !1,
                    message: o.message
                }),
                n.dirty())
            } else
                "multipleOf" === o.kind ? 0 !== ig(e.data, o.value) && (t = this._getOrReturnCtx(e, t),
                xm(t, {
                    code: ym.not_multiple_of,
                    multipleOf: o.value,
                    message: o.message
                }),
                n.dirty()) : "finite" === o.kind ? Number.isFinite(e.data) || (t = this._getOrReturnCtx(e, t),
                xm(t, {
                    code: ym.not_finite,
                    message: o.message
                }),
                n.dirty()) : fm.assertNever(o);
        return {
            status: n.value,
            value: e.data
        }
    }
    gte(e, t) {
        return this.setLimit("min", e, !0, Pm.toString(t))
    }
    gt(e, t) {
        return this.setLimit("min", e, !1, Pm.toString(t))
    }
    lte(e, t) {
        return this.setLimit("max", e, !0, Pm.toString(t))
    }
    lt(e, t) {
        return this.setLimit("max", e, !1, Pm.toString(t))
    }
    setLimit(e, t, n, o) {
        return new lg({
            ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: t,
                inclusive: n,
                message: Pm.toString(o)
            }]
        })
    }
    _addCheck(e) {
        return new lg({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    int(e) {
        return this._addCheck({
            kind: "int",
            message: Pm.toString(e)
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: Pm.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: Pm.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: Pm.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: Pm.toString(e)
        })
    }
    multipleOf(e, t) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: Pm.toString(t)
        })
    }
    finite(e) {
        return this._addCheck({
            kind: "finite",
            message: Pm.toString(e)
        })
    }
    safe(e) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: Pm.toString(e)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: Pm.toString(e)
        })
    }
    get minValue() {
        let e = null;
        for (const t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
        return e
    }
    get isInt() {
        return !!this._def.checks.find(e => "int" === e.kind || "multipleOf" === e.kind && fm.isInteger(e.value))
    }
    get isFinite() {
        let e = null
          , t = null;
        for (const n of this._def.checks) {
            if ("finite" === n.kind || "int" === n.kind || "multipleOf" === n.kind)
                return !0;
            "min" === n.kind ? (null === t || n.value > t) && (t = n.value) : "max" === n.kind && (null === e || n.value < e) && (e = n.value)
        }
        return Number.isFinite(t) && Number.isFinite(e)
    }
}
lg.create = e => new lg({
    checks: [],
    typeName: Hg.ZodNumber,
    coerce: (null == e ? void 0 : e.coerce) || !1,
    ...Rm(e)
});
class ug extends zm {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte
    }
    _parse(e) {
        if (this._def.coerce)
            try {
                e.data = BigInt(e.data)
            } catch {
                return this._getInvalidInput(e)
            }
        if (this._getType(e) !== mm.bigint)
            return this._getInvalidInput(e);
        let t;
        const n = new km;
        for (const o of this._def.checks)
            if ("min" === o.kind) {
                (o.inclusive ? e.data < o.value : e.data <= o.value) && (t = this._getOrReturnCtx(e, t),
                xm(t, {
                    code: ym.too_small,
                    type: "bigint",
                    minimum: o.value,
                    inclusive: o.inclusive,
                    message: o.message
                }),
                n.dirty())
            } else if ("max" === o.kind) {
                (o.inclusive ? e.data > o.value : e.data >= o.value) && (t = this._getOrReturnCtx(e, t),
                xm(t, {
                    code: ym.too_big,
                    type: "bigint",
                    maximum: o.value,
                    inclusive: o.inclusive,
                    message: o.message
                }),
                n.dirty())
            } else
                "multipleOf" === o.kind ? e.data % o.value !== BigInt(0) && (t = this._getOrReturnCtx(e, t),
                xm(t, {
                    code: ym.not_multiple_of,
                    multipleOf: o.value,
                    message: o.message
                }),
                n.dirty()) : fm.assertNever(o);
        return {
            status: n.value,
            value: e.data
        }
    }
    _getInvalidInput(e) {
        const t = this._getOrReturnCtx(e);
        return xm(t, {
            code: ym.invalid_type,
            expected: mm.bigint,
            received: t.parsedType
        }),
        Sm
    }
    gte(e, t) {
        return this.setLimit("min", e, !0, Pm.toString(t))
    }
    gt(e, t) {
        return this.setLimit("min", e, !1, Pm.toString(t))
    }
    lte(e, t) {
        return this.setLimit("max", e, !0, Pm.toString(t))
    }
    lt(e, t) {
        return this.setLimit("max", e, !1, Pm.toString(t))
    }
    setLimit(e, t, n, o) {
        return new ug({
            ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: t,
                inclusive: n,
                message: Pm.toString(o)
            }]
        })
    }
    _addCheck(e) {
        return new ug({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: Pm.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: Pm.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: Pm.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: Pm.toString(e)
        })
    }
    multipleOf(e, t) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: Pm.toString(t)
        })
    }
    get minValue() {
        let e = null;
        for (const t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
        return e
    }
}
ug.create = e => new ug({
    checks: [],
    typeName: Hg.ZodBigInt,
    coerce: (null == e ? void 0 : e.coerce) ?? !1,
    ...Rm(e)
});
class cg extends zm {
    _parse(e) {
        this._def.coerce && (e.data = Boolean(e.data));
        if (this._getType(e) !== mm.boolean) {
            const t = this._getOrReturnCtx(e);
            return xm(t, {
                code: ym.invalid_type,
                expected: mm.boolean,
                received: t.parsedType
            }),
            Sm
        }
        return Em(e.data)
    }
}
cg.create = e => new cg({
    typeName: Hg.ZodBoolean,
    coerce: (null == e ? void 0 : e.coerce) || !1,
    ...Rm(e)
});
class dg extends zm {
    _parse(e) {
        this._def.coerce && (e.data = new Date(e.data));
        if (this._getType(e) !== mm.date) {
            const t = this._getOrReturnCtx(e);
            return xm(t, {
                code: ym.invalid_type,
                expected: mm.date,
                received: t.parsedType
            }),
            Sm
        }
        if (Number.isNaN(e.data.getTime())) {
            return xm(this._getOrReturnCtx(e), {
                code: ym.invalid_date
            }),
            Sm
        }
        const t = new km;
        let n;
        for (const o of this._def.checks)
            "min" === o.kind ? e.data.getTime() < o.value && (n = this._getOrReturnCtx(e, n),
            xm(n, {
                code: ym.too_small,
                message: o.message,
                inclusive: !0,
                exact: !1,
                minimum: o.value,
                type: "date"
            }),
            t.dirty()) : "max" === o.kind ? e.data.getTime() > o.value && (n = this._getOrReturnCtx(e, n),
            xm(n, {
                code: ym.too_big,
                message: o.message,
                inclusive: !0,
                exact: !1,
                maximum: o.value,
                type: "date"
            }),
            t.dirty()) : fm.assertNever(o);
        return {
            status: t.value,
            value: new Date(e.data.getTime())
        }
    }
    _addCheck(e) {
        return new dg({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    min(e, t) {
        return this._addCheck({
            kind: "min",
            value: e.getTime(),
            message: Pm.toString(t)
        })
    }
    max(e, t) {
        return this._addCheck({
            kind: "max",
            value: e.getTime(),
            message: Pm.toString(t)
        })
    }
    get minDate() {
        let e = null;
        for (const t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
        return null != e ? new Date(e) : null
    }
    get maxDate() {
        let e = null;
        for (const t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
        return null != e ? new Date(e) : null
    }
}
dg.create = e => new dg({
    checks: [],
    coerce: (null == e ? void 0 : e.coerce) || !1,
    typeName: Hg.ZodDate,
    ...Rm(e)
});
class pg extends zm {
    _parse(e) {
        if (this._getType(e) !== mm.symbol) {
            const t = this._getOrReturnCtx(e);
            return xm(t, {
                code: ym.invalid_type,
                expected: mm.symbol,
                received: t.parsedType
            }),
            Sm
        }
        return Em(e.data)
    }
}
pg.create = e => new pg({
    typeName: Hg.ZodSymbol,
    ...Rm(e)
});
class fg extends zm {
    _parse(e) {
        if (this._getType(e) !== mm.undefined) {
            const t = this._getOrReturnCtx(e);
            return xm(t, {
                code: ym.invalid_type,
                expected: mm.undefined,
                received: t.parsedType
            }),
            Sm
        }
        return Em(e.data)
    }
}
fg.create = e => new fg({
    typeName: Hg.ZodUndefined,
    ...Rm(e)
});
class hg extends zm {
    _parse(e) {
        if (this._getType(e) !== mm.null) {
            const t = this._getOrReturnCtx(e);
            return xm(t, {
                code: ym.invalid_type,
                expected: mm.null,
                received: t.parsedType
            }),
            Sm
        }
        return Em(e.data)
    }
}
hg.create = e => new hg({
    typeName: Hg.ZodNull,
    ...Rm(e)
});
class vg extends zm {
    constructor() {
        super(...arguments),
        this._any = !0
    }
    _parse(e) {
        return Em(e.data)
    }
}
vg.create = e => new vg({
    typeName: Hg.ZodAny,
    ...Rm(e)
});
class mg extends zm {
    constructor() {
        super(...arguments),
        this._unknown = !0
    }
    _parse(e) {
        return Em(e.data)
    }
}
mg.create = e => new mg({
    typeName: Hg.ZodUnknown,
    ...Rm(e)
});
class gg extends zm {
    _parse(e) {
        const t = this._getOrReturnCtx(e);
        return xm(t, {
            code: ym.invalid_type,
            expected: mm.never,
            received: t.parsedType
        }),
        Sm
    }
}
gg.create = e => new gg({
    typeName: Hg.ZodNever,
    ...Rm(e)
});
class yg extends zm {
    _parse(e) {
        if (this._getType(e) !== mm.undefined) {
            const t = this._getOrReturnCtx(e);
            return xm(t, {
                code: ym.invalid_type,
                expected: mm.void,
                received: t.parsedType
            }),
            Sm
        }
        return Em(e.data)
    }
}
yg.create = e => new yg({
    typeName: Hg.ZodVoid,
    ...Rm(e)
});
class bg extends zm {
    _parse(e) {
        const {ctx: t, status: n} = this._processInputParams(e)
          , o = this._def;
        if (t.parsedType !== mm.array)
            return xm(t, {
                code: ym.invalid_type,
                expected: mm.array,
                received: t.parsedType
            }),
            Sm;
        if (null !== o.exactLength) {
            const e = t.data.length > o.exactLength.value
              , a = t.data.length < o.exactLength.value;
            (e || a) && (xm(t, {
                code: e ? ym.too_big : ym.too_small,
                minimum: a ? o.exactLength.value : void 0,
                maximum: e ? o.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: o.exactLength.message
            }),
            n.dirty())
        }
        if (null !== o.minLength && t.data.length < o.minLength.value && (xm(t, {
            code: ym.too_small,
            minimum: o.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: o.minLength.message
        }),
        n.dirty()),
        null !== o.maxLength && t.data.length > o.maxLength.value && (xm(t, {
            code: ym.too_big,
            maximum: o.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: o.maxLength.message
        }),
        n.dirty()),
        t.common.async)
            return Promise.all([...t.data].map( (e, n) => o.type._parseAsync(new Im(t,e,t.path,n)))).then(e => km.mergeArray(n, e));
        const a = [...t.data].map( (e, n) => o.type._parseSync(new Im(t,e,t.path,n)));
        return km.mergeArray(n, a)
    }
    get element() {
        return this._def.type
    }
    min(e, t) {
        return new bg({
            ...this._def,
            minLength: {
                value: e,
                message: Pm.toString(t)
            }
        })
    }
    max(e, t) {
        return new bg({
            ...this._def,
            maxLength: {
                value: e,
                message: Pm.toString(t)
            }
        })
    }
    length(e, t) {
        return new bg({
            ...this._def,
            exactLength: {
                value: e,
                message: Pm.toString(t)
            }
        })
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
function wg(e) {
    if (e instanceof _g) {
        const t = {};
        for (const n in e.shape) {
            const o = e.shape[n];
            t[n] = Rg.create(wg(o))
        }
        return new _g({
            ...e._def,
            shape: () => t
        })
    }
    return e instanceof bg ? new bg({
        ...e._def,
        type: wg(e.element)
    }) : e instanceof Rg ? Rg.create(wg(e.unwrap())) : e instanceof zg ? zg.create(wg(e.unwrap())) : e instanceof Cg ? Cg.create(e.items.map(e => wg(e))) : e
}
bg.create = (e, t) => new bg({
    type: e,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: Hg.ZodArray,
    ...Rm(t)
});
class _g extends zm {
    constructor() {
        super(...arguments),
        this._cached = null,
        this.nonstrict = this.passthrough,
        this.augment = this.extend
    }
    _getCached() {
        if (null !== this._cached)
            return this._cached;
        const e = this._def.shape()
          , t = fm.objectKeys(e);
        return this._cached = {
            shape: e,
            keys: t
        },
        this._cached
    }
    _parse(e) {
        if (this._getType(e) !== mm.object) {
            const t = this._getOrReturnCtx(e);
            return xm(t, {
                code: ym.invalid_type,
                expected: mm.object,
                received: t.parsedType
            }),
            Sm
        }
        const {status: t, ctx: n} = this._processInputParams(e)
          , {shape: o, keys: a} = this._getCached()
          , r = [];
        if (!(this._def.catchall instanceof gg && "strip" === this._def.unknownKeys))
            for (const i in n.data)
                a.includes(i) || r.push(i);
        const s = [];
        for (const i of a) {
            const e = o[i]
              , t = n.data[i];
            s.push({
                key: {
                    status: "valid",
                    value: i
                },
                value: e._parse(new Im(n,t,n.path,i)),
                alwaysSet: i in n.data
            })
        }
        if (this._def.catchall instanceof gg) {
            const e = this._def.unknownKeys;
            if ("passthrough" === e)
                for (const t of r)
                    s.push({
                        key: {
                            status: "valid",
                            value: t
                        },
                        value: {
                            status: "valid",
                            value: n.data[t]
                        }
                    });
            else if ("strict" === e)
                r.length > 0 && (xm(n, {
                    code: ym.unrecognized_keys,
                    keys: r
                }),
                t.dirty());
            else if ("strip" !== e)
                throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            const e = this._def.catchall;
            for (const t of r) {
                const o = n.data[t];
                s.push({
                    key: {
                        status: "valid",
                        value: t
                    },
                    value: e._parse(new Im(n,o,n.path,t)),
                    alwaysSet: t in n.data
                })
            }
        }
        return n.common.async ? Promise.resolve().then(async () => {
            const e = [];
            for (const t of s) {
                const n = await t.key
                  , o = await t.value;
                e.push({
                    key: n,
                    value: o,
                    alwaysSet: t.alwaysSet
                })
            }
            return e
        }
        ).then(e => km.mergeObjectSync(t, e)) : km.mergeObjectSync(t, s)
    }
    get shape() {
        return this._def.shape()
    }
    strict(e) {
        return Pm.errToObj,
        new _g({
            ...this._def,
            unknownKeys: "strict",
            ...void 0 !== e ? {
                errorMap: (t, n) => {
                    var o, a;
                    const r = (null == (a = (o = this._def).errorMap) ? void 0 : a.call(o, t, n).message) ?? n.defaultError;
                    return "unrecognized_keys" === t.code ? {
                        message: Pm.errToObj(e).message ?? r
                    } : {
                        message: r
                    }
                }
            } : {}
        })
    }
    strip() {
        return new _g({
            ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new _g({
            ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(e) {
        return new _g({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...e
            })
        })
    }
    merge(e) {
        return new _g({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...e._def.shape()
            }),
            typeName: Hg.ZodObject
        })
    }
    setKey(e, t) {
        return this.augment({
            [e]: t
        })
    }
    catchall(e) {
        return new _g({
            ...this._def,
            catchall: e
        })
    }
    pick(e) {
        const t = {};
        for (const n of fm.objectKeys(e))
            e[n] && this.shape[n] && (t[n] = this.shape[n]);
        return new _g({
            ...this._def,
            shape: () => t
        })
    }
    omit(e) {
        const t = {};
        for (const n of fm.objectKeys(this.shape))
            e[n] || (t[n] = this.shape[n]);
        return new _g({
            ...this._def,
            shape: () => t
        })
    }
    deepPartial() {
        return wg(this)
    }
    partial(e) {
        const t = {};
        for (const n of fm.objectKeys(this.shape)) {
            const o = this.shape[n];
            e && !e[n] ? t[n] = o : t[n] = o.optional()
        }
        return new _g({
            ...this._def,
            shape: () => t
        })
    }
    required(e) {
        const t = {};
        for (const n of fm.objectKeys(this.shape))
            if (e && !e[n])
                t[n] = this.shape[n];
            else {
                let e = this.shape[n];
                for (; e instanceof Rg; )
                    e = e._def.innerType;
                t[n] = e
            }
        return new _g({
            ...this._def,
            shape: () => t
        })
    }
    keyof() {
        return Mg(fm.objectKeys(this.shape))
    }
}
_g.create = (e, t) => new _g({
    shape: () => e,
    unknownKeys: "strip",
    catchall: gg.create(),
    typeName: Hg.ZodObject,
    ...Rm(t)
}),
_g.strictCreate = (e, t) => new _g({
    shape: () => e,
    unknownKeys: "strict",
    catchall: gg.create(),
    typeName: Hg.ZodObject,
    ...Rm(t)
}),
_g.lazycreate = (e, t) => new _g({
    shape: e,
    unknownKeys: "strip",
    catchall: gg.create(),
    typeName: Hg.ZodObject,
    ...Rm(t)
});
class xg extends zm {
    _parse(e) {
        const {ctx: t} = this._processInputParams(e)
          , n = this._def.options;
        if (t.common.async)
            return Promise.all(n.map(async e => {
                const n = {
                    ...t,
                    common: {
                        ...t.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await e._parseAsync({
                        data: t.data,
                        path: t.path,
                        parent: n
                    }),
                    ctx: n
                }
            }
            )).then(function(e) {
                for (const t of e)
                    if ("valid" === t.result.status)
                        return t.result;
                for (const o of e)
                    if ("dirty" === o.result.status)
                        return t.common.issues.push(...o.ctx.common.issues),
                        o.result;
                const n = e.map(e => new bm(e.ctx.common.issues));
                return xm(t, {
                    code: ym.invalid_union,
                    unionErrors: n
                }),
                Sm
            });
        {
            let e;
            const o = [];
            for (const r of n) {
                const n = {
                    ...t,
                    common: {
                        ...t.common,
                        issues: []
                    },
                    parent: null
                }
                  , a = r._parseSync({
                    data: t.data,
                    path: t.path,
                    parent: n
                });
                if ("valid" === a.status)
                    return a;
                "dirty" !== a.status || e || (e = {
                    result: a,
                    ctx: n
                }),
                n.common.issues.length && o.push(n.common.issues)
            }
            if (e)
                return t.common.issues.push(...e.ctx.common.issues),
                e.result;
            const a = o.map(e => new bm(e));
            return xm(t, {
                code: ym.invalid_union,
                unionErrors: a
            }),
            Sm
        }
    }
    get options() {
        return this._def.options
    }
}
function kg(e, t) {
    const n = gm(e)
      , o = gm(t);
    if (e === t)
        return {
            valid: !0,
            data: e
        };
    if (n === mm.object && o === mm.object) {
        const n = fm.objectKeys(t)
          , o = fm.objectKeys(e).filter(e => -1 !== n.indexOf(e))
          , a = {
            ...e,
            ...t
        };
        for (const r of o) {
            const n = kg(e[r], t[r]);
            if (!n.valid)
                return {
                    valid: !1
                };
            a[r] = n.data
        }
        return {
            valid: !0,
            data: a
        }
    }
    if (n === mm.array && o === mm.array) {
        if (e.length !== t.length)
            return {
                valid: !1
            };
        const n = [];
        for (let o = 0; o < e.length; o++) {
            const a = kg(e[o], t[o]);
            if (!a.valid)
                return {
                    valid: !1
                };
            n.push(a.data)
        }
        return {
            valid: !0,
            data: n
        }
    }
    return n === mm.date && o === mm.date && +e === +t ? {
        valid: !0,
        data: e
    } : {
        valid: !1
    }
}
xg.create = (e, t) => new xg({
    options: e,
    typeName: Hg.ZodUnion,
    ...Rm(t)
});
class Sg extends zm {
    _parse(e) {
        const {status: t, ctx: n} = this._processInputParams(e)
          , o = (e, o) => {
            if (Tm(e) || Tm(o))
                return Sm;
            const a = kg(e.value, o.value);
            return a.valid ? ((Am(e) || Am(o)) && t.dirty(),
            {
                status: t.value,
                value: a.data
            }) : (xm(n, {
                code: ym.invalid_intersection_types
            }),
            Sm)
        }
        ;
        return n.common.async ? Promise.all([this._def.left._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        })]).then( ([e,t]) => o(e, t)) : o(this._def.left._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }))
    }
}
Sg.create = (e, t, n) => new Sg({
    left: e,
    right: t,
    typeName: Hg.ZodIntersection,
    ...Rm(n)
});
class Cg extends zm {
    _parse(e) {
        const {status: t, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== mm.array)
            return xm(n, {
                code: ym.invalid_type,
                expected: mm.array,
                received: n.parsedType
            }),
            Sm;
        if (n.data.length < this._def.items.length)
            return xm(n, {
                code: ym.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            Sm;
        !this._def.rest && n.data.length > this._def.items.length && (xm(n, {
            code: ym.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }),
        t.dirty());
        const o = [...n.data].map( (e, t) => {
            const o = this._def.items[t] || this._def.rest;
            return o ? o._parse(new Im(n,e,n.path,t)) : null
        }
        ).filter(e => !!e);
        return n.common.async ? Promise.all(o).then(e => km.mergeArray(t, e)) : km.mergeArray(t, o)
    }
    get items() {
        return this._def.items
    }
    rest(e) {
        return new Cg({
            ...this._def,
            rest: e
        })
    }
}
Cg.create = (e, t) => {
    if (!Array.isArray(e))
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new Cg({
        items: e,
        typeName: Hg.ZodTuple,
        rest: null,
        ...Rm(t)
    })
}
;
class Eg extends zm {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(e) {
        const {status: t, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== mm.map)
            return xm(n, {
                code: ym.invalid_type,
                expected: mm.map,
                received: n.parsedType
            }),
            Sm;
        const o = this._def.keyType
          , a = this._def.valueType
          , r = [...n.data.entries()].map( ([e,t], r) => ({
            key: o._parse(new Im(n,e,n.path,[r, "key"])),
            value: a._parse(new Im(n,t,n.path,[r, "value"]))
        }));
        if (n.common.async) {
            const e = new Map;
            return Promise.resolve().then(async () => {
                for (const n of r) {
                    const o = await n.key
                      , a = await n.value;
                    if ("aborted" === o.status || "aborted" === a.status)
                        return Sm;
                    "dirty" !== o.status && "dirty" !== a.status || t.dirty(),
                    e.set(o.value, a.value)
                }
                return {
                    status: t.value,
                    value: e
                }
            }
            )
        }
        {
            const e = new Map;
            for (const n of r) {
                const o = n.key
                  , a = n.value;
                if ("aborted" === o.status || "aborted" === a.status)
                    return Sm;
                "dirty" !== o.status && "dirty" !== a.status || t.dirty(),
                e.set(o.value, a.value)
            }
            return {
                status: t.value,
                value: e
            }
        }
    }
}
Eg.create = (e, t, n) => new Eg({
    valueType: t,
    keyType: e,
    typeName: Hg.ZodMap,
    ...Rm(n)
});
class Tg extends zm {
    _parse(e) {
        const {status: t, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== mm.set)
            return xm(n, {
                code: ym.invalid_type,
                expected: mm.set,
                received: n.parsedType
            }),
            Sm;
        const o = this._def;
        null !== o.minSize && n.data.size < o.minSize.value && (xm(n, {
            code: ym.too_small,
            minimum: o.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: o.minSize.message
        }),
        t.dirty()),
        null !== o.maxSize && n.data.size > o.maxSize.value && (xm(n, {
            code: ym.too_big,
            maximum: o.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: o.maxSize.message
        }),
        t.dirty());
        const a = this._def.valueType;
        function r(e) {
            const n = new Set;
            for (const o of e) {
                if ("aborted" === o.status)
                    return Sm;
                "dirty" === o.status && t.dirty(),
                n.add(o.value)
            }
            return {
                status: t.value,
                value: n
            }
        }
        const s = [...n.data.values()].map( (e, t) => a._parse(new Im(n,e,n.path,t)));
        return n.common.async ? Promise.all(s).then(e => r(e)) : r(s)
    }
    min(e, t) {
        return new Tg({
            ...this._def,
            minSize: {
                value: e,
                message: Pm.toString(t)
            }
        })
    }
    max(e, t) {
        return new Tg({
            ...this._def,
            maxSize: {
                value: e,
                message: Pm.toString(t)
            }
        })
    }
    size(e, t) {
        return this.min(e, t).max(e, t)
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
Tg.create = (e, t) => new Tg({
    valueType: e,
    minSize: null,
    maxSize: null,
    typeName: Hg.ZodSet,
    ...Rm(t)
});
class Ag extends zm {
    get schema() {
        return this._def.getter()
    }
    _parse(e) {
        const {ctx: t} = this._processInputParams(e);
        return this._def.getter()._parse({
            data: t.data,
            path: t.path,
            parent: t
        })
    }
}
Ag.create = (e, t) => new Ag({
    getter: e,
    typeName: Hg.ZodLazy,
    ...Rm(t)
});
class Og extends zm {
    _parse(e) {
        if (e.data !== this._def.value) {
            const t = this._getOrReturnCtx(e);
            return xm(t, {
                received: t.data,
                code: ym.invalid_literal,
                expected: this._def.value
            }),
            Sm
        }
        return {
            status: "valid",
            value: e.data
        }
    }
    get value() {
        return this._def.value
    }
}
function Mg(e, t) {
    return new Pg({
        values: e,
        typeName: Hg.ZodEnum,
        ...Rm(t)
    })
}
Og.create = (e, t) => new Og({
    value: e,
    typeName: Hg.ZodLiteral,
    ...Rm(t)
});
class Pg extends zm {
    _parse(e) {
        if ("string" != typeof e.data) {
            const t = this._getOrReturnCtx(e)
              , n = this._def.values;
            return xm(t, {
                expected: fm.joinValues(n),
                received: t.parsedType,
                code: ym.invalid_type
            }),
            Sm
        }
        if (this._cache || (this._cache = new Set(this._def.values)),
        !this._cache.has(e.data)) {
            const t = this._getOrReturnCtx(e)
              , n = this._def.values;
            return xm(t, {
                received: t.data,
                code: ym.invalid_enum_value,
                options: n
            }),
            Sm
        }
        return Em(e.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        const e = {};
        for (const t of this._def.values)
            e[t] = t;
        return e
    }
    get Values() {
        const e = {};
        for (const t of this._def.values)
            e[t] = t;
        return e
    }
    get Enum() {
        const e = {};
        for (const t of this._def.values)
            e[t] = t;
        return e
    }
    extract(e, t=this._def) {
        return Pg.create(e, {
            ...this._def,
            ...t
        })
    }
    exclude(e, t=this._def) {
        return Pg.create(this.options.filter(t => !e.includes(t)), {
            ...this._def,
            ...t
        })
    }
}
Pg.create = Mg;
class Bg extends zm {
    _parse(e) {
        const t = fm.getValidEnumValues(this._def.values)
          , n = this._getOrReturnCtx(e);
        if (n.parsedType !== mm.string && n.parsedType !== mm.number) {
            const e = fm.objectValues(t);
            return xm(n, {
                expected: fm.joinValues(e),
                received: n.parsedType,
                code: ym.invalid_type
            }),
            Sm
        }
        if (this._cache || (this._cache = new Set(fm.getValidEnumValues(this._def.values))),
        !this._cache.has(e.data)) {
            const e = fm.objectValues(t);
            return xm(n, {
                received: n.data,
                code: ym.invalid_enum_value,
                options: e
            }),
            Sm
        }
        return Em(e.data)
    }
    get enum() {
        return this._def.values
    }
}
Bg.create = (e, t) => new Bg({
    values: e,
    typeName: Hg.ZodNativeEnum,
    ...Rm(t)
});
class Ig extends zm {
    unwrap() {
        return this._def.type
    }
    _parse(e) {
        const {ctx: t} = this._processInputParams(e);
        if (t.parsedType !== mm.promise && !1 === t.common.async)
            return xm(t, {
                code: ym.invalid_type,
                expected: mm.promise,
                received: t.parsedType
            }),
            Sm;
        const n = t.parsedType === mm.promise ? t.data : Promise.resolve(t.data);
        return Em(n.then(e => this._def.type.parseAsync(e, {
            path: t.path,
            errorMap: t.common.contextualErrorMap
        })))
    }
}
Ig.create = (e, t) => new Ig({
    type: e,
    typeName: Hg.ZodPromise,
    ...Rm(t)
});
class Lg extends zm {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === Hg.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(e) {
        const {status: t, ctx: n} = this._processInputParams(e)
          , o = this._def.effect || null
          , a = {
            addIssue: e => {
                xm(n, e),
                e.fatal ? t.abort() : t.dirty()
            }
            ,
            get path() {
                return n.path
            }
        };
        if (a.addIssue = a.addIssue.bind(a),
        "preprocess" === o.type) {
            const e = o.transform(n.data, a);
            if (n.common.async)
                return Promise.resolve(e).then(async e => {
                    if ("aborted" === t.value)
                        return Sm;
                    const o = await this._def.schema._parseAsync({
                        data: e,
                        path: n.path,
                        parent: n
                    });
                    return "aborted" === o.status ? Sm : "dirty" === o.status || "dirty" === t.value ? Cm(o.value) : o
                }
                );
            {
                if ("aborted" === t.value)
                    return Sm;
                const o = this._def.schema._parseSync({
                    data: e,
                    path: n.path,
                    parent: n
                });
                return "aborted" === o.status ? Sm : "dirty" === o.status || "dirty" === t.value ? Cm(o.value) : o
            }
        }
        if ("refinement" === o.type) {
            const e = e => {
                const t = o.refinement(e, a);
                if (n.common.async)
                    return Promise.resolve(t);
                if (t instanceof Promise)
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return e
            }
            ;
            if (!1 === n.common.async) {
                const o = this._def.schema._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                return "aborted" === o.status ? Sm : ("dirty" === o.status && t.dirty(),
                e(o.value),
                {
                    status: t.value,
                    value: o.value
                })
            }
            return this._def.schema._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }).then(n => "aborted" === n.status ? Sm : ("dirty" === n.status && t.dirty(),
            e(n.value).then( () => ({
                status: t.value,
                value: n.value
            }))))
        }
        if ("transform" === o.type) {
            if (!1 === n.common.async) {
                const e = this._def.schema._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                if (!Om(e))
                    return Sm;
                const r = o.transform(e.value, a);
                if (r instanceof Promise)
                    throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: t.value,
                    value: r
                }
            }
            return this._def.schema._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }).then(e => Om(e) ? Promise.resolve(o.transform(e.value, a)).then(e => ({
                status: t.value,
                value: e
            })) : Sm)
        }
        fm.assertNever(o)
    }
}
Lg.create = (e, t, n) => new Lg({
    schema: e,
    typeName: Hg.ZodEffects,
    effect: t,
    ...Rm(n)
}),
Lg.createWithPreprocess = (e, t, n) => new Lg({
    schema: t,
    effect: {
        type: "preprocess",
        transform: e
    },
    typeName: Hg.ZodEffects,
    ...Rm(n)
});
class Rg extends zm {
    _parse(e) {
        return this._getType(e) === mm.undefined ? Em(void 0) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
Rg.create = (e, t) => new Rg({
    innerType: e,
    typeName: Hg.ZodOptional,
    ...Rm(t)
});
class zg extends zm {
    _parse(e) {
        return this._getType(e) === mm.null ? Em(null) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
zg.create = (e, t) => new zg({
    innerType: e,
    typeName: Hg.ZodNullable,
    ...Rm(t)
});
class Ng extends zm {
    _parse(e) {
        const {ctx: t} = this._processInputParams(e);
        let n = t.data;
        return t.parsedType === mm.undefined && (n = this._def.defaultValue()),
        this._def.innerType._parse({
            data: n,
            path: t.path,
            parent: t
        })
    }
    removeDefault() {
        return this._def.innerType
    }
}
Ng.create = (e, t) => new Ng({
    innerType: e,
    typeName: Hg.ZodDefault,
    defaultValue: "function" == typeof t.default ? t.default : () => t.default,
    ...Rm(t)
});
class Dg extends zm {
    _parse(e) {
        const {ctx: t} = this._processInputParams(e)
          , n = {
            ...t,
            common: {
                ...t.common,
                issues: []
            }
        }
          , o = this._def.innerType._parse({
            data: n.data,
            path: n.path,
            parent: {
                ...n
            }
        });
        return Mm(o) ? o.then(e => ({
            status: "valid",
            value: "valid" === e.status ? e.value : this._def.catchValue({
                get error() {
                    return new bm(n.common.issues)
                },
                input: n.data
            })
        })) : {
            status: "valid",
            value: "valid" === o.status ? o.value : this._def.catchValue({
                get error() {
                    return new bm(n.common.issues)
                },
                input: n.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
Dg.create = (e, t) => new Dg({
    innerType: e,
    typeName: Hg.ZodCatch,
    catchValue: "function" == typeof t.catch ? t.catch : () => t.catch,
    ...Rm(t)
});
class jg extends zm {
    _parse(e) {
        if (this._getType(e) !== mm.nan) {
            const t = this._getOrReturnCtx(e);
            return xm(t, {
                code: ym.invalid_type,
                expected: mm.nan,
                received: t.parsedType
            }),
            Sm
        }
        return {
            status: "valid",
            value: e.data
        }
    }
}
jg.create = e => new jg({
    typeName: Hg.ZodNaN,
    ...Rm(e)
});
class Fg extends zm {
    _parse(e) {
        const {ctx: t} = this._processInputParams(e)
          , n = t.data;
        return this._def.type._parse({
            data: n,
            path: t.path,
            parent: t
        })
    }
    unwrap() {
        return this._def.type
    }
}
class $g extends zm {
    _parse(e) {
        const {status: t, ctx: n} = this._processInputParams(e);
        if (n.common.async) {
            return (async () => {
                const e = await this._def.in._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                return "aborted" === e.status ? Sm : "dirty" === e.status ? (t.dirty(),
                Cm(e.value)) : this._def.out._parseAsync({
                    data: e.value,
                    path: n.path,
                    parent: n
                })
            }
            )()
        }
        {
            const e = this._def.in._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return "aborted" === e.status ? Sm : "dirty" === e.status ? (t.dirty(),
            {
                status: "dirty",
                value: e.value
            }) : this._def.out._parseSync({
                data: e.value,
                path: n.path,
                parent: n
            })
        }
    }
    static create(e, t) {
        return new $g({
            in: e,
            out: t,
            typeName: Hg.ZodPipeline
        })
    }
}
class Vg extends zm {
    _parse(e) {
        const t = this._def.innerType._parse(e)
          , n = e => (Om(e) && (e.value = Object.freeze(e.value)),
        e);
        return Mm(t) ? t.then(e => n(e)) : n(t)
    }
    unwrap() {
        return this._def.innerType
    }
}
var Hg, Ug;
Vg.create = (e, t) => new Vg({
    innerType: e,
    typeName: Hg.ZodReadonly,
    ...Rm(t)
}),
(Ug = Hg || (Hg = {})).ZodString = "ZodString",
Ug.ZodNumber = "ZodNumber",
Ug.ZodNaN = "ZodNaN",
Ug.ZodBigInt = "ZodBigInt",
Ug.ZodBoolean = "ZodBoolean",
Ug.ZodDate = "ZodDate",
Ug.ZodSymbol = "ZodSymbol",
Ug.ZodUndefined = "ZodUndefined",
Ug.ZodNull = "ZodNull",
Ug.ZodAny = "ZodAny",
Ug.ZodUnknown = "ZodUnknown",
Ug.ZodNever = "ZodNever",
Ug.ZodVoid = "ZodVoid",
Ug.ZodArray = "ZodArray",
Ug.ZodObject = "ZodObject",
Ug.ZodUnion = "ZodUnion",
Ug.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
Ug.ZodIntersection = "ZodIntersection",
Ug.ZodTuple = "ZodTuple",
Ug.ZodRecord = "ZodRecord",
Ug.ZodMap = "ZodMap",
Ug.ZodSet = "ZodSet",
Ug.ZodFunction = "ZodFunction",
Ug.ZodLazy = "ZodLazy",
Ug.ZodLiteral = "ZodLiteral",
Ug.ZodEnum = "ZodEnum",
Ug.ZodEffects = "ZodEffects",
Ug.ZodNativeEnum = "ZodNativeEnum",
Ug.ZodOptional = "ZodOptional",
Ug.ZodNullable = "ZodNullable",
Ug.ZodDefault = "ZodDefault",
Ug.ZodCatch = "ZodCatch",
Ug.ZodPromise = "ZodPromise",
Ug.ZodBranded = "ZodBranded",
Ug.ZodPipeline = "ZodPipeline",
Ug.ZodReadonly = "ZodReadonly";
const Zg = sg.create
  , qg = lg.create;
gg.create,
bg.create;
const Wg = _g.create;
/**
  * vee-validate v4.15.1
  * (c) 2025 Abdelrahman Awad
  * @license MIT
  */
function Gg(e) {
    return "function" == typeof e
}
function Kg(e) {
    return null == e
}
xg.create,
Sg.create,
Cg.create,
Pg.create,
Ig.create,
Rg.create,
zg.create;
const Yg = e => null !== e && !!e && "object" == typeof e && !Array.isArray(e);
function Xg(e) {
    return Number(e) >= 0
}
function Jg(e) {
    if (!function(e) {
        return "object" == typeof e && null !== e
    }(e) || "[object Object]" !== function(e) {
        return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e)
    }(e))
        return !1;
    if (null === Object.getPrototypeOf(e))
        return !0;
    let t = e;
    for (; null !== Object.getPrototypeOf(t); )
        t = Object.getPrototypeOf(t);
    return Object.getPrototypeOf(e) === t
}
function Qg(e, t) {
    return Object.keys(t).forEach(n => {
        if (Jg(t[n]) && Jg(e[n]))
            return e[n] || (e[n] = {}),
            void Qg(e[n], t[n]);
        e[n] = t[n]
    }
    ),
    e
}
function ey(e) {
    const t = e.split(".");
    if (!t.length)
        return "";
    let n = String(t[0]);
    for (let o = 1; o < t.length; o++)
        Xg(t[o]) ? n += `[${t[o]}]` : n += `.${t[o]}`;
    return n
}
const ty = {};
function ny(e, t, n) {
    "object" == typeof n.value && (n.value = oy(n.value)),
    n.enumerable && !n.get && !n.set && n.configurable && n.writable && "__proto__" !== t ? e[t] = n.value : Object.defineProperty(e, t, n)
}
function oy(e) {
    if ("object" != typeof e)
        return e;
    var t, n, o, a = 0, r = Object.prototype.toString.call(e);
    if ("[object Object]" === r ? o = Object.create(e.__proto__ || null) : "[object Array]" === r ? o = Array(e.length) : "[object Set]" === r ? (o = new Set,
    e.forEach(function(e) {
        o.add(oy(e))
    })) : "[object Map]" === r ? (o = new Map,
    e.forEach(function(e, t) {
        o.set(oy(t), oy(e))
    })) : "[object Date]" === r ? o = new Date(+e) : "[object RegExp]" === r ? o = new RegExp(e.source,e.flags) : "[object DataView]" === r ? o = new e.constructor(oy(e.buffer)) : "[object ArrayBuffer]" === r ? o = e.slice(0) : "Array]" === r.slice(-6) && (o = new e.constructor(e)),
    o) {
        for (n = Object.getOwnPropertySymbols(e); a < n.length; a++)
            ny(o, n[a], Object.getOwnPropertyDescriptor(e, n[a]));
        for (a = 0,
        n = Object.getOwnPropertyNames(e); a < n.length; a++)
            Object.hasOwnProperty.call(o, t = n[a]) && o[t] === e[t] || ny(o, t, Object.getOwnPropertyDescriptor(e, t))
    }
    return o || e
}
const ay = Symbol("vee-validate-form")
  , ry = Symbol("vee-validate-form-context")
  , sy = "undefined" != typeof window;
function iy(e) {
    return !!e && Gg(e.parse) && "VVTypedSchema" === e.__type
}
function ly(e) {
    return !!e && Gg(e.validate)
}
function uy(e) {
    return Array.isArray(e) ? 0 === e.length : Yg(e) && 0 === Object.keys(e).length
}
function cy(e) {
    return /^\[.+\]$/i.test(e)
}
function dy(e) {
    return "SELECT" === e.tagName
}
function py(e) {
    return !!e && (!!("undefined" != typeof Event && Gg(Event) && e instanceof Event) || !(!e || !e.srcElement))
}
function fy(e, t) {
    if (e === t)
        return !0;
    if (e && t && "object" == typeof e && "object" == typeof t) {
        if (e.constructor !== t.constructor)
            return !1;
        var n, o, a;
        if (Array.isArray(e)) {
            if ((n = e.length) != t.length)
                return !1;
            for (o = n; 0 !== o--; )
                if (!fy(e[o], t[o]))
                    return !1;
            return !0
        }
        if (e instanceof Map && t instanceof Map) {
            if (e.size !== t.size)
                return !1;
            for (o of e.entries())
                if (!t.has(o[0]))
                    return !1;
            for (o of e.entries())
                if (!fy(o[1], t.get(o[0])))
                    return !1;
            return !0
        }
        if (vy(e) && vy(t))
            return e.size === t.size && (e.name === t.name && (e.lastModified === t.lastModified && e.type === t.type));
        if (e instanceof Set && t instanceof Set) {
            if (e.size !== t.size)
                return !1;
            for (o of e.entries())
                if (!t.has(o[0]))
                    return !1;
            return !0
        }
        if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
            if ((n = e.length) != t.length)
                return !1;
            for (o = n; 0 !== o--; )
                if (e[o] !== t[o])
                    return !1;
            return !0
        }
        if (e.constructor === RegExp)
            return e.source === t.source && e.flags === t.flags;
        if (e.valueOf !== Object.prototype.valueOf)
            return e.valueOf() === t.valueOf();
        if (e.toString !== Object.prototype.toString)
            return e.toString() === t.toString();
        if (e = hy(e),
        t = hy(t),
        (n = (a = Object.keys(e)).length) !== Object.keys(t).length)
            return !1;
        for (o = n; 0 !== o--; )
            if (!Object.prototype.hasOwnProperty.call(t, a[o]))
                return !1;
        for (o = n; 0 !== o--; ) {
            var r = a[o];
            if (!fy(e[r], t[r]))
                return !1
        }
        return !0
    }
    return e != e && t != t
}
function hy(e) {
    return Object.fromEntries(Object.entries(e).filter( ([,e]) => void 0 !== e))
}
function vy(e) {
    return !!sy && e instanceof File
}
function my(e) {
    return cy(e) ? e.replace(/\[|\]/gi, "") : e
}
function gy(e, t, n) {
    if (!e)
        return n;
    if (cy(t))
        return e[my(t)];
    return (t || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce( (e, t) => {
        return (Yg(o = e) || Array.isArray(o)) && t in e ? e[t] : n;
        var o
    }
    , e)
}
function yy(e, t, n) {
    if (cy(t))
        return void (e[my(t)] = n);
    const o = t.split(/\.|\[(\d+)\]/).filter(Boolean);
    let a = e;
    for (let r = 0; r < o.length; r++) {
        if (r === o.length - 1)
            return void (a[o[r]] = n);
        o[r]in a && !Kg(a[o[r]]) || (a[o[r]] = Xg(o[r + 1]) ? [] : {}),
        a = a[o[r]]
    }
}
function by(e, t) {
    Array.isArray(e) && Xg(t) ? e.splice(Number(t), 1) : Yg(e) && delete e[t]
}
function wy(e, t) {
    if (cy(t))
        return void delete e[my(t)];
    const n = t.split(/\.|\[(\d+)\]/).filter(Boolean);
    let o = e;
    for (let r = 0; r < n.length; r++) {
        if (r === n.length - 1) {
            by(o, n[r]);
            break
        }
        if (!(n[r]in o) || Kg(o[n[r]]))
            break;
        o = o[n[r]]
    }
    const a = n.map( (t, o) => gy(e, n.slice(0, o).join(".")));
    for (let r = a.length - 1; r >= 0; r--)
        uy(a[r]) && (0 !== r ? by(a[r - 1], n[r - 1]) : by(e, n[0]))
}
function _y(e) {
    return Object.keys(e)
}
function xy(e, t=0) {
    let n = null
      , o = [];
    return function(...a) {
        return n && clearTimeout(n),
        n = setTimeout( () => {
            const t = e(...a);
            o.forEach(e => e(t)),
            o = []
        }
        , t),
        new Promise(e => o.push(e))
    }
}
function ky(e) {
    return Array.isArray(e) ? e : e ? [e] : []
}
function Sy(e, t) {
    const n = {};
    for (const o in e)
        t.includes(o) || (n[o] = e[o]);
    return n
}
function Cy(e) {
    if (Ey(e))
        return e._value
}
function Ey(e) {
    return "_value"in e
}
function Ty(e) {
    if (!py(e))
        return e;
    const t = e.target;
    if (("checkbox" === (n = t.type) || "radio" === n) && Ey(t))
        return Cy(t);
    var n, o;
    if ("file" === t.type && t.files) {
        const e = Array.from(t.files);
        return t.multiple ? e : e[0]
    }
    if (dy(o = t) && o.multiple)
        return Array.from(t.options).filter(e => e.selected && !e.disabled).map(Cy);
    if (dy(t)) {
        const e = Array.from(t.options).find(e => e.selected);
        return e ? Cy(e) : t.value
    }
    return function(e) {
        return "number" === e.type || "range" === e.type ? Number.isNaN(e.valueAsNumber) ? e.value : e.valueAsNumber : e.value
    }(t)
}
function Ay(e) {
    const t = {};
    return Object.defineProperty(t, "_$$isNormalized", {
        value: !0,
        writable: !1,
        enumerable: !1,
        configurable: !1
    }),
    e ? Yg(e) && e._$$isNormalized ? e : Yg(e) ? Object.keys(e).reduce( (t, n) => {
        const o = function(e) {
            if (!0 === e)
                return [];
            if (Array.isArray(e))
                return e;
            if (Yg(e))
                return e;
            return [e]
        }(e[n]);
        return !1 !== e[n] && (t[n] = Oy(o)),
        t
    }
    , t) : "string" != typeof e ? t : e.split("|").reduce( (e, t) => {
        const n = My(t);
        return n.name ? (e[n.name] = Oy(n.params),
        e) : e
    }
    , t) : t
}
function Oy(e) {
    const t = e => "string" == typeof e && "@" === e[0] ? function(e) {
        const t = t => {
            var n;
            return null !== (n = gy(t, e)) && void 0 !== n ? n : t[e]
        }
        ;
        return t.__locatorRef = e,
        t
    }(e.slice(1)) : e;
    return Array.isArray(e) ? e.map(t) : e instanceof RegExp ? [e] : Object.keys(e).reduce( (n, o) => (n[o] = t(e[o]),
    n), {})
}
const My = e => {
    let t = [];
    const n = e.split(":")[0];
    return e.includes(":") && (t = e.split(":").slice(1).join(":").split(",")),
    {
        name: n,
        params: t
    }
}
;
let Py = Object.assign({}, {
    generateMessage: ({field: e}) => `${e} is not valid.`,
    bails: !0,
    validateOnBlur: !0,
    validateOnChange: !0,
    validateOnInput: !1,
    validateOnModelUpdate: !0
});
const By = () => Py;
async function Iy(e, t, n={}) {
    const o = null == n ? void 0 : n.bails
      , a = {
        name: (null == n ? void 0 : n.name) || "{field}",
        rules: t,
        label: null == n ? void 0 : n.label,
        bails: null == o || o,
        formData: (null == n ? void 0 : n.values) || {}
    }
      , r = await async function(e, t) {
        const n = e.rules;
        if (iy(n) || ly(n))
            return async function(e, t) {
                const n = iy(t.rules) ? t.rules : Ly(t.rules)
                  , o = await n.parse(e, {
                    formData: t.formData
                })
                  , a = [];
                for (const r of o.errors)
                    r.errors.length && a.push(...r.errors);
                return {
                    value: o.value,
                    errors: a
                }
            }(t, Object.assign(Object.assign({}, e), {
                rules: n
            }));
        if (Gg(n) || Array.isArray(n)) {
            const o = {
                field: e.label || e.name,
                name: e.name,
                label: e.label,
                form: e.formData,
                value: t
            }
              , a = Array.isArray(n) ? n : [n]
              , r = a.length
              , s = [];
            for (let n = 0; n < r; n++) {
                const r = a[n]
                  , i = await r(t, o);
                if (!("string" != typeof i && !Array.isArray(i) && i)) {
                    if (Array.isArray(i))
                        s.push(...i);
                    else {
                        const e = "string" == typeof i ? i : zy(o);
                        s.push(e)
                    }
                    if (e.bails)
                        return {
                            errors: s
                        }
                }
            }
            return {
                errors: s
            }
        }
        const o = Object.assign(Object.assign({}, e), {
            rules: Ay(n)
        })
          , a = []
          , r = Object.keys(o.rules)
          , s = r.length;
        for (let i = 0; i < s; i++) {
            const n = r[i]
              , s = await Ry(o, t, {
                name: n,
                params: o.rules[n]
            });
            if (s.error && (a.push(s.error),
            e.bails))
                return {
                    errors: a
                }
        }
        return {
            errors: a
        }
    }(a, e);
    return Object.assign(Object.assign({}, r), {
        valid: !r.errors.length
    })
}
function Ly(e) {
    return {
        __type: "VVTypedSchema",
        async parse(t, n) {
            var o;
            try {
                return {
                    output: await e.validate(t, {
                        abortEarly: !1,
                        context: (null == n ? void 0 : n.formData) || {}
                    }),
                    errors: []
                }
            } catch (a) {
                if (!function(e) {
                    return !!e && "ValidationError" === e.name
                }(a))
                    throw a;
                if (!(null === (o = a.inner) || void 0 === o ? void 0 : o.length) && a.errors.length)
                    return {
                        errors: [{
                            path: a.path,
                            errors: a.errors
                        }]
                    };
                const e = a.inner.reduce( (e, t) => {
                    const n = t.path || "";
                    return e[n] || (e[n] = {
                        errors: [],
                        path: n
                    }),
                    e[n].errors.push(...t.errors),
                    e
                }
                , {});
                return {
                    errors: Object.values(e)
                }
            }
        }
    }
}
async function Ry(e, t, n) {
    const o = (a = n.name,
    ty[a]);
    var a;
    if (!o)
        throw new Error(`No such validator '${n.name}' exists.`);
    const r = function(e, t) {
        const n = e => function(e) {
            return Gg(e) && !!e.__locatorRef
        }(e) ? e(t) : e;
        if (Array.isArray(e))
            return e.map(n);
        return Object.keys(e).reduce( (t, o) => (t[o] = n(e[o]),
        t), {})
    }(n.params, e.formData)
      , s = {
        field: e.label || e.name,
        name: e.name,
        label: e.label,
        value: t,
        form: e.formData,
        rule: Object.assign(Object.assign({}, n), {
            params: r
        })
    }
      , i = await o(t, r, s);
    return "string" == typeof i ? {
        error: i
    } : {
        error: i ? void 0 : zy(s)
    }
}
function zy(e) {
    const t = By().generateMessage;
    return t ? t(e) : "Field is invalid"
}
let Ny = 0;
const Dy = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];
function jy(e) {
    const t = (null == e ? void 0 : e.initialValues) || {}
      , n = Object.assign({}, Dt(t))
      , o = Nt(null == e ? void 0 : e.validationSchema);
    return o && iy(o) && Gg(o.cast) ? oy(o.cast(n) || {}) : oy(n)
}
function Fy(e) {
    var t;
    const n = Ny++
      , o = (null == e ? void 0 : e.name) || "Form";
    let a = 0;
    const r = It(!1)
      , s = It(!1)
      , i = It(0)
      , l = []
      , u = bt(jy(e))
      , c = It([])
      , d = It({})
      , p = It({})
      , f = function(e) {
        let t = null
          , n = [];
        return function(...o) {
            const a = fn( () => {
                if (t !== a)
                    return;
                const r = e(...o);
                n.forEach(e => e(r)),
                n = [],
                t = null
            }
            );
            return t = a,
            new Promise(e => n.push(e))
        }
    }( () => {
        p.value = c.value.reduce( (e, t) => (e[ey(Dt(t.path))] = t,
        e), {})
    }
    );
    function h(e, t) {
        const n = I(e);
        if (n) {
            if ("string" == typeof e) {
                const t = ey(e);
                d.value[t] && delete d.value[t]
            }
            n.errors = ky(t),
            n.valid = !n.errors.length
        } else
            "string" == typeof e && (d.value[ey(e)] = ky(t))
    }
    function v(e) {
        _y(e).forEach(t => {
            h(t, e[t])
        }
        )
    }
    (null == e ? void 0 : e.initialErrors) && v(e.initialErrors);
    const m = ms( () => {
        const e = c.value.reduce( (e, t) => (t.errors.length && (e[Dt(t.path)] = t.errors),
        e), {});
        return Object.assign(Object.assign({}, d.value), e)
    }
    )
      , g = ms( () => _y(m.value).reduce( (e, t) => {
        const n = m.value[t];
        return (null == n ? void 0 : n.length) && (e[t] = n[0]),
        e
    }
    , {}))
      , y = ms( () => c.value.reduce( (e, t) => (e[Dt(t.path)] = {
        name: Dt(t.path) || "",
        label: t.label || ""
    },
    e), {}))
      , b = ms( () => c.value.reduce( (e, t) => {
        var n;
        return e[Dt(t.path)] = null === (n = t.bails) || void 0 === n || n,
        e
    }
    , {}))
      , w = Object.assign({}, (null == e ? void 0 : e.initialErrors) || {})
      , _ = null !== (t = null == e ? void 0 : e.keepValuesOnUnmount) && void 0 !== t && t
      , {initialValues: x, originalInitialValues: k, setInitialValues: S} = function(e, t, n) {
        const o = jy(n)
          , a = It(o)
          , r = It(oy(o));
        function s(n, o) {
            (null == o ? void 0 : o.force) ? (a.value = oy(n),
            r.value = oy(n)) : (a.value = Qg(oy(a.value) || {}, oy(n)),
            r.value = Qg(oy(r.value) || {}, oy(n))),
            (null == o ? void 0 : o.updateFields) && e.value.forEach(e => {
                if (e.touched)
                    return;
                const n = gy(a.value, Dt(e.path));
                yy(t, Dt(e.path), oy(n))
            }
            )
        }
        return {
            initialValues: a,
            originalInitialValues: r,
            setInitialValues: s
        }
    }(c, u, e)
      , C = function(e, t, n, o) {
        const a = {
            touched: "some",
            pending: "some",
            valid: "every"
        }
          , r = ms( () => !fy(t, Nt(n)));
        function s() {
            const t = e.value;
            return _y(a).reduce( (e, n) => {
                const o = a[n];
                return e[n] = t[o](e => e[n]),
                e
            }
            , {})
        }
        const i = bt(s());
        return Ya( () => {
            const e = s();
            i.touched = e.touched,
            i.valid = e.valid,
            i.pending = e.pending
        }
        ),
        ms( () => Object.assign(Object.assign({
            initialValues: Nt(n)
        }, i), {
            valid: i.valid && !_y(o.value).length,
            dirty: r.value
        }))
    }(c, u, k, g)
      , E = ms( () => c.value.reduce( (e, t) => {
        const n = gy(u, Dt(t.path));
        return yy(e, Dt(t.path), n),
        e
    }
    , {}))
      , T = null == e ? void 0 : e.validationSchema;
    function A(e, t) {
        var n, o;
        const r = ms( () => gy(x.value, Dt(e)))
          , s = p.value[Dt(e)]
          , i = "checkbox" === (null == t ? void 0 : t.type) || "radio" === (null == t ? void 0 : t.type);
        if (s && i) {
            s.multiple = !0;
            const e = a++;
            return Array.isArray(s.id) ? s.id.push(e) : s.id = [s.id, e],
            s.fieldsCount++,
            s.__flags.pendingUnmount[e] = !1,
            s
        }
        const l = ms( () => gy(u, Dt(e)))
          , d = Dt(e)
          , h = R.findIndex(e => e === d);
        -1 !== h && R.splice(h, 1);
        const v = ms( () => {
            var n, o, a, r;
            const s = Dt(T);
            if (iy(s))
                return null !== (o = null === (n = s.describe) || void 0 === n ? void 0 : n.call(s, Dt(e)).required) && void 0 !== o && o;
            const i = Dt(null == t ? void 0 : t.schema);
            return !!iy(i) && (null !== (r = null === (a = i.describe) || void 0 === a ? void 0 : a.call(i).required) && void 0 !== r && r)
        }
        )
          , m = a++
          , y = bt({
            id: m,
            path: e,
            touched: !1,
            pending: !1,
            valid: !0,
            validated: !!(null === (n = w[d]) || void 0 === n ? void 0 : n.length),
            required: v,
            initialValue: r,
            errors: Lt([]),
            bails: null !== (o = null == t ? void 0 : t.bails) && void 0 !== o && o,
            label: null == t ? void 0 : t.label,
            type: (null == t ? void 0 : t.type) || "default",
            value: l,
            multiple: !1,
            __flags: {
                pendingUnmount: {
                    [m]: !1
                },
                pendingReset: !1
            },
            fieldsCount: 1,
            validate: null == t ? void 0 : t.validate,
            dirty: ms( () => !fy(Nt(l), Nt(r)))
        });
        return c.value.push(y),
        p.value[d] = y,
        f(),
        g.value[d] && !w[d] && fn( () => {
            W(d, {
                mode: "silent"
            })
        }
        ),
        Bt(e) && Qa(e, e => {
            f();
            const t = oy(l.value);
            p.value[e] = y,
            fn( () => {
                yy(u, e, t)
            }
            )
        }
        ),
        y
    }
    const O = xy(Y, 5)
      , M = xy(Y, 5)
      , P = function(e, t) {
        let n;
        return async function(...o) {
            const a = e(...o);
            n = a;
            const r = await a;
            return a !== n ? r : (n = void 0,
            t(r, o))
        }
    }(async e => await ("silent" === e ? O() : M()), (e, [t]) => {
        const n = _y(D.errorBag.value)
          , o = [...new Set([..._y(e.results), ...c.value.map(e => e.path), ...n])].sort().reduce( (n, o) => {
            var a;
            const r = o
              , s = I(r) || function(e) {
                const t = c.value.filter(t => e.startsWith(Dt(t.path)));
                return t.reduce( (e, t) => e ? t.path.length > e.path.length ? t : e : t, void 0)
            }(r)
              , i = (null === (a = e.results[r]) || void 0 === a ? void 0 : a.errors) || []
              , l = Dt(null == s ? void 0 : s.path) || r
              , u = function(e, t) {
                if (!t)
                    return e;
                return {
                    valid: e.valid && t.valid,
                    errors: [...e.errors, ...t.errors]
                }
            }/**
  * vee-validate v4.15.1
  * (c) 2025 Abdelrahman Awad
  * @license MIT
  */
            ({
                errors: i,
                valid: !i.length
            }, n.results[l]);
            return n.results[l] = u,
            u.valid || (n.errors[l] = u.errors[0]),
            s && d.value[l] && delete d.value[l],
            s ? (s.valid = u.valid,
            "silent" === t ? n : "validated-only" !== t || s.validated ? (h(s, u.errors),
            n) : n) : (h(l, i),
            n)
        }
        , {
            valid: e.valid,
            results: {},
            errors: {},
            source: e.source
        });
        return e.values && (o.values = e.values,
        o.source = e.source),
        _y(o.results).forEach(e => {
            var n;
            const a = I(e);
            a && "silent" !== t && ("validated-only" !== t || a.validated) && h(a, null === (n = o.results[e]) || void 0 === n ? void 0 : n.errors)
        }
        ),
        o
    }
    );
    function B(e) {
        c.value.forEach(e)
    }
    function I(e) {
        const t = "string" == typeof e ? ey(e) : e;
        return "string" == typeof t ? p.value[t] : t
    }
    let L, R = [];
    function z(e) {
        return function(t, n) {
            return function(o) {
                return o instanceof Event && (o.preventDefault(),
                o.stopPropagation()),
                B(e => e.touched = !0),
                r.value = !0,
                i.value++,
                q().then(a => {
                    const r = oy(u);
                    if (a.valid && "function" == typeof t) {
                        const n = oy(E.value);
                        let s = e ? n : r;
                        return a.values && (s = "schema" === a.source ? a.values : Object.assign({}, s, a.values)),
                        t(s, {
                            evt: o,
                            controlledValues: n,
                            setErrors: v,
                            setFieldError: h,
                            setTouched: H,
                            setFieldTouched: V,
                            setValues: F,
                            setFieldValue: j,
                            resetForm: Z,
                            resetField: U
                        })
                    }
                    a.valid || "function" != typeof n || n({
                        values: r,
                        evt: o,
                        errors: a.errors,
                        results: a.results
                    })
                }
                ).then(e => (r.value = !1,
                e), e => {
                    throw r.value = !1,
                    e
                }
                )
            }
        }
    }
    const N = z(!1);
    N.withControlled = z(!0);
    const D = {
        name: o,
        formId: n,
        values: u,
        controlledValues: E,
        errorBag: m,
        errors: g,
        schema: T,
        submitCount: i,
        meta: C,
        isSubmitting: r,
        isValidating: s,
        fieldArrays: l,
        keepValuesOnUnmount: _,
        validateSchema: Nt(T) ? P : void 0,
        validate: q,
        setFieldError: h,
        validateField: W,
        setFieldValue: j,
        setValues: F,
        setErrors: v,
        setFieldTouched: V,
        setTouched: H,
        resetForm: Z,
        resetField: U,
        handleSubmit: N,
        useFieldModel: function(e) {
            if (!Array.isArray(e))
                return $(e);
            return e.map(e => $(e, !0))
        },
        defineInputBinds: function(e, t) {
            const [n,o] = J(e, t);
            function a() {
                o.value.onBlur()
            }
            function r(t) {
                const n = Ty(t);
                j(Dt(e), n, !1),
                o.value.onInput()
            }
            function s(t) {
                const n = Ty(t);
                j(Dt(e), n, !1),
                o.value.onChange()
            }
            return ms( () => Object.assign(Object.assign({}, o.value), {
                onBlur: a,
                onInput: r,
                onChange: s,
                value: n.value
            }))
        },
        defineComponentBinds: function(e, t) {
            const [n,o] = J(e, t)
              , a = I(Dt(e));
            function r(e) {
                n.value = e
            }
            return ms( () => {
                const e = Gg(t) ? t(Sy(a, Dy)) : t || {};
                return Object.assign({
                    [e.model || "modelValue"]: n.value,
                    [`onUpdate:${e.model || "modelValue"}`]: r
                }, o.value)
            }
            )
        },
        defineField: J,
        stageInitialValue: function(t, n, o=!1) {
            K(t, n),
            yy(u, t, n),
            o && !(null == e ? void 0 : e.initialValues) && yy(k.value, t, oy(n))
        },
        unsetInitialValue: G,
        setFieldInitialValue: K,
        createPathState: A,
        getPathState: I,
        unsetPathValue: function(e) {
            return R.push(e),
            L || (L = fn( () => {
                [...R].sort().reverse().forEach(e => {
                    wy(u, e)
                }
                ),
                R = [],
                L = null
            }
            )),
            L
        },
        removePathState: function(e, t) {
            const n = c.value.findIndex(n => n.path === e && (Array.isArray(n.id) ? n.id.includes(t) : n.id === t))
              , o = c.value[n];
            if (-1 !== n && o) {
                if (fn( () => {
                    W(e, {
                        mode: "silent",
                        warn: !1
                    })
                }
                ),
                o.multiple && o.fieldsCount && o.fieldsCount--,
                Array.isArray(o.id)) {
                    const e = o.id.indexOf(t);
                    e >= 0 && o.id.splice(e, 1),
                    delete o.__flags.pendingUnmount[t]
                }
                (!o.multiple || o.fieldsCount <= 0) && (c.value.splice(n, 1),
                G(e),
                f(),
                delete p.value[e])
            }
        },
        initialValues: x,
        getAllPathStates: () => c.value,
        destroyPath: function(e) {
            _y(p.value).forEach(t => {
                t.startsWith(e) && delete p.value[t]
            }
            ),
            c.value = c.value.filter(t => !t.path.startsWith(e)),
            fn( () => {
                f()
            }
            )
        },
        isFieldTouched: function(e) {
            const t = I(e);
            if (t)
                return t.touched;
            return c.value.filter(t => t.path.startsWith(e)).some(e => e.touched)
        },
        isFieldDirty: function(e) {
            const t = I(e);
            if (t)
                return t.dirty;
            return c.value.filter(t => t.path.startsWith(e)).some(e => e.dirty)
        },
        isFieldValid: function(e) {
            const t = I(e);
            if (t)
                return t.valid;
            return c.value.filter(t => t.path.startsWith(e)).every(e => e.valid)
        }
    };
    function j(e, t, n=!0) {
        const o = oy(t)
          , a = "string" == typeof e ? e : e.path;
        I(a) || A(a),
        yy(u, a, o),
        n && W(a)
    }
    function F(e, t=!0) {
        Qg(u, e),
        l.forEach(e => e && e.reset()),
        t && q()
    }
    function $(e, t) {
        const n = I(Dt(e)) || A(e);
        return ms({
            get: () => n.value,
            set(n) {
                var o;
                j(Dt(e), n, null !== (o = Dt(t)) && void 0 !== o && o)
            }
        })
    }
    function V(e, t) {
        const n = I(e);
        n && (n.touched = t)
    }
    function H(e) {
        "boolean" != typeof e ? _y(e).forEach(t => {
            V(t, !!e[t])
        }
        ) : B(t => {
            t.touched = e
        }
        )
    }
    function U(e, t) {
        var n;
        const o = t && "value"in t ? t.value : gy(x.value, e)
          , a = I(e);
        a && (a.__flags.pendingReset = !0),
        K(e, oy(o), !0),
        j(e, o, !1),
        V(e, null !== (n = null == t ? void 0 : t.touched) && void 0 !== n && n),
        h(e, (null == t ? void 0 : t.errors) || []),
        fn( () => {
            a && (a.__flags.pendingReset = !1)
        }
        )
    }
    function Z(e, t) {
        let n = oy((null == e ? void 0 : e.values) ? e.values : k.value);
        n = (null == t ? void 0 : t.force) ? n : Qg(k.value, n),
        n = iy(T) && Gg(T.cast) ? T.cast(n) : n,
        S(n, {
            force: null == t ? void 0 : t.force
        }),
        B(t => {
            var o;
            t.__flags.pendingReset = !0,
            t.validated = !1,
            t.touched = (null === (o = null == e ? void 0 : e.touched) || void 0 === o ? void 0 : o[Dt(t.path)]) || !1,
            j(Dt(t.path), gy(n, Dt(t.path)), !1),
            h(Dt(t.path), void 0)
        }
        ),
        (null == t ? void 0 : t.force) ? function(e, t=!0) {
            _y(u).forEach(e => {
                delete u[e]
            }
            ),
            _y(e).forEach(t => {
                j(t, e[t], !1)
            }
            ),
            t && q()
        }(n, !1) : F(n, !1),
        v((null == e ? void 0 : e.errors) || {}),
        i.value = (null == e ? void 0 : e.submitCount) || 0,
        fn( () => {
            q({
                mode: "silent"
            }),
            B(e => {
                e.__flags.pendingReset = !1
            }
            )
        }
        )
    }
    async function q(e) {
        const t = (null == e ? void 0 : e.mode) || "force";
        if ("force" === t && B(e => e.validated = !0),
        D.validateSchema)
            return D.validateSchema(t);
        s.value = !0;
        const n = await Promise.all(c.value.map(t => t.validate ? t.validate(e).then(e => ({
            key: Dt(t.path),
            valid: e.valid,
            errors: e.errors,
            value: e.value
        })) : Promise.resolve({
            key: Dt(t.path),
            valid: !0,
            errors: [],
            value: void 0
        })));
        s.value = !1;
        const o = {}
          , a = {}
          , r = {};
        for (const s of n)
            o[s.key] = {
                valid: s.valid,
                errors: s.errors
            },
            s.value && yy(r, s.key, s.value),
            s.errors.length && (a[s.key] = s.errors[0]);
        return {
            valid: n.every(e => e.valid),
            results: o,
            errors: a,
            values: r,
            source: "fields"
        }
    }
    async function W(e, t) {
        const n = I(e);
        if (n && "silent" !== (null == t ? void 0 : t.mode) && (n.validated = !0),
        T) {
            const {results: n} = await P((null == t ? void 0 : t.mode) || "validated-only");
            return n[e] || {
                errors: [],
                valid: !0
            }
        }
        return (null == n ? void 0 : n.validate) ? n.validate(t) : (!n && (null == t ? void 0 : t.warn),
        Promise.resolve({
            errors: [],
            valid: !0
        }))
    }
    function G(e) {
        wy(x.value, e)
    }
    function K(e, t, n=!1) {
        yy(x.value, e, oy(t)),
        n && yy(k.value, e, oy(t))
    }
    async function Y() {
        const e = Nt(T);
        if (!e)
            return {
                valid: !0,
                results: {},
                errors: {},
                source: "none"
            };
        s.value = !0;
        const t = ly(e) || iy(e) ? await async function(e, t) {
            const n = iy(e) ? e : Ly(e)
              , o = await n.parse(oy(t), {
                formData: oy(t)
            })
              , a = {}
              , r = {};
            for (const s of o.errors) {
                const e = s.errors
                  , t = (s.path || "").replace(/\["(\d+)"\]/g, (e, t) => `[${t}]`);
                a[t] = {
                    valid: !e.length,
                    errors: e
                },
                e.length && (r[t] = e[0])
            }
            return {
                valid: !o.errors.length,
                results: a,
                errors: r,
                values: o.value,
                source: "schema"
            }
        }(e, u) : await async function(e, t, n) {
            const o = _y(e).map(async o => {
                var a, r, s;
                const i = null === (a = null == n ? void 0 : n.names) || void 0 === a ? void 0 : a[o]
                  , l = await Iy(gy(t, o), e[o], {
                    name: (null == i ? void 0 : i.name) || o,
                    label: null == i ? void 0 : i.label,
                    values: t,
                    bails: null === (s = null === (r = null == n ? void 0 : n.bailsMap) || void 0 === r ? void 0 : r[o]) || void 0 === s || s
                });
                return Object.assign(Object.assign({}, l), {
                    path: o
                })
            }
            );
            let a = !0;
            const r = await Promise.all(o)
              , s = {}
              , i = {};
            for (const l of r)
                s[l.path] = {
                    valid: l.valid,
                    errors: l.errors
                },
                l.valid || (a = !1,
                i[l.path] = l.errors[0]);
            return {
                valid: a,
                results: s,
                errors: i,
                source: "schema"
            }
        }(e, u, {
            names: y.value,
            bailsMap: b.value
        });
        return s.value = !1,
        t
    }
    const X = N( (e, {evt: t}) => {
        (function(e) {
            return py(e) && e.target && "submit"in e.target
        }
        )(t) && t.target.submit()
    }
    );
    function J(e, t) {
        const n = Gg(t) || null == t ? void 0 : t.label
          , o = I(Dt(e)) || A(e, {
            label: n
        })
          , a = () => Gg(t) ? t(Sy(o, Dy)) : t || {};
        function r() {
            var e;
            o.touched = !0;
            (null !== (e = a().validateOnBlur) && void 0 !== e ? e : By().validateOnBlur) && W(Dt(o.path))
        }
        function s() {
            var e;
            (null !== (e = a().validateOnInput) && void 0 !== e ? e : By().validateOnInput) && fn( () => {
                W(Dt(o.path))
            }
            )
        }
        function i() {
            var e;
            (null !== (e = a().validateOnChange) && void 0 !== e ? e : By().validateOnChange) && fn( () => {
                W(Dt(o.path))
            }
            )
        }
        const l = ms( () => {
            const e = {
                onChange: i,
                onInput: s,
                onBlur: r
            };
            return Gg(t) ? Object.assign(Object.assign({}, e), t(Sy(o, Dy)).props || {}) : (null == t ? void 0 : t.props) ? Object.assign(Object.assign({}, e), t.props(Sy(o, Dy))) : e
        }
        );
        return [$(e, () => {
            var e, t, n;
            return null === (n = null !== (e = a().validateOnModelUpdate) && void 0 !== e ? e : null === (t = By()) || void 0 === t ? void 0 : t.validateOnModelUpdate) || void 0 === n || n
        }
        ), l]
    }
    Mo( () => {
        (null == e ? void 0 : e.initialErrors) && v(e.initialErrors),
        (null == e ? void 0 : e.initialTouched) && H(e.initialTouched),
        (null == e ? void 0 : e.validateOnMount) ? q() : D.validateSchema && D.validateSchema("silent")
    }
    ),
    Bt(T) && Qa(T, () => {
        var e;
        null === (e = D.validateSchema) || void 0 === e || e.call(D, "validated-only")
    }
    ),
    _a(ay, D);
    const Q = Object.assign(Object.assign({}, D), {
        values: _t(u),
        handleReset: () => Z(),
        submitForm: X
    });
    return _a(ry, Q),
    Q
}
const $y = e => null !== e && !!e && "object" == typeof e && !Array.isArray(e);
function Vy(e) {
    return Number(e) >= 0
}
function Hy(e) {
    if (!function(e) {
        return "object" == typeof e && null !== e
    }(e) || "[object Object]" !== function(e) {
        return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e)
    }(e))
        return !1;
    if (null === Object.getPrototypeOf(e))
        return !0;
    let t = e;
    for (; null !== Object.getPrototypeOf(t); )
        t = Object.getPrototypeOf(t);
    return Object.getPrototypeOf(e) === t
}
function Uy(e, t) {
    return Object.keys(t).forEach(n => {
        if (Hy(t[n]) && Hy(e[n]))
            return e[n] || (e[n] = {}),
            void Uy(e[n], t[n]);
        e[n] = t[n]
    }
    ),
    e
}
function Zy(e, t) {
    return {
        __type: "VVTypedSchema",
        async parse(n) {
            const o = await e.safeParseAsync(n, t);
            if (o.success)
                return {
                    value: o.data,
                    errors: []
                };
            const a = {};
            return qy(o.error.issues, a),
            {
                errors: Object.values(a)
            }
        },
        cast(t) {
            try {
                return e.parse(t)
            } catch (n) {
                const o = Wy(e);
                return $y(o) && $y(t) ? Uy(o, t) : t
            }
        },
        describe(t) {
            try {
                if (!t)
                    return {
                        required: !e.isOptional(),
                        exists: !0
                    };
                const n = function(e, t) {
                    if (!Yy(t))
                        return null;
                    if (cy(e))
                        return t.shape[my(e)];
                    const n = (e || "").split(/\.|\[(\d+)\]/).filter(Boolean);
                    let o = t;
                    for (let a = 0; a <= n.length; a++) {
                        const e = n[a];
                        if (!e || !o)
                            return o;
                        Yy(o) ? o = o.shape[e] || null : Vy(e) && Ky(o) && (o = o._def.type)
                    }
                    return null
                }(t, e);
                return n ? {
                    required: !n.isOptional(),
                    exists: !0
                } : {
                    required: !1,
                    exists: !1
                }
            } catch (n) {
                return {
                    required: !1,
                    exists: !1
                }
            }
        }
    }
}
function qy(e, t) {
    e.forEach(e => {
        const n = function(e) {
            const t = e.split(".");
            if (!t.length)
                return "";
            let n = String(t[0]);
            for (let o = 1; o < t.length; o++)
                Vy(t[o]) ? n += `[${t[o]}]` : n += `.${t[o]}`;
            return n
        }(e.path.join("."));
        ("invalid_union" !== e.code || (qy(e.unionErrors.flatMap(e => e.issues), t),
        n)) && (t[n] || (t[n] = {
            errors: [],
            path: n
        }),
        t[n].errors.push(e.message))
    }
    )
}
function Wy(e) {
    if (e instanceof _g)
        return Object.fromEntries(Object.entries(e.shape).map( ([e,t]) => t instanceof Ng ? [e, t._def.defaultValue()] : t instanceof _g ? [e, Wy(t)] : [e, void 0]))
}
function Gy(e) {
    return e._def.typeName
}
function Ky(e) {
    return Gy(e) === Hg.ZodArray
}
function Yy(e) {
    return Gy(e) === Hg.ZodObject
}
function Xy(e, t) {
    return function() {
        return e.apply(t, arguments)
    }
}
const {toString: Jy} = Object.prototype
  , {getPrototypeOf: Qy} = Object
  , {iterator: eb, toStringTag: tb} = Symbol
  , nb = (e => t => {
    const n = Jy.call(t);
    return e[n] || (e[n] = n.slice(8, -1).toLowerCase())
}
)(Object.create(null))
  , ob = e => (e = e.toLowerCase(),
t => nb(t) === e)
  , ab = e => t => typeof t === e
  , {isArray: rb} = Array
  , sb = ab("undefined");
const ib = ob("ArrayBuffer");
const lb = ab("string")
  , ub = ab("function")
  , cb = ab("number")
  , db = e => null !== e && "object" == typeof e
  , pb = e => {
    if ("object" !== nb(e))
        return !1;
    const t = Qy(e);
    return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || tb in e || eb in e)
}
  , fb = ob("Date")
  , hb = ob("File")
  , vb = ob("Blob")
  , mb = ob("FileList")
  , gb = ob("URLSearchParams")
  , [yb,bb,wb,_b] = ["ReadableStream", "Request", "Response", "Headers"].map(ob);
function xb(e, t, {allOwnKeys: n=!1}={}) {
    if (null == e)
        return;
    let o, a;
    if ("object" != typeof e && (e = [e]),
    rb(e))
        for (o = 0,
        a = e.length; o < a; o++)
            t.call(null, e[o], o, e);
    else {
        const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e)
          , r = a.length;
        let s;
        for (o = 0; o < r; o++)
            s = a[o],
            t.call(null, e[s], s, e)
    }
}
function kb(e, t) {
    t = t.toLowerCase();
    const n = Object.keys(e);
    let o, a = n.length;
    for (; a-- > 0; )
        if (o = n[a],
        t === o.toLowerCase())
            return o;
    return null
}
const Sb = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global
  , Cb = e => !sb(e) && e !== Sb;
const Eb = (e => t => e && t instanceof e)("undefined" != typeof Uint8Array && Qy(Uint8Array))
  , Tb = ob("HTMLFormElement")
  , Ab = ( ({hasOwnProperty: e}) => (t, n) => e.call(t, n))(Object.prototype)
  , Ob = ob("RegExp")
  , Mb = (e, t) => {
    const n = Object.getOwnPropertyDescriptors(e)
      , o = {};
    xb(n, (n, a) => {
        let r;
        !1 !== (r = t(n, a, e)) && (o[a] = r || n)
    }
    ),
    Object.defineProperties(e, o)
}
;
const Pb = ob("AsyncFunction")
  , Bb = (Ib = "function" == typeof setImmediate,
Lb = ub(Sb.postMessage),
Ib ? setImmediate : Lb ? (Rb = `axios@${Math.random()}`,
zb = [],
Sb.addEventListener("message", ({source: e, data: t}) => {
    e === Sb && t === Rb && zb.length && zb.shift()()
}
, !1),
e => {
    zb.push(e),
    Sb.postMessage(Rb, "*")
}
) : e => setTimeout(e));
var Ib, Lb, Rb, zb;
const Nb = "undefined" != typeof queueMicrotask ? queueMicrotask.bind(Sb) : "undefined" != typeof process && process.nextTick || Bb
  , Db = {
    isArray: rb,
    isArrayBuffer: ib,
    isBuffer: function(e) {
        return null !== e && !sb(e) && null !== e.constructor && !sb(e.constructor) && ub(e.constructor.isBuffer) && e.constructor.isBuffer(e)
    },
    isFormData: e => {
        let t;
        return e && ("function" == typeof FormData && e instanceof FormData || ub(e.append) && ("formdata" === (t = nb(e)) || "object" === t && ub(e.toString) && "[object FormData]" === e.toString()))
    }
    ,
    isArrayBufferView: function(e) {
        let t;
        return t = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && ib(e.buffer),
        t
    },
    isString: lb,
    isNumber: cb,
    isBoolean: e => !0 === e || !1 === e,
    isObject: db,
    isPlainObject: pb,
    isReadableStream: yb,
    isRequest: bb,
    isResponse: wb,
    isHeaders: _b,
    isUndefined: sb,
    isDate: fb,
    isFile: hb,
    isBlob: vb,
    isRegExp: Ob,
    isFunction: ub,
    isStream: e => db(e) && ub(e.pipe),
    isURLSearchParams: gb,
    isTypedArray: Eb,
    isFileList: mb,
    forEach: xb,
    merge: function e() {
        const {caseless: t} = Cb(this) && this || {}
          , n = {}
          , o = (o, a) => {
            const r = t && kb(n, a) || a;
            pb(n[r]) && pb(o) ? n[r] = e(n[r], o) : pb(o) ? n[r] = e({}, o) : rb(o) ? n[r] = o.slice() : n[r] = o
        }
        ;
        for (let a = 0, r = arguments.length; a < r; a++)
            arguments[a] && xb(arguments[a], o);
        return n
    },
    extend: (e, t, n, {allOwnKeys: o}={}) => (xb(t, (t, o) => {
        n && ub(t) ? e[o] = Xy(t, n) : e[o] = t
    }
    , {
        allOwnKeys: o
    }),
    e),
    trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
    stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)),
    e),
    inherits: (e, t, n, o) => {
        e.prototype = Object.create(t.prototype, o),
        e.prototype.constructor = e,
        Object.defineProperty(e, "super", {
            value: t.prototype
        }),
        n && Object.assign(e.prototype, n)
    }
    ,
    toFlatObject: (e, t, n, o) => {
        let a, r, s;
        const i = {};
        if (t = t || {},
        null == e)
            return t;
        do {
            for (a = Object.getOwnPropertyNames(e),
            r = a.length; r-- > 0; )
                s = a[r],
                o && !o(s, e, t) || i[s] || (t[s] = e[s],
                i[s] = !0);
            e = !1 !== n && Qy(e)
        } while (e && (!n || n(e, t)) && e !== Object.prototype);
        return t
    }
    ,
    kindOf: nb,
    kindOfTest: ob,
    endsWith: (e, t, n) => {
        e = String(e),
        (void 0 === n || n > e.length) && (n = e.length),
        n -= t.length;
        const o = e.indexOf(t, n);
        return -1 !== o && o === n
    }
    ,
    toArray: e => {
        if (!e)
            return null;
        if (rb(e))
            return e;
        let t = e.length;
        if (!cb(t))
            return null;
        const n = new Array(t);
        for (; t-- > 0; )
            n[t] = e[t];
        return n
    }
    ,
    forEachEntry: (e, t) => {
        const n = (e && e[eb]).call(e);
        let o;
        for (; (o = n.next()) && !o.done; ) {
            const n = o.value;
            t.call(e, n[0], n[1])
        }
    }
    ,
    matchAll: (e, t) => {
        let n;
        const o = [];
        for (; null !== (n = e.exec(t)); )
            o.push(n);
        return o
    }
    ,
    isHTMLForm: Tb,
    hasOwnProperty: Ab,
    hasOwnProp: Ab,
    reduceDescriptors: Mb,
    freezeMethods: e => {
        Mb(e, (t, n) => {
            if (ub(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n))
                return !1;
            const o = e[n];
            ub(o) && (t.enumerable = !1,
            "writable"in t ? t.writable = !1 : t.set || (t.set = () => {
                throw Error("Can not rewrite read-only method '" + n + "'")
            }
            ))
        }
        )
    }
    ,
    toObjectSet: (e, t) => {
        const n = {}
          , o = e => {
            e.forEach(e => {
                n[e] = !0
            }
            )
        }
        ;
        return rb(e) ? o(e) : o(String(e).split(t)),
        n
    }
    ,
    toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(e, t, n) {
        return t.toUpperCase() + n
    }),
    noop: () => {}
    ,
    toFiniteNumber: (e, t) => null != e && Number.isFinite(e = +e) ? e : t,
    findKey: kb,
    global: Sb,
    isContextDefined: Cb,
    isSpecCompliantForm: function(e) {
        return !!(e && ub(e.append) && "FormData" === e[tb] && e[eb])
    },
    toJSONObject: e => {
        const t = new Array(10)
          , n = (e, o) => {
            if (db(e)) {
                if (t.indexOf(e) >= 0)
                    return;
                if (!("toJSON"in e)) {
                    t[o] = e;
                    const a = rb(e) ? [] : {};
                    return xb(e, (e, t) => {
                        const r = n(e, o + 1);
                        !sb(r) && (a[t] = r)
                    }
                    ),
                    t[o] = void 0,
                    a
                }
            }
            return e
        }
        ;
        return n(e, 0)
    }
    ,
    isAsyncFn: Pb,
    isThenable: e => e && (db(e) || ub(e)) && ub(e.then) && ub(e.catch),
    setImmediate: Bb,
    asap: Nb,
    isIterable: e => null != e && ub(e[eb])
};
function jb(e, t, n, o, a) {
    Error.call(this),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack,
    this.message = e,
    this.name = "AxiosError",
    t && (this.code = t),
    n && (this.config = n),
    o && (this.request = o),
    a && (this.response = a,
    this.status = a.status ? a.status : null)
}
Db.inherits(jb, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: Db.toJSONObject(this.config),
            code: this.code,
            status: this.status
        }
    }
});
const Fb = jb.prototype
  , $b = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => {
    $b[e] = {
        value: e
    }
}
),
Object.defineProperties(jb, $b),
Object.defineProperty(Fb, "isAxiosError", {
    value: !0
}),
jb.from = (e, t, n, o, a, r) => {
    const s = Object.create(Fb);
    return Db.toFlatObject(e, s, function(e) {
        return e !== Error.prototype
    }, e => "isAxiosError" !== e),
    jb.call(s, e.message, t, n, o, a),
    s.cause = e,
    s.name = e.name,
    r && Object.assign(s, r),
    s
}
;
function Vb(e) {
    return Db.isPlainObject(e) || Db.isArray(e)
}
function Hb(e) {
    return Db.endsWith(e, "[]") ? e.slice(0, -2) : e
}
function Ub(e, t, n) {
    return e ? e.concat(t).map(function(e, t) {
        return e = Hb(e),
        !n && t ? "[" + e + "]" : e
    }).join(n ? "." : "") : t
}
const Zb = Db.toFlatObject(Db, {}, null, function(e) {
    return /^is[A-Z]/.test(e)
});
function qb(e, t, n) {
    if (!Db.isObject(e))
        throw new TypeError("target must be an object");
    t = t || new FormData;
    const o = (n = Db.toFlatObject(n, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(e, t) {
        return !Db.isUndefined(t[e])
    })).metaTokens
      , a = n.visitor || u
      , r = n.dots
      , s = n.indexes
      , i = (n.Blob || "undefined" != typeof Blob && Blob) && Db.isSpecCompliantForm(t);
    if (!Db.isFunction(a))
        throw new TypeError("visitor must be a function");
    function l(e) {
        if (null === e)
            return "";
        if (Db.isDate(e))
            return e.toISOString();
        if (Db.isBoolean(e))
            return e.toString();
        if (!i && Db.isBlob(e))
            throw new jb("Blob is not supported. Use a Buffer instead.");
        return Db.isArrayBuffer(e) || Db.isTypedArray(e) ? i && "function" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e
    }
    function u(e, n, a) {
        let i = e;
        if (e && !a && "object" == typeof e)
            if (Db.endsWith(n, "{}"))
                n = o ? n : n.slice(0, -2),
                e = JSON.stringify(e);
            else if (Db.isArray(e) && function(e) {
                return Db.isArray(e) && !e.some(Vb)
            }(e) || (Db.isFileList(e) || Db.endsWith(n, "[]")) && (i = Db.toArray(e)))
                return n = Hb(n),
                i.forEach(function(e, o) {
                    !Db.isUndefined(e) && null !== e && t.append(!0 === s ? Ub([n], o, r) : null === s ? n : n + "[]", l(e))
                }),
                !1;
        return !!Vb(e) || (t.append(Ub(a, n, r), l(e)),
        !1)
    }
    const c = []
      , d = Object.assign(Zb, {
        defaultVisitor: u,
        convertValue: l,
        isVisitable: Vb
    });
    if (!Db.isObject(e))
        throw new TypeError("data must be an object");
    return function e(n, o) {
        if (!Db.isUndefined(n)) {
            if (-1 !== c.indexOf(n))
                throw Error("Circular reference detected in " + o.join("."));
            c.push(n),
            Db.forEach(n, function(n, r) {
                !0 === (!(Db.isUndefined(n) || null === n) && a.call(t, n, Db.isString(r) ? r.trim() : r, o, d)) && e(n, o ? o.concat(r) : [r])
            }),
            c.pop()
        }
    }(e),
    t
}
function Wb(e) {
    const t = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(e) {
        return t[e]
    })
}
function Gb(e, t) {
    this._pairs = [],
    e && qb(e, this, t)
}
const Kb = Gb.prototype;
function Yb(e) {
    return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
function Xb(e, t, n) {
    if (!t)
        return e;
    const o = n && n.encode || Yb;
    Db.isFunction(n) && (n = {
        serialize: n
    });
    const a = n && n.serialize;
    let r;
    if (r = a ? a(t, n) : Db.isURLSearchParams(t) ? t.toString() : new Gb(t,n).toString(o),
    r) {
        const t = e.indexOf("#");
        -1 !== t && (e = e.slice(0, t)),
        e += (-1 === e.indexOf("?") ? "?" : "&") + r
    }
    return e
}
Kb.append = function(e, t) {
    this._pairs.push([e, t])
}
,
Kb.toString = function(e) {
    const t = e ? function(t) {
        return e.call(this, t, Wb)
    }
    : Wb;
    return this._pairs.map(function(e) {
        return t(e[0]) + "=" + t(e[1])
    }, "").join("&")
}
;
class Jb {
    constructor() {
        this.handlers = []
    }
    use(e, t, n) {
        return this.handlers.push({
            fulfilled: e,
            rejected: t,
            synchronous: !!n && n.synchronous,
            runWhen: n ? n.runWhen : null
        }),
        this.handlers.length - 1
    }
    eject(e) {
        this.handlers[e] && (this.handlers[e] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(e) {
        Db.forEach(this.handlers, function(t) {
            null !== t && e(t)
        })
    }
}
const Qb = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}
  , ew = {
    isBrowser: !0,
    classes: {
        URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : Gb,
        FormData: "undefined" != typeof FormData ? FormData : null,
        Blob: "undefined" != typeof Blob ? Blob : null
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
}
  , tw = "undefined" != typeof window && "undefined" != typeof document
  , nw = "object" == typeof navigator && navigator || void 0
  , ow = tw && (!nw || ["ReactNative", "NativeScript", "NS"].indexOf(nw.product) < 0)
  , aw = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts
  , rw = tw && window.location.href || "http://localhost"
  , sw = {
    ...Object.freeze(Object.defineProperty({
        __proto__: null,
        hasBrowserEnv: tw,
        hasStandardBrowserEnv: ow,
        hasStandardBrowserWebWorkerEnv: aw,
        navigator: nw,
        origin: rw
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    ...ew
};
function iw(e) {
    function t(e, n, o, a) {
        let r = e[a++];
        if ("__proto__" === r)
            return !0;
        const s = Number.isFinite(+r)
          , i = a >= e.length;
        if (r = !r && Db.isArray(o) ? o.length : r,
        i)
            return Db.hasOwnProp(o, r) ? o[r] = [o[r], n] : o[r] = n,
            !s;
        o[r] && Db.isObject(o[r]) || (o[r] = []);
        return t(e, n, o[r], a) && Db.isArray(o[r]) && (o[r] = function(e) {
            const t = {}
              , n = Object.keys(e);
            let o;
            const a = n.length;
            let r;
            for (o = 0; o < a; o++)
                r = n[o],
                t[r] = e[r];
            return t
        }(o[r])),
        !s
    }
    if (Db.isFormData(e) && Db.isFunction(e.entries)) {
        const n = {};
        return Db.forEachEntry(e, (e, o) => {
            t(function(e) {
                return Db.matchAll(/\w+|\[(\w*)]/g, e).map(e => "[]" === e[0] ? "" : e[1] || e[0])
            }(e), o, n, 0)
        }
        ),
        n
    }
    return null
}
const lw = {
    transitional: Qb,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(e, t) {
        const n = t.getContentType() || ""
          , o = n.indexOf("application/json") > -1
          , a = Db.isObject(e);
        a && Db.isHTMLForm(e) && (e = new FormData(e));
        if (Db.isFormData(e))
            return o ? JSON.stringify(iw(e)) : e;
        if (Db.isArrayBuffer(e) || Db.isBuffer(e) || Db.isStream(e) || Db.isFile(e) || Db.isBlob(e) || Db.isReadableStream(e))
            return e;
        if (Db.isArrayBufferView(e))
            return e.buffer;
        if (Db.isURLSearchParams(e))
            return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
            e.toString();
        let r;
        if (a) {
            if (n.indexOf("application/x-www-form-urlencoded") > -1)
                return function(e, t) {
                    return qb(e, new sw.classes.URLSearchParams, Object.assign({
                        visitor: function(e, t, n, o) {
                            return sw.isNode && Db.isBuffer(e) ? (this.append(t, e.toString("base64")),
                            !1) : o.defaultVisitor.apply(this, arguments)
                        }
                    }, t))
                }(e, this.formSerializer).toString();
            if ((r = Db.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
                const t = this.env && this.env.FormData;
                return qb(r ? {
                    "files[]": e
                } : e, t && new t, this.formSerializer)
            }
        }
        return a || o ? (t.setContentType("application/json", !1),
        function(e, t, n) {
            if (Db.isString(e))
                try {
                    return (t || JSON.parse)(e),
                    Db.trim(e)
                } catch (pC) {
                    if ("SyntaxError" !== pC.name)
                        throw pC
                }
            return (n || JSON.stringify)(e)
        }(e)) : e
    }
    ],
    transformResponse: [function(e) {
        const t = this.transitional || lw.transitional
          , n = t && t.forcedJSONParsing
          , o = "json" === this.responseType;
        if (Db.isResponse(e) || Db.isReadableStream(e))
            return e;
        if (e && Db.isString(e) && (n && !this.responseType || o)) {
            const n = !(t && t.silentJSONParsing) && o;
            try {
                return JSON.parse(e)
            } catch (pC) {
                if (n) {
                    if ("SyntaxError" === pC.name)
                        throw jb.from(pC, jb.ERR_BAD_RESPONSE, this, null, this.response);
                    throw pC
                }
            }
        }
        return e
    }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: sw.classes.FormData,
        Blob: sw.classes.Blob
    },
    validateStatus: function(e) {
        return e >= 200 && e < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
Db.forEach(["delete", "get", "head", "post", "put", "patch"], e => {
    lw.headers[e] = {}
}
);
const uw = Db.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
  , cw = Symbol("internals");
function dw(e) {
    return e && String(e).trim().toLowerCase()
}
function pw(e) {
    return !1 === e || null == e ? e : Db.isArray(e) ? e.map(pw) : String(e)
}
function fw(e, t, n, o, a) {
    return Db.isFunction(o) ? o.call(this, t, n) : (a && (t = n),
    Db.isString(t) ? Db.isString(o) ? -1 !== t.indexOf(o) : Db.isRegExp(o) ? o.test(t) : void 0 : void 0)
}
let hw = class {
    constructor(e) {
        e && this.set(e)
    }
    set(e, t, n) {
        const o = this;
        function a(e, t, n) {
            const a = dw(t);
            if (!a)
                throw new Error("header name must be a non-empty string");
            const r = Db.findKey(o, a);
            (!r || void 0 === o[r] || !0 === n || void 0 === n && !1 !== o[r]) && (o[r || t] = pw(e))
        }
        const r = (e, t) => Db.forEach(e, (e, n) => a(e, n, t));
        if (Db.isPlainObject(e) || e instanceof this.constructor)
            r(e, t);
        else if (Db.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()))
            r((e => {
                const t = {};
                let n, o, a;
                return e && e.split("\n").forEach(function(e) {
                    a = e.indexOf(":"),
                    n = e.substring(0, a).trim().toLowerCase(),
                    o = e.substring(a + 1).trim(),
                    !n || t[n] && uw[n] || ("set-cookie" === n ? t[n] ? t[n].push(o) : t[n] = [o] : t[n] = t[n] ? t[n] + ", " + o : o)
                }),
                t
            }
            )(e), t);
        else if (Db.isObject(e) && Db.isIterable(e)) {
            let n, o, a = {};
            for (const t of e) {
                if (!Db.isArray(t))
                    throw TypeError("Object iterator must return a key-value pair");
                a[o = t[0]] = (n = a[o]) ? Db.isArray(n) ? [...n, t[1]] : [n, t[1]] : t[1]
            }
            r(a, t)
        } else
            null != e && a(t, e, n);
        return this
    }
    get(e, t) {
        if (e = dw(e)) {
            const n = Db.findKey(this, e);
            if (n) {
                const e = this[n];
                if (!t)
                    return e;
                if (!0 === t)
                    return function(e) {
                        const t = Object.create(null)
                          , n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                        let o;
                        for (; o = n.exec(e); )
                            t[o[1]] = o[2];
                        return t
                    }(e);
                if (Db.isFunction(t))
                    return t.call(this, e, n);
                if (Db.isRegExp(t))
                    return t.exec(e);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(e, t) {
        if (e = dw(e)) {
            const n = Db.findKey(this, e);
            return !(!n || void 0 === this[n] || t && !fw(0, this[n], n, t))
        }
        return !1
    }
    delete(e, t) {
        const n = this;
        let o = !1;
        function a(e) {
            if (e = dw(e)) {
                const a = Db.findKey(n, e);
                !a || t && !fw(0, n[a], a, t) || (delete n[a],
                o = !0)
            }
        }
        return Db.isArray(e) ? e.forEach(a) : a(e),
        o
    }
    clear(e) {
        const t = Object.keys(this);
        let n = t.length
          , o = !1;
        for (; n--; ) {
            const a = t[n];
            e && !fw(0, this[a], a, e, !0) || (delete this[a],
            o = !0)
        }
        return o
    }
    normalize(e) {
        const t = this
          , n = {};
        return Db.forEach(this, (o, a) => {
            const r = Db.findKey(n, a);
            if (r)
                return t[r] = pw(o),
                void delete t[a];
            const s = e ? function(e) {
                return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, n) => t.toUpperCase() + n)
            }(a) : String(a).trim();
            s !== a && delete t[a],
            t[s] = pw(o),
            n[s] = !0
        }
        ),
        this
    }
    concat(...e) {
        return this.constructor.concat(this, ...e)
    }
    toJSON(e) {
        const t = Object.create(null);
        return Db.forEach(this, (n, o) => {
            null != n && !1 !== n && (t[o] = e && Db.isArray(n) ? n.join(", ") : n)
        }
        ),
        t
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map( ([e,t]) => e + ": " + t).join("\n")
    }
    getSetCookie() {
        return this.get("set-cookie") || []
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(e) {
        return e instanceof this ? e : new this(e)
    }
    static concat(e, ...t) {
        const n = new this(e);
        return t.forEach(e => n.set(e)),
        n
    }
    static accessor(e) {
        const t = (this[cw] = this[cw] = {
            accessors: {}
        }).accessors
          , n = this.prototype;
        function o(e) {
            const o = dw(e);
            t[o] || (!function(e, t) {
                const n = Db.toCamelCase(" " + t);
                ["get", "set", "has"].forEach(o => {
                    Object.defineProperty(e, o + n, {
                        value: function(e, n, a) {
                            return this[o].call(this, t, e, n, a)
                        },
                        configurable: !0
                    })
                }
                )
            }(n, e),
            t[o] = !0)
        }
        return Db.isArray(e) ? e.forEach(o) : o(e),
        this
    }
}
;
function vw(e, t) {
    const n = this || lw
      , o = t || n
      , a = hw.from(o.headers);
    let r = o.data;
    return Db.forEach(e, function(e) {
        r = e.call(n, r, a.normalize(), t ? t.status : void 0)
    }),
    a.normalize(),
    r
}
function mw(e) {
    return !(!e || !e.__CANCEL__)
}
function gw(e, t, n) {
    jb.call(this, null == e ? "canceled" : e, jb.ERR_CANCELED, t, n),
    this.name = "CanceledError"
}
function yw(e, t, n) {
    const o = n.config.validateStatus;
    n.status && o && !o(n.status) ? t(new jb("Request failed with status code " + n.status,[jb.ERR_BAD_REQUEST, jb.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],n.config,n.request,n)) : e(n)
}
hw.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
Db.reduceDescriptors(hw.prototype, ({value: e}, t) => {
    let n = t[0].toUpperCase() + t.slice(1);
    return {
        get: () => e,
        set(e) {
            this[n] = e
        }
    }
}
),
Db.freezeMethods(hw),
Db.inherits(gw, jb, {
    __CANCEL__: !0
});
const bw = (e, t, n=3) => {
    let o = 0;
    const a = function(e, t) {
        e = e || 10;
        const n = new Array(e)
          , o = new Array(e);
        let a, r = 0, s = 0;
        return t = void 0 !== t ? t : 1e3,
        function(i) {
            const l = Date.now()
              , u = o[s];
            a || (a = l),
            n[r] = i,
            o[r] = l;
            let c = s
              , d = 0;
            for (; c !== r; )
                d += n[c++],
                c %= e;
            if (r = (r + 1) % e,
            r === s && (s = (s + 1) % e),
            l - a < t)
                return;
            const p = u && l - u;
            return p ? Math.round(1e3 * d / p) : void 0
        }
    }(50, 250);
    return function(e, t) {
        let n, o, a = 0, r = 1e3 / t;
        const s = (t, r=Date.now()) => {
            a = r,
            n = null,
            o && (clearTimeout(o),
            o = null),
            e.apply(null, t)
        }
        ;
        return [ (...e) => {
            const t = Date.now()
              , i = t - a;
            i >= r ? s(e, t) : (n = e,
            o || (o = setTimeout( () => {
                o = null,
                s(n)
            }
            , r - i)))
        }
        , () => n && s(n)]
    }(n => {
        const r = n.loaded
          , s = n.lengthComputable ? n.total : void 0
          , i = r - o
          , l = a(i);
        o = r;
        e({
            loaded: r,
            total: s,
            progress: s ? r / s : void 0,
            bytes: i,
            rate: l || void 0,
            estimated: l && s && r <= s ? (s - r) / l : void 0,
            event: n,
            lengthComputable: null != s,
            [t ? "download" : "upload"]: !0
        })
    }
    , n)
}
  , ww = (e, t) => {
    const n = null != e;
    return [o => t[0]({
        lengthComputable: n,
        total: e,
        loaded: o
    }), t[1]]
}
  , _w = e => (...t) => Db.asap( () => e(...t))
  , xw = sw.hasStandardBrowserEnv ? ( (e, t) => n => (n = new URL(n,sw.origin),
e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(new URL(sw.origin), sw.navigator && /(msie|trident)/i.test(sw.navigator.userAgent)) : () => !0
  , kw = sw.hasStandardBrowserEnv ? {
    write(e, t, n, o, a, r) {
        const s = [e + "=" + encodeURIComponent(t)];
        Db.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()),
        Db.isString(o) && s.push("path=" + o),
        Db.isString(a) && s.push("domain=" + a),
        !0 === r && s.push("secure"),
        document.cookie = s.join("; ")
    },
    read(e) {
        const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
        return t ? decodeURIComponent(t[3]) : null
    },
    remove(e) {
        this.write(e, "", Date.now() - 864e5)
    }
} : {
    write() {},
    read: () => null,
    remove() {}
};
function Sw(e, t, n) {
    let o = !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
    return e && (o || 0 == n) ? function(e, t) {
        return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e
    }(e, t) : t
}
const Cw = e => e instanceof hw ? {
    ...e
} : e;
function Ew(e, t) {
    t = t || {};
    const n = {};
    function o(e, t, n, o) {
        return Db.isPlainObject(e) && Db.isPlainObject(t) ? Db.merge.call({
            caseless: o
        }, e, t) : Db.isPlainObject(t) ? Db.merge({}, t) : Db.isArray(t) ? t.slice() : t
    }
    function a(e, t, n, a) {
        return Db.isUndefined(t) ? Db.isUndefined(e) ? void 0 : o(void 0, e, 0, a) : o(e, t, 0, a)
    }
    function r(e, t) {
        if (!Db.isUndefined(t))
            return o(void 0, t)
    }
    function s(e, t) {
        return Db.isUndefined(t) ? Db.isUndefined(e) ? void 0 : o(void 0, e) : o(void 0, t)
    }
    function i(n, a, r) {
        return r in t ? o(n, a) : r in e ? o(void 0, n) : void 0
    }
    const l = {
        url: r,
        method: r,
        data: r,
        baseURL: s,
        transformRequest: s,
        transformResponse: s,
        paramsSerializer: s,
        timeout: s,
        timeoutMessage: s,
        withCredentials: s,
        withXSRFToken: s,
        adapter: s,
        responseType: s,
        xsrfCookieName: s,
        xsrfHeaderName: s,
        onUploadProgress: s,
        onDownloadProgress: s,
        decompress: s,
        maxContentLength: s,
        maxBodyLength: s,
        beforeRedirect: s,
        transport: s,
        httpAgent: s,
        httpsAgent: s,
        cancelToken: s,
        socketPath: s,
        responseEncoding: s,
        validateStatus: i,
        headers: (e, t, n) => a(Cw(e), Cw(t), 0, !0)
    };
    return Db.forEach(Object.keys(Object.assign({}, e, t)), function(o) {
        const r = l[o] || a
          , s = r(e[o], t[o], o);
        Db.isUndefined(s) && r !== i || (n[o] = s)
    }),
    n
}
const Tw = e => {
    const t = Ew({}, e);
    let n, {data: o, withXSRFToken: a, xsrfHeaderName: r, xsrfCookieName: s, headers: i, auth: l} = t;
    if (t.headers = i = hw.from(i),
    t.url = Xb(Sw(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer),
    l && i.set("Authorization", "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))),
    Db.isFormData(o))
        if (sw.hasStandardBrowserEnv || sw.hasStandardBrowserWebWorkerEnv)
            i.setContentType(void 0);
        else if (!1 !== (n = i.getContentType())) {
            const [e,...t] = n ? n.split(";").map(e => e.trim()).filter(Boolean) : [];
            i.setContentType([e || "multipart/form-data", ...t].join("; "))
        }
    if (sw.hasStandardBrowserEnv && (a && Db.isFunction(a) && (a = a(t)),
    a || !1 !== a && xw(t.url))) {
        const e = r && s && kw.read(s);
        e && i.set(r, e)
    }
    return t
}
  , Aw = "undefined" != typeof XMLHttpRequest && function(e) {
    return new Promise(function(t, n) {
        const o = Tw(e);
        let a = o.data;
        const r = hw.from(o.headers).normalize();
        let s, i, l, u, c, {responseType: d, onUploadProgress: p, onDownloadProgress: f} = o;
        function h() {
            u && u(),
            c && c(),
            o.cancelToken && o.cancelToken.unsubscribe(s),
            o.signal && o.signal.removeEventListener("abort", s)
        }
        let v = new XMLHttpRequest;
        function m() {
            if (!v)
                return;
            const o = hw.from("getAllResponseHeaders"in v && v.getAllResponseHeaders());
            yw(function(e) {
                t(e),
                h()
            }, function(e) {
                n(e),
                h()
            }, {
                data: d && "text" !== d && "json" !== d ? v.response : v.responseText,
                status: v.status,
                statusText: v.statusText,
                headers: o,
                config: e,
                request: v
            }),
            v = null
        }
        v.open(o.method.toUpperCase(), o.url, !0),
        v.timeout = o.timeout,
        "onloadend"in v ? v.onloadend = m : v.onreadystatechange = function() {
            v && 4 === v.readyState && (0 !== v.status || v.responseURL && 0 === v.responseURL.indexOf("file:")) && setTimeout(m)
        }
        ,
        v.onabort = function() {
            v && (n(new jb("Request aborted",jb.ECONNABORTED,e,v)),
            v = null)
        }
        ,
        v.onerror = function() {
            n(new jb("Network Error",jb.ERR_NETWORK,e,v)),
            v = null
        }
        ,
        v.ontimeout = function() {
            let t = o.timeout ? "timeout of " + o.timeout + "ms exceeded" : "timeout exceeded";
            const a = o.transitional || Qb;
            o.timeoutErrorMessage && (t = o.timeoutErrorMessage),
            n(new jb(t,a.clarifyTimeoutError ? jb.ETIMEDOUT : jb.ECONNABORTED,e,v)),
            v = null
        }
        ,
        void 0 === a && r.setContentType(null),
        "setRequestHeader"in v && Db.forEach(r.toJSON(), function(e, t) {
            v.setRequestHeader(t, e)
        }),
        Db.isUndefined(o.withCredentials) || (v.withCredentials = !!o.withCredentials),
        d && "json" !== d && (v.responseType = o.responseType),
        f && ([l,c] = bw(f, !0),
        v.addEventListener("progress", l)),
        p && v.upload && ([i,u] = bw(p),
        v.upload.addEventListener("progress", i),
        v.upload.addEventListener("loadend", u)),
        (o.cancelToken || o.signal) && (s = t => {
            v && (n(!t || t.type ? new gw(null,e,v) : t),
            v.abort(),
            v = null)
        }
        ,
        o.cancelToken && o.cancelToken.subscribe(s),
        o.signal && (o.signal.aborted ? s() : o.signal.addEventListener("abort", s)));
        const g = function(e) {
            const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
            return t && t[1] || ""
        }(o.url);
        g && -1 === sw.protocols.indexOf(g) ? n(new jb("Unsupported protocol " + g + ":",jb.ERR_BAD_REQUEST,e)) : v.send(a || null)
    }
    )
}
  , Ow = (e, t) => {
    const {length: n} = e = e ? e.filter(Boolean) : [];
    if (t || n) {
        let n, o = new AbortController;
        const a = function(e) {
            if (!n) {
                n = !0,
                s();
                const t = e instanceof Error ? e : this.reason;
                o.abort(t instanceof jb ? t : new gw(t instanceof Error ? t.message : t))
            }
        };
        let r = t && setTimeout( () => {
            r = null,
            a(new jb(`timeout ${t} of ms exceeded`,jb.ETIMEDOUT))
        }
        , t);
        const s = () => {
            e && (r && clearTimeout(r),
            r = null,
            e.forEach(e => {
                e.unsubscribe ? e.unsubscribe(a) : e.removeEventListener("abort", a)
            }
            ),
            e = null)
        }
        ;
        e.forEach(e => e.addEventListener("abort", a));
        const {signal: i} = o;
        return i.unsubscribe = () => Db.asap(s),
        i
    }
}
  , Mw = function*(e, t) {
    let n = e.byteLength;
    if (n < t)
        return void (yield e);
    let o, a = 0;
    for (; a < n; )
        o = a + t,
        yield e.slice(a, o),
        a = o
}
  , Pw = async function*(e) {
    if (e[Symbol.asyncIterator])
        return void (yield*e);
    const t = e.getReader();
    try {
        for (; ; ) {
            const {done: e, value: n} = await t.read();
            if (e)
                break;
            yield n
        }
    } finally {
        await t.cancel()
    }
}
  , Bw = (e, t, n, o) => {
    const a = async function*(e, t) {
        for await(const n of Pw(e))
            yield*Mw(n, t)
    }(e, t);
    let r, s = 0, i = e => {
        r || (r = !0,
        o && o(e))
    }
    ;
    return new ReadableStream({
        async pull(e) {
            try {
                const {done: t, value: o} = await a.next();
                if (t)
                    return i(),
                    void e.close();
                let r = o.byteLength;
                if (n) {
                    let e = s += r;
                    n(e)
                }
                e.enqueue(new Uint8Array(o))
            } catch (t) {
                throw i(t),
                t
            }
        },
        cancel: e => (i(e),
        a.return())
    },{
        highWaterMark: 2
    })
}
  , Iw = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response
  , Lw = Iw && "function" == typeof ReadableStream
  , Rw = Iw && ("function" == typeof TextEncoder ? (e => t => e.encode(t))(new TextEncoder) : async e => new Uint8Array(await new Response(e).arrayBuffer()))
  , zw = (e, ...t) => {
    try {
        return !!e(...t)
    } catch (pC) {
        return !1
    }
}
  , Nw = Lw && zw( () => {
    let e = !1;
    const t = new Request(sw.origin,{
        body: new ReadableStream,
        method: "POST",
        get duplex() {
            return e = !0,
            "half"
        }
    }).headers.has("Content-Type");
    return e && !t
}
)
  , Dw = Lw && zw( () => Db.isReadableStream(new Response("").body))
  , jw = {
    stream: Dw && (e => e.body)
};
var Fw;
Iw && (Fw = new Response,
["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => {
    !jw[e] && (jw[e] = Db.isFunction(Fw[e]) ? t => t[e]() : (t, n) => {
        throw new jb(`Response type '${e}' is not supported`,jb.ERR_NOT_SUPPORT,n)
    }
    )
}
));
const $w = async (e, t) => {
    const n = Db.toFiniteNumber(e.getContentLength());
    return null == n ? (async e => {
        if (null == e)
            return 0;
        if (Db.isBlob(e))
            return e.size;
        if (Db.isSpecCompliantForm(e)) {
            const t = new Request(sw.origin,{
                method: "POST",
                body: e
            });
            return (await t.arrayBuffer()).byteLength
        }
        return Db.isArrayBufferView(e) || Db.isArrayBuffer(e) ? e.byteLength : (Db.isURLSearchParams(e) && (e += ""),
        Db.isString(e) ? (await Rw(e)).byteLength : void 0)
    }
    )(t) : n
}
  , Vw = {
    http: null,
    xhr: Aw,
    fetch: Iw && (async e => {
        let {url: t, method: n, data: o, signal: a, cancelToken: r, timeout: s, onDownloadProgress: i, onUploadProgress: l, responseType: u, headers: c, withCredentials: d="same-origin", fetchOptions: p} = Tw(e);
        u = u ? (u + "").toLowerCase() : "text";
        let f, h = Ow([a, r && r.toAbortSignal()], s);
        const v = h && h.unsubscribe && ( () => {
            h.unsubscribe()
        }
        );
        let m;
        try {
            if (l && Nw && "get" !== n && "head" !== n && 0 !== (m = await $w(c, o))) {
                let e, n = new Request(t,{
                    method: "POST",
                    body: o,
                    duplex: "half"
                });
                if (Db.isFormData(o) && (e = n.headers.get("content-type")) && c.setContentType(e),
                n.body) {
                    const [e,t] = ww(m, bw(_w(l)));
                    o = Bw(n.body, 65536, e, t)
                }
            }
            Db.isString(d) || (d = d ? "include" : "omit");
            const a = "credentials"in Request.prototype;
            f = new Request(t,{
                ...p,
                signal: h,
                method: n.toUpperCase(),
                headers: c.normalize().toJSON(),
                body: o,
                duplex: "half",
                credentials: a ? d : void 0
            });
            let r = await fetch(f, p);
            const s = Dw && ("stream" === u || "response" === u);
            if (Dw && (i || s && v)) {
                const e = {};
                ["status", "statusText", "headers"].forEach(t => {
                    e[t] = r[t]
                }
                );
                const t = Db.toFiniteNumber(r.headers.get("content-length"))
                  , [n,o] = i && ww(t, bw(_w(i), !0)) || [];
                r = new Response(Bw(r.body, 65536, n, () => {
                    o && o(),
                    v && v()
                }
                ),e)
            }
            u = u || "text";
            let g = await jw[Db.findKey(jw, u) || "text"](r, e);
            return !s && v && v(),
            await new Promise( (t, n) => {
                yw(t, n, {
                    data: g,
                    headers: hw.from(r.headers),
                    status: r.status,
                    statusText: r.statusText,
                    config: e,
                    request: f
                })
            }
            )
        } catch (g) {
            if (v && v(),
            g && "TypeError" === g.name && /Load failed|fetch/i.test(g.message))
                throw Object.assign(new jb("Network Error",jb.ERR_NETWORK,e,f), {
                    cause: g.cause || g
                });
            throw jb.from(g, g && g.code, e, f)
        }
    }
    )
};
Db.forEach(Vw, (e, t) => {
    if (e) {
        try {
            Object.defineProperty(e, "name", {
                value: t
            })
        } catch (pC) {}
        Object.defineProperty(e, "adapterName", {
            value: t
        })
    }
}
);
const Hw = e => `- ${e}`
  , Uw = e => Db.isFunction(e) || null === e || !1 === e
  , Zw = e => {
    e = Db.isArray(e) ? e : [e];
    const {length: t} = e;
    let n, o;
    const a = {};
    for (let r = 0; r < t; r++) {
        let t;
        if (n = e[r],
        o = n,
        !Uw(n) && (o = Vw[(t = String(n)).toLowerCase()],
        void 0 === o))
            throw new jb(`Unknown adapter '${t}'`);
        if (o)
            break;
        a[t || "#" + r] = o
    }
    if (!o) {
        const e = Object.entries(a).map( ([e,t]) => `adapter ${e} ` + (!1 === t ? "is not supported by the environment" : "is not available in the build"));
        throw new jb("There is no suitable adapter to dispatch the request " + (t ? e.length > 1 ? "since :\n" + e.map(Hw).join("\n") : " " + Hw(e[0]) : "as no adapter specified"),"ERR_NOT_SUPPORT")
    }
    return o
}
;
function qw(e) {
    if (e.cancelToken && e.cancelToken.throwIfRequested(),
    e.signal && e.signal.aborted)
        throw new gw(null,e)
}
function Ww(e) {
    qw(e),
    e.headers = hw.from(e.headers),
    e.data = vw.call(e, e.transformRequest),
    -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1);
    return Zw(e.adapter || lw.adapter)(e).then(function(t) {
        return qw(e),
        t.data = vw.call(e, e.transformResponse, t),
        t.headers = hw.from(t.headers),
        t
    }, function(t) {
        return mw(t) || (qw(e),
        t && t.response && (t.response.data = vw.call(e, e.transformResponse, t.response),
        t.response.headers = hw.from(t.response.headers))),
        Promise.reject(t)
    })
}
const Gw = "1.10.0"
  , Kw = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach( (e, t) => {
    Kw[e] = function(n) {
        return typeof n === e || "a" + (t < 1 ? "n " : " ") + e
    }
}
);
const Yw = {};
Kw.transitional = function(e, t, n) {
    return (o, a, r) => {
        if (!1 === e)
            throw new jb(function(e, t) {
                return "[Axios v" + Gw + "] Transitional option '" + e + "'" + t + (n ? ". " + n : "")
            }(a, " has been removed" + (t ? " in " + t : "")),jb.ERR_DEPRECATED);
        return t && !Yw[a] && (Yw[a] = !0),
        !e || e(o, a, r)
    }
}
,
Kw.spelling = function(e) {
    return (e, t) => !0
}
;
const Xw = {
    assertOptions: function(e, t, n) {
        if ("object" != typeof e)
            throw new jb("options must be an object",jb.ERR_BAD_OPTION_VALUE);
        const o = Object.keys(e);
        let a = o.length;
        for (; a-- > 0; ) {
            const r = o[a]
              , s = t[r];
            if (s) {
                const t = e[r]
                  , n = void 0 === t || s(t, r, e);
                if (!0 !== n)
                    throw new jb("option " + r + " must be " + n,jb.ERR_BAD_OPTION_VALUE);
                continue
            }
            if (!0 !== n)
                throw new jb("Unknown option " + r,jb.ERR_BAD_OPTION)
        }
    },
    validators: Kw
}
  , Jw = Xw.validators;
let Qw = class {
    constructor(e) {
        this.defaults = e || {},
        this.interceptors = {
            request: new Jb,
            response: new Jb
        }
    }
    async request(e, t) {
        try {
            return await this._request(e, t)
        } catch (n) {
            if (n instanceof Error) {
                let e = {};
                Error.captureStackTrace ? Error.captureStackTrace(e) : e = new Error;
                const t = e.stack ? e.stack.replace(/^.+\n/, "") : "";
                try {
                    n.stack ? t && !String(n.stack).endsWith(t.replace(/^.+\n.+\n/, "")) && (n.stack += "\n" + t) : n.stack = t
                } catch (pC) {}
            }
            throw n
        }
    }
    _request(e, t) {
        "string" == typeof e ? (t = t || {}).url = e : t = e || {},
        t = Ew(this.defaults, t);
        const {transitional: n, paramsSerializer: o, headers: a} = t;
        void 0 !== n && Xw.assertOptions(n, {
            silentJSONParsing: Jw.transitional(Jw.boolean),
            forcedJSONParsing: Jw.transitional(Jw.boolean),
            clarifyTimeoutError: Jw.transitional(Jw.boolean)
        }, !1),
        null != o && (Db.isFunction(o) ? t.paramsSerializer = {
            serialize: o
        } : Xw.assertOptions(o, {
            encode: Jw.function,
            serialize: Jw.function
        }, !0)),
        void 0 !== t.allowAbsoluteUrls || (void 0 !== this.defaults.allowAbsoluteUrls ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0),
        Xw.assertOptions(t, {
            baseUrl: Jw.spelling("baseURL"),
            withXsrfToken: Jw.spelling("withXSRFToken")
        }, !0),
        t.method = (t.method || this.defaults.method || "get").toLowerCase();
        let r = a && Db.merge(a.common, a[t.method]);
        a && Db.forEach(["delete", "get", "head", "post", "put", "patch", "common"], e => {
            delete a[e]
        }
        ),
        t.headers = hw.concat(r, a);
        const s = [];
        let i = !0;
        this.interceptors.request.forEach(function(e) {
            "function" == typeof e.runWhen && !1 === e.runWhen(t) || (i = i && e.synchronous,
            s.unshift(e.fulfilled, e.rejected))
        });
        const l = [];
        let u;
        this.interceptors.response.forEach(function(e) {
            l.push(e.fulfilled, e.rejected)
        });
        let c, d = 0;
        if (!i) {
            const e = [Ww.bind(this), void 0];
            for (e.unshift.apply(e, s),
            e.push.apply(e, l),
            c = e.length,
            u = Promise.resolve(t); d < c; )
                u = u.then(e[d++], e[d++]);
            return u
        }
        c = s.length;
        let p = t;
        for (d = 0; d < c; ) {
            const e = s[d++]
              , t = s[d++];
            try {
                p = e(p)
            } catch (f) {
                t.call(this, f);
                break
            }
        }
        try {
            u = Ww.call(this, p)
        } catch (f) {
            return Promise.reject(f)
        }
        for (d = 0,
        c = l.length; d < c; )
            u = u.then(l[d++], l[d++]);
        return u
    }
    getUri(e) {
        return Xb(Sw((e = Ew(this.defaults, e)).baseURL, e.url, e.allowAbsoluteUrls), e.params, e.paramsSerializer)
    }
}
;
Db.forEach(["delete", "get", "head", "options"], function(e) {
    Qw.prototype[e] = function(t, n) {
        return this.request(Ew(n || {}, {
            method: e,
            url: t,
            data: (n || {}).data
        }))
    }
}),
Db.forEach(["post", "put", "patch"], function(e) {
    function t(t) {
        return function(n, o, a) {
            return this.request(Ew(a || {}, {
                method: e,
                headers: t ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: n,
                data: o
            }))
        }
    }
    Qw.prototype[e] = t(),
    Qw.prototype[e + "Form"] = t(!0)
});
const e_ = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(e_).forEach( ([e,t]) => {
    e_[t] = e
}
);
const t_ = function e(t) {
    const n = new Qw(t)
      , o = Xy(Qw.prototype.request, n);
    return Db.extend(o, Qw.prototype, n, {
        allOwnKeys: !0
    }),
    Db.extend(o, n, null, {
        allOwnKeys: !0
    }),
    o.create = function(n) {
        return e(Ew(t, n))
    }
    ,
    o
}(lw);
t_.Axios = Qw,
t_.CanceledError = gw,
t_.CancelToken = class e {
    constructor(e) {
        if ("function" != typeof e)
            throw new TypeError("executor must be a function.");
        let t;
        this.promise = new Promise(function(e) {
            t = e
        }
        );
        const n = this;
        this.promise.then(e => {
            if (!n._listeners)
                return;
            let t = n._listeners.length;
            for (; t-- > 0; )
                n._listeners[t](e);
            n._listeners = null
        }
        ),
        this.promise.then = e => {
            let t;
            const o = new Promise(e => {
                n.subscribe(e),
                t = e
            }
            ).then(e);
            return o.cancel = function() {
                n.unsubscribe(t)
            }
            ,
            o
        }
        ,
        e(function(e, o, a) {
            n.reason || (n.reason = new gw(e,o,a),
            t(n.reason))
        })
    }
    throwIfRequested() {
        if (this.reason)
            throw this.reason
    }
    subscribe(e) {
        this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e]
    }
    unsubscribe(e) {
        if (!this._listeners)
            return;
        const t = this._listeners.indexOf(e);
        -1 !== t && this._listeners.splice(t, 1)
    }
    toAbortSignal() {
        const e = new AbortController
          , t = t => {
            e.abort(t)
        }
        ;
        return this.subscribe(t),
        e.signal.unsubscribe = () => this.unsubscribe(t),
        e.signal
    }
    static source() {
        let t;
        return {
            token: new e(function(e) {
                t = e
            }
            ),
            cancel: t
        }
    }
}
,
t_.isCancel = mw,
t_.VERSION = Gw,
t_.toFormData = qb,
t_.AxiosError = jb,
t_.Cancel = t_.CanceledError,
t_.all = function(e) {
    return Promise.all(e)
}
,
t_.spread = function(e) {
    return function(t) {
        return e.apply(null, t)
    }
}
,
t_.isAxiosError = function(e) {
    return Db.isObject(e) && !0 === e.isAxiosError
}
,
t_.mergeConfig = Ew,
t_.AxiosHeaders = hw,
t_.formToJSON = e => iw(Db.isHTMLForm(e) ? new FormData(e) : e),
t_.getAdapter = Zw,
t_.HttpStatusCode = e_,
t_.default = t_;
const {Axios: n_, AxiosError: o_, CanceledError: a_, isCancel: r_, CancelToken: s_, VERSION: i_, all: l_, Cancel: u_, isAxiosError: c_, spread: d_, toFormData: p_, AxiosHeaders: f_, HttpStatusCode: h_, formToJSON: v_, getAdapter: m_, mergeConfig: g_} = t_
  , y_ = "tk"
  , b_ = t_.create({
    baseURL: "https://r-client.dancsolutions.com/api",
    headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
    }
});
b_.interceptors.request.use(function(e) {
    if ("undefined" != typeof window) {
        const t = localStorage.getItem(y_);
        t && (e.headers.Authorization = `Bearer ${t}`)
    }
    return new URL(e.baseURL + e.url),
    e
}),
b_.interceptors.response.use(function(e) {
    return e
}, function(e) {
    return e.response && 401 === e.response.status && "undefined" != typeof window && localStorage.removeItem(y_),
    Promise.reject(e)
});
let w_ = 1;
const __ = new class {
    constructor() {
        n(this, "subscribers"),
        n(this, "toasts"),
        n(this, "dismissedToasts"),
        n(this, "subscribe", e => (this.subscribers.push(e),
        () => {
            const t = this.subscribers.indexOf(e);
            this.subscribers.splice(t, 1)
        }
        )),
        n(this, "publish", e => {
            this.subscribers.forEach(t => t(e))
        }
        ),
        n(this, "addToast", e => {
            this.publish(e),
            this.toasts = [...this.toasts, e]
        }
        ),
        n(this, "create", e => {
            var t;
            const {message: n, ...o} = e
              , a = "number" == typeof e.id || e.id && (null == (t = e.id) ? void 0 : t.length) > 0 ? e.id : w_++
              , r = this.toasts.find(e => e.id === a)
              , s = void 0 === e.dismissible || e.dismissible;
            return this.dismissedToasts.has(a) && this.dismissedToasts.delete(a),
            r ? this.toasts = this.toasts.map(t => t.id === a ? (this.publish({
                ...t,
                ...e,
                id: a,
                title: n
            }),
            {
                ...t,
                ...e,
                id: a,
                dismissible: s,
                title: n
            }) : t) : this.addToast({
                title: n,
                ...o,
                dismissible: s,
                id: a
            }),
            a
        }
        ),
        n(this, "dismiss", e => (e ? (this.dismissedToasts.add(e),
        requestAnimationFrame( () => this.subscribers.forEach(t => t({
            id: e,
            dismiss: !0
        })))) : this.toasts.forEach(e => {
            this.subscribers.forEach(t => t({
                id: e.id,
                dismiss: !0
            }))
        }
        ),
        e)),
        n(this, "message", (e, t) => this.create({
            ...t,
            message: e,
            type: "default"
        })),
        n(this, "error", (e, t) => this.create({
            ...t,
            type: "error",
            message: e
        })),
        n(this, "success", (e, t) => this.create({
            ...t,
            type: "success",
            message: e
        })),
        n(this, "info", (e, t) => this.create({
            ...t,
            type: "info",
            message: e
        })),
        n(this, "warning", (e, t) => this.create({
            ...t,
            type: "warning",
            message: e
        })),
        n(this, "loading", (e, t) => this.create({
            ...t,
            type: "loading",
            message: e
        })),
        n(this, "promise", (e, t) => {
            if (!t)
                return;
            let n;
            void 0 !== t.loading && (n = this.create({
                ...t,
                promise: e,
                type: "loading",
                message: t.loading,
                description: "function" != typeof t.description ? t.description : void 0
            }));
            const o = Promise.resolve(e instanceof Function ? e() : e);
            let a, r = void 0 !== n;
            const s = o.then(async e => {
                a = ["resolve", e];
                if (Lr(e))
                    r = !1,
                    this.create({
                        id: n,
                        type: "default",
                        message: e
                    });
                else if (x_(e) && !e.ok) {
                    r = !1;
                    const o = "function" == typeof t.error ? await t.error(`HTTP error! status: ${e.status}`) : t.error
                      , a = "function" == typeof t.description ? await t.description(`HTTP error! status: ${e.status}`) : t.description
                      , s = "object" == typeof o && !Lr(o) ? o : {
                        message: o || "",
                        id: n || ""
                    };
                    this.create({
                        id: n,
                        type: "error",
                        description: a,
                        ...s
                    })
                } else if (e instanceof Error) {
                    r = !1;
                    const o = "function" == typeof t.error ? await t.error(e) : t.error
                      , a = "function" == typeof t.description ? await t.description(e) : t.description
                      , s = "object" == typeof o && !Lr(o) ? o : {
                        message: o || "",
                        id: n || ""
                    };
                    this.create({
                        id: n,
                        type: "error",
                        description: a,
                        ...s
                    })
                } else if (void 0 !== t.success) {
                    r = !1;
                    const o = "function" == typeof t.success ? await t.success(e) : t.success
                      , a = "function" == typeof t.description ? await t.description(e) : t.description
                      , s = "object" == typeof o && !Lr(o) ? o : {
                        message: o || "",
                        id: n || ""
                    };
                    this.create({
                        id: n,
                        type: "success",
                        description: a,
                        ...s
                    })
                }
            }
            ).catch(async e => {
                if (a = ["reject", e],
                void 0 !== t.error) {
                    r = !1;
                    const o = "function" == typeof t.error ? await t.error(e) : t.error
                      , a = "function" == typeof t.description ? await t.description(e) : t.description
                      , s = "object" == typeof o && !Lr(o) ? o : {
                        message: o || "",
                        id: n || ""
                    };
                    this.create({
                        id: n,
                        type: "error",
                        description: a,
                        ...s
                    })
                }
            }
            ).finally( () => {
                var e;
                r && (this.dismiss(n),
                n = void 0),
                null == (e = t.finally) || e.call(t)
            }
            )
              , i = () => new Promise( (e, t) => s.then( () => "reject" === a[0] ? t(a[1]) : e(a[1])).catch(t));
            return "string" != typeof n && "number" != typeof n ? {
                unwrap: i
            } : Object.assign(n, {
                unwrap: i
            })
        }
        ),
        n(this, "custom", (e, t) => {
            const n = (null == t ? void 0 : t.id) || w_++;
            return this.publish({
                component: e,
                id: n,
                ...t
            }),
            n
        }
        ),
        n(this, "getActiveToasts", () => this.toasts.filter(e => !this.dismissedToasts.has(e.id))),
        this.subscribers = [],
        this.toasts = [],
        this.dismissedToasts = new Set
    }
}
;
const x_ = e => e && "object" == typeof e && "ok"in e && "boolean" == typeof e.ok && "status"in e && "number" == typeof e.status
  , k_ = function(e, t) {
    const n = (null == t ? void 0 : t.id) || w_++;
    return __.create({
        message: e,
        id: n,
        type: "default",
        ...t
    }),
    n
}
  , S_ = Object.assign(k_, {
    success: __.success,
    info: __.info,
    warning: __.warning,
    error: __.error,
    custom: __.custom,
    message: __.message,
    promise: __.promise,
    dismiss: __.dismiss,
    loading: __.loading
}, {
    getHistory: () => __.toasts,
    getToasts: () => __.getActiveToasts()
});
function C_(e) {
    return void 0 !== e.label
}
const E_ = "24px"
  , T_ = "16px";
function A_(...e) {
    return e.filter(Boolean).join(" ")
}
function O_(e, t) {
    const n = {};
    return [e, t].forEach( (e, t) => {
        const o = 1 === t
          , a = o ? "--mobile-offset" : "--offset"
          , r = o ? T_ : E_;
        function s(e) {
            ["top", "right", "bottom", "left"].forEach(t => {
                n[`${a}-${t}`] = "number" == typeof e ? `${e}px` : e
            }
            )
        }
        "number" == typeof e || "string" == typeof e ? s(e) : "object" == typeof e ? ["top", "right", "bottom", "left"].forEach(t => {
            void 0 === e[t] ? n[`${a}-${t}`] = r : n[`${a}-${t}`] = "number" == typeof e[t] ? `${e[t]}px` : e[t]
        }
        ) : s(r)
    }
    ),
    n
}
const M_ = ["data-rich-colors", "data-styled", "data-mounted", "data-promise", "data-swiped", "data-removed", "data-visible", "data-y-position", "data-x-position", "data-index", "data-front", "data-swiping", "data-dismissible", "data-type", "data-invert", "data-swipe-out", "data-swipe-direction", "data-expanded"]
  , P_ = ["aria-label", "data-disabled"];
var B_ = to({
    __name: "Toast",
    props: {
        toast: {},
        toasts: {},
        index: {},
        swipeDirections: {},
        expanded: {
            type: Boolean
        },
        invert: {
            type: Boolean
        },
        heights: {},
        gap: {},
        position: {},
        visibleToasts: {},
        expandByDefault: {
            type: Boolean
        },
        closeButton: {
            type: Boolean
        },
        interacting: {
            type: Boolean
        },
        style: {},
        cancelButtonStyle: {},
        actionButtonStyle: {},
        duration: {},
        class: {},
        unstyled: {
            type: Boolean
        },
        descriptionClass: {},
        loadingIcon: {},
        classes: {},
        icons: {},
        closeButtonAriaLabel: {},
        defaultRichColors: {
            type: Boolean
        }
    },
    emits: ["update:heights", "update:height", "removeToast"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = It(null)
          , r = It(null)
          , s = It(!1)
          , i = It(!1)
          , l = It(!1)
          , u = It(!1)
          , c = It(!1)
          , d = It(0)
          , p = It(0)
          , f = It(n.toast.duration || n.duration || 4e3)
          , h = It(null)
          , v = It(null)
          , m = ms( () => 0 === n.index)
          , g = ms( () => n.index + 1 <= n.visibleToasts)
          , y = ms( () => n.toast.type)
          , b = ms( () => !1 !== n.toast.dismissible)
          , w = ms( () => n.toast.class || "")
          , _ = ms( () => n.descriptionClass || "")
          , x = ms( () => {
            const e = n.toast.position || n.position
              , t = n.heights.filter(t => t.position === e).findIndex(e => e.toastId === n.toast.id);
            return t >= 0 ? t : 0
        }
        )
          , k = ms( () => {
            const e = n.toast.position || n.position;
            return n.heights.filter(t => t.position === e).reduce( (e, t, n) => n >= x.value ? e : e + t.height, 0)
        }
        )
          , S = ms( () => x.value * n.gap + k.value || 0)
          , C = ms( () => n.toast.closeButton ?? n.closeButton)
          , E = ms( () => n.toast.duration || n.duration || 4e3)
          , T = It(0)
          , A = It(0)
          , O = It(null)
          , M = ms( () => n.position.split("-"))
          , P = ms( () => M.value[0])
          , B = ms( () => M.value[1])
          , I = ms( () => "string" != typeof n.toast.title)
          , L = ms( () => "string" != typeof n.toast.description)
          , {isDocumentHidden: R} = function() {
            const e = It(!1);
            return Ya( () => {
                const t = () => {
                    e.value = document.hidden
                }
                ;
                return document.addEventListener("visibilitychange", t),
                () => window.removeEventListener("visibilitychange", t)
            }
            ),
            {
                isDocumentHidden: e
            }
        }()
          , z = ms( () => y.value && "loading" === y.value);
        function N() {
            i.value = !0,
            d.value = S.value,
            setTimeout( () => {
                o("removeToast", n.toast)
            }
            , 200)
        }
        function D() {
            var e, t;
            if (z.value || !b.value)
                return {};
            N(),
            null == (t = (e = n.toast).onDismiss) || t.call(e, n.toast)
        }
        function j(e) {
            !z.value && b.value && (h.value = new Date,
            d.value = S.value,
            e.target.setPointerCapture(e.pointerId),
            "BUTTON" !== e.target.tagName && (l.value = !0,
            O.value = {
                x: e.clientX,
                y: e.clientY
            }))
        }
        function F() {
            var e, t, o, s, i, p, f;
            if (u.value || !b.value)
                return;
            O.value = null;
            const m = Number((null == (e = v.value) ? void 0 : e.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0)
              , g = Number((null == (t = v.value) ? void 0 : t.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0)
              , y = (new Date).getTime() - ((null == (o = h.value) ? void 0 : o.getTime()) || 0)
              , w = "x" === a.value ? m : g
              , _ = Math.abs(w) / y;
            if (Math.abs(w) >= 45 || _ > .11)
                return d.value = S.value,
                null == (i = (s = n.toast).onDismiss) || i.call(s, n.toast),
                "x" === a.value ? r.value = m > 0 ? "right" : "left" : r.value = g > 0 ? "down" : "up",
                N(),
                void (u.value = !0);
            null == (p = v.value) || p.style.setProperty("--swipe-amount-x", "0px"),
            null == (f = v.value) || f.style.setProperty("--swipe-amount-y", "0px"),
            c.value = !1,
            l.value = !1,
            a.value = null
        }
        function $(e) {
            var t, o, r, s;
            if (!O.value || !b.value)
                return;
            if ((null == (o = null == (t = null == window ? void 0 : window.getSelection()) ? void 0 : t.toString()) ? void 0 : o.length) ?? !1)
                return;
            const i = e.clientY - O.value.y
              , l = e.clientX - O.value.x
              , u = n.swipeDirections ?? function(e) {
                const [t,n] = e.split("-")
                  , o = [];
                return t && o.push(t),
                n && o.push(n),
                o
            }(n.position);
            !a.value && (Math.abs(l) > 1 || Math.abs(i) > 1) && (a.value = Math.abs(l) > Math.abs(i) ? "x" : "y");
            let d = {
                x: 0,
                y: 0
            };
            const p = e => 1 / (1.5 + Math.abs(e) / 20);
            if ("y" === a.value) {
                if (u.includes("top") || u.includes("bottom"))
                    if (u.includes("top") && i < 0 || u.includes("bottom") && i > 0)
                        d.y = i;
                    else {
                        const e = i * p(i);
                        d.y = Math.abs(e) < Math.abs(i) ? e : i
                    }
            } else if ("x" === a.value && (u.includes("left") || u.includes("right")))
                if (u.includes("left") && l < 0 || u.includes("right") && l > 0)
                    d.x = l;
                else {
                    const e = l * p(l);
                    d.x = Math.abs(e) < Math.abs(l) ? e : l
                }
            (Math.abs(d.x) > 0 || Math.abs(d.y) > 0) && (c.value = !0),
            null == (r = v.value) || r.style.setProperty("--swipe-amount-x", `${d.x}px`),
            null == (s = v.value) || s.style.setProperty("--swipe-amount-y", `${d.y}px`)
        }
        function V() {
            l.value = !1,
            a.value = null,
            O.value = null
        }
        return Mo( () => {
            s.value = !0,
            f.value = E.value
        }
        ),
        Ya(async () => {
            if (!s.value || !v.value)
                return;
            await fn();
            const e = v.value
              , t = e.style.height;
            e.style.height = "auto";
            const a = e.getBoundingClientRect().height;
            e.style.height = t,
            p.value = a,
            o("update:height", {
                toastId: n.toast.id,
                height: a,
                position: n.toast.position || n.position
            })
        }
        ),
        Mo( () => {
            if (s.value = !0,
            !v.value)
                return;
            const e = v.value.getBoundingClientRect().height;
            p.value = e;
            const t = [{
                toastId: n.toast.id,
                height: e,
                position: n.toast.position
            }, ...n.heights];
            o("update:heights", t)
        }
        ),
        Io( () => {
            v.value && o("removeToast", n.toast)
        }
        ),
        Ya(e => {
            if (n.toast.promise && "loading" === y.value || n.toast.duration === 1 / 0 || "loading" === n.toast.type)
                return;
            let t;
            n.expanded || n.interacting || R.value ? ( () => {
                if (A.value < T.value) {
                    const e = (new Date).getTime() - T.value;
                    f.value = f.value - e
                }
                A.value = (new Date).getTime()
            }
            )() : f.value !== 1 / 0 && (T.value = (new Date).getTime(),
            t = setTimeout( () => {
                var e, t;
                null == (t = (e = n.toast).onAutoClose) || t.call(e, n.toast),
                N()
            }
            , f.value)),
            e( () => {
                clearTimeout(t)
            }
            )
        }
        ),
        Qa( () => n.toast.delete, e => {
            void 0 !== e && e && N()
        }
        , {
            deep: !0
        }),
        (e, t) => {
            var o, a, f, h, x, k, E, T, A, O, M, R, H, Z, q, W, G, X, J, Q, ee, te, oe, ae, re, se, ie;
            return Tr(),
            Br("li", {
                tabindex: "0",
                ref_key: "toastRef",
                ref: v,
                class: K(Nt(A_)(n.class, w.value, null == (o = e.classes) ? void 0 : o.toast, null == (a = e.toast.classes) ? void 0 : a.toast, null == (f = e.classes) ? void 0 : f[y.value], null == (x = null == (h = e.toast) ? void 0 : h.classes) ? void 0 : x[y.value])),
                "data-sonner-toast": "",
                "data-rich-colors": e.toast.richColors ?? e.defaultRichColors,
                "data-styled": !Boolean(e.toast.component || (null == (k = e.toast) ? void 0 : k.unstyled) || e.unstyled),
                "data-mounted": s.value,
                "data-promise": Boolean(e.toast.promise),
                "data-swiped": c.value,
                "data-removed": i.value,
                "data-visible": g.value,
                "data-y-position": P.value,
                "data-x-position": B.value,
                "data-index": e.index,
                "data-front": m.value,
                "data-swiping": l.value,
                "data-dismissible": b.value,
                "data-type": y.value,
                "data-invert": e.toast.invert || e.invert,
                "data-swipe-out": u.value,
                "data-swipe-direction": r.value,
                "data-expanded": Boolean(e.expanded || e.expandByDefault && s.value),
                style: U({
                    "--index": e.index,
                    "--toasts-before": e.index,
                    "--z-index": e.toasts.length - e.index,
                    "--offset": `${i.value ? d.value : S.value}px`,
                    "--initial-height": e.expandByDefault ? "auto" : `${p.value}px`,
                    ...e.style,
                    ...n.toast.style
                }),
                onDragend: V,
                onPointerdown: j,
                onPointerup: F,
                onPointermove: $
            }, [C.value && !e.toast.component && "loading" !== y.value ? (Tr(),
            Br("button", {
                key: 0,
                "aria-label": e.closeButtonAriaLabel || "Close toast",
                "data-disabled": z.value,
                "data-close-button": "true",
                class: K(Nt(A_)(null == (E = e.classes) ? void 0 : E.closeButton, null == (A = null == (T = e.toast) ? void 0 : T.classes) ? void 0 : A.closeButton)),
                onClick: D
            }, [(null == (O = e.icons) ? void 0 : O.close) ? (Tr(),
            Ir(Vo(null == (M = e.icons) ? void 0 : M.close), {
                key: 0
            })) : Wo(e.$slots, "close-icon", {
                key: 1
            })], 10, P_)) : Ur("v-if", !0), e.toast.component ? (Tr(),
            Ir(Vo(e.toast.component), Gr({
                key: 1
            }, e.toast.componentProps, {
                onCloseToast: D
            }), null, 16)) : (Tr(),
            Br(_r, {
                key: 2
            }, ["default" !== y.value || e.toast.icon || e.toast.promise ? (Tr(),
            Br("div", {
                key: 0,
                "data-icon": "",
                class: K(Nt(A_)(null == (R = e.classes) ? void 0 : R.icon, null == (Z = null == (H = e.toast) ? void 0 : H.classes) ? void 0 : Z.icon))
            }, [e.toast.icon ? (Tr(),
            Ir(Vo(e.toast.icon), {
                key: 0
            })) : (Tr(),
            Br(_r, {
                key: 1
            }, ["loading" === y.value ? Wo(e.$slots, "loading-icon", {
                key: 0
            }) : "success" === y.value ? Wo(e.$slots, "success-icon", {
                key: 1
            }) : "error" === y.value ? Wo(e.$slots, "error-icon", {
                key: 2
            }) : "warning" === y.value ? Wo(e.$slots, "warning-icon", {
                key: 3
            }) : "info" === y.value ? Wo(e.$slots, "info-icon", {
                key: 4
            }) : Ur("v-if", !0)], 64))], 2)) : Ur("v-if", !0), Dr("div", {
                "data-content": "",
                class: K(Nt(A_)(null == (q = e.classes) ? void 0 : q.content, null == (G = null == (W = e.toast) ? void 0 : W.classes) ? void 0 : G.content))
            }, [Dr("div", {
                "data-title": "",
                class: K(Nt(A_)(null == (X = e.classes) ? void 0 : X.title, null == (J = e.toast.classes) ? void 0 : J.title))
            }, [I.value ? (Tr(),
            Ir(Vo(e.toast.title), Y(Gr({
                key: 0
            }, e.toast.componentProps)), null, 16)) : (Tr(),
            Br(_r, {
                key: 1
            }, [Vr(ne(e.toast.title), 1)], 64))], 2), e.toast.description ? (Tr(),
            Br("div", {
                key: 0,
                "data-description": "",
                class: K(Nt(A_)(e.descriptionClass, _.value, null == (Q = e.classes) ? void 0 : Q.description, null == (ee = e.toast.classes) ? void 0 : ee.description))
            }, [L.value ? (Tr(),
            Ir(Vo(e.toast.description), Y(Gr({
                key: 0
            }, e.toast.componentProps)), null, 16)) : (Tr(),
            Br(_r, {
                key: 1
            }, [Vr(ne(e.toast.description), 1)], 64))], 2)) : Ur("v-if", !0)], 2), e.toast.cancel ? (Tr(),
            Br("button", {
                key: 1,
                style: U(e.toast.cancelButtonStyle || e.cancelButtonStyle),
                class: K(Nt(A_)(null == (te = e.classes) ? void 0 : te.cancelButton, null == (oe = e.toast.classes) ? void 0 : oe.cancelButton)),
                "data-button": "",
                "data-cancel": "",
                onClick: t[0] || (t[0] = t => {
                    var n, o;
                    Nt(C_)(e.toast.cancel) && b.value && (null == (o = (n = e.toast.cancel).onClick) || o.call(n, t),
                    N())
                }
                )
            }, ne(Nt(C_)(e.toast.cancel) ? null == (ae = e.toast.cancel) ? void 0 : ae.label : e.toast.cancel), 7)) : Ur("v-if", !0), e.toast.action ? (Tr(),
            Br("button", {
                key: 2,
                style: U(e.toast.actionButtonStyle || e.actionButtonStyle),
                class: K(Nt(A_)(null == (re = e.classes) ? void 0 : re.actionButton, null == (se = e.toast.classes) ? void 0 : se.actionButton)),
                "data-button": "",
                "data-action": "",
                onClick: t[1] || (t[1] = t => {
                    var n, o;
                    Nt(C_)(e.toast.action) && (null == (o = (n = e.toast.action).onClick) || o.call(n, t),
                    t.defaultPrevented || N())
                }
                )
            }, ne(Nt(C_)(e.toast.action) ? null == (ie = e.toast.action) ? void 0 : ie.label : e.toast.action), 7)) : Ur("v-if", !0)], 64))], 46, M_)
        }
    }
})
  , I_ = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [o,a] of t)
        n[o] = a;
    return n
}
;
const L_ = {
    xmlns: "http://www.w3.org/2000/svg",
    width: "12",
    height: "12",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stoke-width": "1.5",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
};
var R_ = I_({}, [["render", function(e, t) {
    return Tr(),
    Br("svg", L_, t[0] || (t[0] = [Dr("line", {
        x1: "18",
        y1: "6",
        x2: "6",
        y2: "18"
    }, null, -1), Dr("line", {
        x1: "6",
        y1: "6",
        x2: "18",
        y2: "18"
    }, null, -1)]))
}
]]);
const z_ = ["data-visible"]
  , N_ = {
    class: "sonner-spinner"
};
var D_ = to({
    __name: "Loader",
    props: {
        visible: {
            type: Boolean
        }
    },
    setup(e) {
        const t = Array(12).fill(0);
        return (e, n) => (Tr(),
        Br("div", {
            class: "sonner-loading-wrapper",
            "data-visible": e.visible
        }, [Dr("div", N_, [(Tr(!0),
        Br(_r, null, qo(Nt(t), e => (Tr(),
        Br("div", {
            key: `spinner-bar-${e}`,
            class: "sonner-loading-bar"
        }))), 128))])], 8, z_))
    }
});
const j_ = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
};
var F_ = I_({}, [["render", function(e, t) {
    return Tr(),
    Br("svg", j_, t[0] || (t[0] = [Dr("path", {
        "fill-rule": "evenodd",
        d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
        "clip-rule": "evenodd"
    }, null, -1)]))
}
]]);
const $_ = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
};
var V_ = I_({}, [["render", function(e, t) {
    return Tr(),
    Br("svg", $_, t[0] || (t[0] = [Dr("path", {
        "fill-rule": "evenodd",
        d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
        "clip-rule": "evenodd"
    }, null, -1)]))
}
]]);
const H_ = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    height: "20",
    width: "20"
};
var U_ = I_({}, [["render", function(e, t) {
    return Tr(),
    Br("svg", H_, t[0] || (t[0] = [Dr("path", {
        "fill-rule": "evenodd",
        d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
        "clip-rule": "evenodd"
    }, null, -1)]))
}
]]);
const Z_ = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
};
var q_ = I_({}, [["render", function(e, t) {
    return Tr(),
    Br("svg", Z_, t[0] || (t[0] = [Dr("path", {
        "fill-rule": "evenodd",
        d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
        "clip-rule": "evenodd"
    }, null, -1)]))
}
]]);
const W_ = ["aria-label"]
  , G_ = ["data-sonner-theme", "dir", "data-theme", "data-rich-colors", "data-y-position", "data-x-position", "data-lifted"]
  , K_ = "undefined" != typeof window && "undefined" != typeof document;
function Y_() {
    if ("undefined" == typeof window)
        return "ltr";
    if ("undefined" == typeof document)
        return "ltr";
    const e = document.documentElement.getAttribute("dir");
    return "auto" !== e && e ? e : window.getComputedStyle(document.documentElement).direction
}
var X_ = to({
    name: "Toaster",
    inheritAttrs: !1,
    __name: "Toaster",
    props: {
        invert: {
            type: Boolean,
            default: !1
        },
        theme: {
            default: "light"
        },
        position: {
            default: "bottom-right"
        },
        hotkey: {
            default: () => ["altKey", "KeyT"]
        },
        richColors: {
            type: Boolean,
            default: !1
        },
        expand: {
            type: Boolean,
            default: !1
        },
        duration: {},
        gap: {
            default: 14
        },
        visibleToasts: {
            default: 3
        },
        closeButton: {
            type: Boolean,
            default: !1
        },
        toastOptions: {
            default: () => ({})
        },
        class: {
            default: ""
        },
        style: {},
        offset: {
            default: E_
        },
        mobileOffset: {
            default: T_
        },
        dir: {
            default: "auto"
        },
        swipeDirections: {},
        icons: {},
        containerAriaLabel: {
            default: "Notifications"
        }
    },
    setup(e) {
        const t = e
          , n = ta()
          , o = It([]);
        function a(e, t) {
            return o.value.filter(n => !n.position && 0 === t || n.position === e)
        }
        const r = ms( () => {
            const e = o.value.filter(e => e.position).map(e => e.position);
            return e.length > 0 ? Array.from(new Set([t.position].concat(e))) : [t.position]
        }
        )
          , s = ms( () => {
            const e = {};
            return r.value.forEach(t => {
                e[t] = o.value.filter(e => e.position === t)
            }
            ),
            e
        }
        )
          , i = It([])
          , l = It(!1)
          , u = It(!1)
          , c = It("system" !== t.theme ? t.theme : "undefined" != typeof window && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light")
          , d = It(null)
          , p = It(null)
          , f = It(!1)
          , h = t.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
        function v(e) {
            var t;
            (null == (t = o.value.find(t => t.id === e.id)) ? void 0 : t.delete) || __.dismiss(e.id),
            o.value = o.value.filter( ({id: t}) => t !== e.id),
            setTimeout( () => {
                o.value.find(t => t.id === e.id) || (i.value = i.value.filter(t => t.toastId !== e.id))
            }
            , 250)
        }
        function m(e) {
            var t, n;
            f.value && !(null == (n = null == (t = e.currentTarget) ? void 0 : t.contains) ? void 0 : n.call(t, e.relatedTarget)) && (f.value = !1,
            p.value && (p.value.focus({
                preventScroll: !0
            }),
            p.value = null))
        }
        function g(e) {
            e.target instanceof HTMLElement && "false" === e.target.dataset.dismissible || f.value || (f.value = !0,
            p.value = e.relatedTarget)
        }
        function y(e) {
            if (e.target) {
                if (e.target instanceof HTMLElement && "false" === e.target.dataset.dismissible)
                    return
            }
            u.value = !0
        }
        function b() {
            l.value = !0
        }
        function w() {
            u.value || (l.value = !1)
        }
        function _() {
            l.value = !1
        }
        function x() {
            u.value = !1
        }
        function k(e) {
            i.value = e
        }
        function S(e) {
            const t = i.value.findIndex(t => t.toastId === e.toastId);
            if (-1 !== t)
                i.value[t] = e;
            else {
                const t = i.value.findIndex(t => t.position === e.position);
                -1 !== t ? i.value.splice(t, 0, e) : i.value.unshift(e)
            }
        }
        return Ya(e => {
            e(__.subscribe(e => {
                e.dismiss ? requestAnimationFrame( () => {
                    o.value = o.value.map(t => t.id === e.id ? {
                        ...t,
                        delete: !0
                    } : t)
                }
                ) : fn( () => {
                    const t = o.value.findIndex(t => t.id === e.id);
                    o.value = -1 !== t ? [...o.value.slice(0, t), {
                        ...o.value[t],
                        ...e
                    }, ...o.value.slice(t + 1)] : [e, ...o.value]
                }
                )
            }
            ))
        }
        ),
        Ya(e => {
            if ("undefined" == typeof window)
                return;
            if ("system" !== t.theme)
                return void (c.value = t.theme);
            const n = window.matchMedia("(prefers-color-scheme: dark)")
              , o = e => {
                c.value = e ? "dark" : "light"
            }
            ;
            o(n.matches);
            const a = e => {
                o(e.matches)
            }
            ;
            try {
                n.addEventListener("change", a)
            } catch {
                n.addListener(a)
            }
            e( () => {
                try {
                    n.removeEventListener("change", a)
                } catch {
                    n.removeListener(a)
                }
            }
            )
        }
        ),
        Ya( () => {
            d.value && p.value && (p.value.focus({
                preventScroll: !0
            }),
            p.value = null,
            f.value = !1)
        }
        ),
        Ya( () => {
            o.value.length <= 1 && (l.value = !1)
        }
        ),
        Ya(e => {
            function n(e) {
                const n = t.hotkey.every(t => e[t] || e.code === t)
                  , o = Array.isArray(d.value) ? d.value[0] : d.value;
                n && (l.value = !0,
                null == o || o.focus());
                const a = document.activeElement === d.value || (null == o ? void 0 : o.contains(document.activeElement));
                "Escape" === e.code && a && (l.value = !1)
            }
            K_ && (document.addEventListener("keydown", n),
            e( () => {
                document.removeEventListener("keydown", n)
            }
            ))
        }
        ),
        (e, p) => (Tr(),
        Br(_r, null, [Ur(" Remove item from normal navigation flow, only available via hotkey "), Dr("section", {
            "aria-label": `${e.containerAriaLabel} ${Nt(h)}`,
            tabIndex: -1,
            "aria-live": "polite",
            "aria-relevant": "additions text",
            "aria-atomic": "false"
        }, [(Tr(!0),
        Br(_r, null, qo(r.value, (r, p) => {
            var f;
            return Tr(),
            Br("ol", Gr({
                key: r,
                ref_for: !0,
                ref_key: "listRef",
                ref: d,
                "data-sonner-toaster": "",
                "data-sonner-theme": c.value,
                class: t.class,
                dir: "auto" === e.dir ? Y_() : e.dir,
                tabIndex: -1,
                "data-theme": e.theme,
                "data-rich-colors": e.richColors,
                "data-y-position": r.split("-")[0],
                "data-x-position": r.split("-")[1],
                "data-lifted": l.value && o.value.length > 1 && !e.expand,
                style: {
                    "--front-toast-height": `${(null == (f = i.value[0]) ? void 0 : f.height) || 0}px`,
                    "--width": `${Nt(356)}px`,
                    "--gap": `${e.gap}px`,
                    ...e.style,
                    ...Nt(n).style,
                    ...Nt(O_)(e.offset, e.mobileOffset)
                }
            }, e.$attrs, {
                onBlur: m,
                onFocus: g,
                onMouseenter: b,
                onMousemove: b,
                onMouseleave: w,
                onDragend: _,
                onPointerdown: y,
                onPointerup: x
            }), [(Tr(!0),
            Br(_r, null, qo(a(r, p), (n, o) => {
                var a, c, d, p, f, h, m, g, y, b;
                return Tr(),
                Ir(B_, {
                    key: n.id,
                    heights: i.value,
                    icons: e.icons,
                    index: o,
                    toast: n,
                    defaultRichColors: e.richColors,
                    duration: (null == (a = e.toastOptions) ? void 0 : a.duration) ?? e.duration,
                    class: K((null == (c = e.toastOptions) ? void 0 : c.class) ?? ""),
                    descriptionClass: null == (d = e.toastOptions) ? void 0 : d.descriptionClass,
                    invert: e.invert,
                    visibleToasts: e.visibleToasts,
                    closeButton: (null == (p = e.toastOptions) ? void 0 : p.closeButton) ?? e.closeButton,
                    interacting: u.value,
                    position: r,
                    style: U(null == (f = e.toastOptions) ? void 0 : f.style),
                    unstyled: null == (h = e.toastOptions) ? void 0 : h.unstyled,
                    classes: null == (m = e.toastOptions) ? void 0 : m.classes,
                    cancelButtonStyle: null == (g = e.toastOptions) ? void 0 : g.cancelButtonStyle,
                    actionButtonStyle: null == (y = e.toastOptions) ? void 0 : y.actionButtonStyle,
                    "close-button-aria-label": null == (b = e.toastOptions) ? void 0 : b.closeButtonAriaLabel,
                    toasts: s.value[r],
                    expandByDefault: e.expand,
                    gap: e.gap,
                    expanded: l.value,
                    swipeDirections: t.swipeDirections,
                    "onUpdate:heights": k,
                    "onUpdate:height": S,
                    onRemoveToast: v
                }, {
                    "close-icon": En( () => [Wo(e.$slots, "close-icon", {}, () => [jr(R_)])]),
                    "loading-icon": En( () => [Wo(e.$slots, "loading-icon", {}, () => [jr(D_, {
                        visible: "loading" === n.type
                    }, null, 8, ["visible"])])]),
                    "success-icon": En( () => [Wo(e.$slots, "success-icon", {}, () => [jr(F_)])]),
                    "error-icon": En( () => [Wo(e.$slots, "error-icon", {}, () => [jr(q_)])]),
                    "warning-icon": En( () => [Wo(e.$slots, "warning-icon", {}, () => [jr(U_)])]),
                    "info-icon": En( () => [Wo(e.$slots, "info-icon", {}, () => [jr(V_)])]),
                    _: 2
                }, 1032, ["heights", "icons", "index", "toast", "defaultRichColors", "duration", "class", "descriptionClass", "invert", "visibleToasts", "closeButton", "interacting", "position", "style", "unstyled", "classes", "cancelButtonStyle", "actionButtonStyle", "close-button-aria-label", "toasts", "expandByDefault", "gap", "expanded", "swipeDirections"])
            }
            ), 128))], 16, G_)
        }
        ), 128))], 8, W_)], 2112))
    }
});
/*!
  * vue-router v4.5.1
  * (c) 2025 Eduardo San Martin Morote
  * @license MIT
  */
const J_ = "undefined" != typeof document;
function Q_(e) {
    return "object" == typeof e || "displayName"in e || "props"in e || "__vccOpts"in e
}
const ex = Object.assign;
function tx(e, t) {
    const n = {};
    for (const o in t) {
        const a = t[o];
        n[o] = ox(a) ? a.map(e) : e(a)
    }
    return n
}
const nx = () => {}
  , ox = Array.isArray
  , ax = /#/g
  , rx = /&/g
  , sx = /\//g
  , ix = /=/g
  , lx = /\?/g
  , ux = /\+/g
  , cx = /%5B/g
  , dx = /%5D/g
  , px = /%5E/g
  , fx = /%60/g
  , hx = /%7B/g
  , vx = /%7C/g
  , mx = /%7D/g
  , gx = /%20/g;
function yx(e) {
    return encodeURI("" + e).replace(vx, "|").replace(cx, "[").replace(dx, "]")
}
function bx(e) {
    return yx(e).replace(ux, "%2B").replace(gx, "+").replace(ax, "%23").replace(rx, "%26").replace(fx, "`").replace(hx, "{").replace(mx, "}").replace(px, "^")
}
function wx(e) {
    return bx(e).replace(ix, "%3D")
}
function _x(e) {
    return null == e ? "" : function(e) {
        return yx(e).replace(ax, "%23").replace(lx, "%3F")
    }(e).replace(sx, "%2F")
}
function xx(e) {
    try {
        return decodeURIComponent("" + e)
    } catch (t) {}
    return "" + e
}
const kx = /\/$/;
function Sx(e, t, n="/") {
    let o, a = {}, r = "", s = "";
    const i = t.indexOf("#");
    let l = t.indexOf("?");
    return i < l && i >= 0 && (l = -1),
    l > -1 && (o = t.slice(0, l),
    r = t.slice(l + 1, i > -1 ? i : t.length),
    a = e(r)),
    i > -1 && (o = o || t.slice(0, i),
    s = t.slice(i, t.length)),
    o = function(e, t) {
        if (e.startsWith("/"))
            return e;
        if (!e)
            return t;
        const n = t.split("/")
          , o = e.split("/")
          , a = o[o.length - 1];
        ".." !== a && "." !== a || o.push("");
        let r, s, i = n.length - 1;
        for (r = 0; r < o.length; r++)
            if (s = o[r],
            "." !== s) {
                if (".." !== s)
                    break;
                i > 1 && i--
            }
        return n.slice(0, i).join("/") + "/" + o.slice(r).join("/")
    }(null != o ? o : t, n),
    {
        fullPath: o + (r && "?") + r + s,
        path: o,
        query: a,
        hash: xx(s)
    }
}
function Cx(e, t) {
    return t && e.toLowerCase().startsWith(t.toLowerCase()) ? e.slice(t.length) || "/" : e
}
function Ex(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t)
}
function Tx(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length)
        return !1;
    for (const n in e)
        if (!Ax(e[n], t[n]))
            return !1;
    return !0
}
function Ax(e, t) {
    return ox(e) ? Ox(e, t) : ox(t) ? Ox(t, e) : e === t
}
function Ox(e, t) {
    return ox(t) ? e.length === t.length && e.every( (e, n) => e === t[n]) : 1 === e.length && e[0] === t
}
const Mx = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
};
var Px, Bx, Ix, Lx;
function Rx(e) {
    if (!e)
        if (J_) {
            const t = document.querySelector("base");
            e = (e = t && t.getAttribute("href") || "/").replace(/^\w+:\/\/[^\/]+/, "")
        } else
            e = "/";
    return "/" !== e[0] && "#" !== e[0] && (e = "/" + e),
    e.replace(kx, "")
}
(Bx = Px || (Px = {})).pop = "pop",
Bx.push = "push",
(Lx = Ix || (Ix = {})).back = "back",
Lx.forward = "forward",
Lx.unknown = "";
const zx = /^[^#]+#/;
function Nx(e, t) {
    return e.replace(zx, "#") + t
}
const Dx = () => ({
    left: window.scrollX,
    top: window.scrollY
});
function jx(e) {
    let t;
    if ("el"in e) {
        const n = e.el
          , o = "string" == typeof n && n.startsWith("#")
          , a = "string" == typeof n ? o ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!a)
            return;
        t = function(e, t) {
            const n = document.documentElement.getBoundingClientRect()
              , o = e.getBoundingClientRect();
            return {
                behavior: t.behavior,
                left: o.left - n.left - (t.left || 0),
                top: o.top - n.top - (t.top || 0)
            }
        }(a, e)
    } else
        t = e;
    "scrollBehavior"in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(null != t.left ? t.left : window.scrollX, null != t.top ? t.top : window.scrollY)
}
function Fx(e, t) {
    return (history.state ? history.state.position - t : -1) + e
}
const $x = new Map;
function Vx(e, t) {
    const {pathname: n, search: o, hash: a} = t
      , r = e.indexOf("#");
    if (r > -1) {
        let t = a.includes(e.slice(r)) ? e.slice(r).length : 1
          , n = a.slice(t);
        return "/" !== n[0] && (n = "/" + n),
        Cx(n, "")
    }
    return Cx(n, e) + o + a
}
function Hx(e, t, n, o=!1, a=!1) {
    return {
        back: e,
        current: t,
        forward: n,
        replaced: o,
        position: window.history.length,
        scroll: a ? Dx() : null
    }
}
function Ux(e) {
    const {history: t, location: n} = window
      , o = {
        value: Vx(e, n)
    }
      , a = {
        value: t.state
    };
    function r(o, r, s) {
        const i = e.indexOf("#")
          , l = i > -1 ? (n.host && document.querySelector("base") ? e : e.slice(i)) + o : location.protocol + "//" + location.host + e + o;
        try {
            t[s ? "replaceState" : "pushState"](r, "", l),
            a.value = r
        } catch (u) {
            n[s ? "replace" : "assign"](l)
        }
    }
    return a.value || r(o.value, {
        back: null,
        current: o.value,
        forward: null,
        position: t.length - 1,
        replaced: !0,
        scroll: null
    }, !0),
    {
        location: o,
        state: a,
        push: function(e, n) {
            const s = ex({}, a.value, t.state, {
                forward: e,
                scroll: Dx()
            });
            r(s.current, s, !0),
            r(e, ex({}, Hx(o.value, e, null), {
                position: s.position + 1
            }, n), !1),
            o.value = e
        },
        replace: function(e, n) {
            r(e, ex({}, t.state, Hx(a.value.back, e, a.value.forward, !0), n, {
                position: a.value.position
            }), !0),
            o.value = e
        }
    }
}
function Zx(e) {
    return "string" == typeof e || "symbol" == typeof e
}
const qx = Symbol("");
var Wx, Gx;
function Kx(e, t) {
    return ex(new Error, {
        type: e,
        [qx]: !0
    }, t)
}
function Yx(e, t) {
    return e instanceof Error && qx in e && (null == t || !!(e.type & t))
}
(Gx = Wx || (Wx = {}))[Gx.aborted = 4] = "aborted",
Gx[Gx.cancelled = 8] = "cancelled",
Gx[Gx.duplicated = 16] = "duplicated";
const Xx = "[^/]+?"
  , Jx = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
}
  , Qx = /[.+*?^${}()[\]/\\]/g;
function ek(e, t) {
    let n = 0;
    for (; n < e.length && n < t.length; ) {
        const o = t[n] - e[n];
        if (o)
            return o;
        n++
    }
    return e.length < t.length ? 1 === e.length && 80 === e[0] ? -1 : 1 : e.length > t.length ? 1 === t.length && 80 === t[0] ? 1 : -1 : 0
}
function tk(e, t) {
    let n = 0;
    const o = e.score
      , a = t.score;
    for (; n < o.length && n < a.length; ) {
        const e = ek(o[n], a[n]);
        if (e)
            return e;
        n++
    }
    if (1 === Math.abs(a.length - o.length)) {
        if (nk(o))
            return 1;
        if (nk(a))
            return -1
    }
    return a.length - o.length
}
function nk(e) {
    const t = e[e.length - 1];
    return e.length > 0 && t[t.length - 1] < 0
}
const ok = {
    type: 0,
    value: ""
}
  , ak = /[a-zA-Z0-9_]/;
function rk(e, t, n) {
    const o = function(e, t) {
        const n = ex({}, Jx, t)
          , o = [];
        let a = n.start ? "^" : "";
        const r = [];
        for (const l of e) {
            const e = l.length ? [] : [90];
            n.strict && !l.length && (a += "/");
            for (let t = 0; t < l.length; t++) {
                const o = l[t];
                let s = 40 + (n.sensitive ? .25 : 0);
                if (0 === o.type)
                    t || (a += "/"),
                    a += o.value.replace(Qx, "\\$&"),
                    s += 40;
                else if (1 === o.type) {
                    const {value: e, repeatable: n, optional: u, regexp: c} = o;
                    r.push({
                        name: e,
                        repeatable: n,
                        optional: u
                    });
                    const d = c || Xx;
                    if (d !== Xx) {
                        s += 10;
                        try {
                            new RegExp(`(${d})`)
                        } catch (i) {
                            throw new Error(`Invalid custom RegExp for param "${e}" (${d}): ` + i.message)
                        }
                    }
                    let p = n ? `((?:${d})(?:/(?:${d}))*)` : `(${d})`;
                    t || (p = u && l.length < 2 ? `(?:/${p})` : "/" + p),
                    u && (p += "?"),
                    a += p,
                    s += 20,
                    u && (s += -8),
                    n && (s += -20),
                    ".*" === d && (s += -50)
                }
                e.push(s)
            }
            o.push(e)
        }
        if (n.strict && n.end) {
            const e = o.length - 1;
            o[e][o[e].length - 1] += .7000000000000001
        }
        n.strict || (a += "/?"),
        n.end ? a += "$" : n.strict && !a.endsWith("/") && (a += "(?:/|$)");
        const s = new RegExp(a,n.sensitive ? "" : "i");
        return {
            re: s,
            score: o,
            keys: r,
            parse: function(e) {
                const t = e.match(s)
                  , n = {};
                if (!t)
                    return null;
                for (let o = 1; o < t.length; o++) {
                    const e = t[o] || ""
                      , a = r[o - 1];
                    n[a.name] = e && a.repeatable ? e.split("/") : e
                }
                return n
            },
            stringify: function(t) {
                let n = ""
                  , o = !1;
                for (const a of e) {
                    o && n.endsWith("/") || (n += "/"),
                    o = !1;
                    for (const e of a)
                        if (0 === e.type)
                            n += e.value;
                        else if (1 === e.type) {
                            const {value: r, repeatable: s, optional: i} = e
                              , l = r in t ? t[r] : "";
                            if (ox(l) && !s)
                                throw new Error(`Provided param "${r}" is an array but it is not repeatable (* or + modifiers)`);
                            const u = ox(l) ? l.join("/") : l;
                            if (!u) {
                                if (!i)
                                    throw new Error(`Missing required param "${r}"`);
                                a.length < 2 && (n.endsWith("/") ? n = n.slice(0, -1) : o = !0)
                            }
                            n += u
                        }
                }
                return n || "/"
            }
        }
    }(function(e) {
        if (!e)
            return [[]];
        if ("/" === e)
            return [[ok]];
        if (!e.startsWith("/"))
            throw new Error(`Invalid path "${e}"`);
        function t(e) {
            throw new Error(`ERR (${n})/"${u}": ${e}`)
        }
        let n = 0
          , o = n;
        const a = [];
        let r;
        function s() {
            r && a.push(r),
            r = []
        }
        let i, l = 0, u = "", c = "";
        function d() {
            u && (0 === n ? r.push({
                type: 0,
                value: u
            }) : 1 === n || 2 === n || 3 === n ? (r.length > 1 && ("*" === i || "+" === i) && t(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`),
            r.push({
                type: 1,
                value: u,
                regexp: c,
                repeatable: "*" === i || "+" === i,
                optional: "*" === i || "?" === i
            })) : t("Invalid state to consume buffer"),
            u = "")
        }
        function p() {
            u += i
        }
        for (; l < e.length; )
            if (i = e[l++],
            "\\" !== i || 2 === n)
                switch (n) {
                case 0:
                    "/" === i ? (u && d(),
                    s()) : ":" === i ? (d(),
                    n = 1) : p();
                    break;
                case 4:
                    p(),
                    n = o;
                    break;
                case 1:
                    "(" === i ? n = 2 : ak.test(i) ? p() : (d(),
                    n = 0,
                    "*" !== i && "?" !== i && "+" !== i && l--);
                    break;
                case 2:
                    ")" === i ? "\\" == c[c.length - 1] ? c = c.slice(0, -1) + i : n = 3 : c += i;
                    break;
                case 3:
                    d(),
                    n = 0,
                    "*" !== i && "?" !== i && "+" !== i && l--,
                    c = "";
                    break;
                default:
                    t("Unknown state")
                }
            else
                o = n,
                n = 4;
        return 2 === n && t(`Unfinished custom RegExp for param "${u}"`),
        d(),
        s(),
        a
    }(e.path), n)
      , a = ex(o, {
        record: e,
        parent: t,
        children: [],
        alias: []
    });
    return t && !a.record.aliasOf == !t.record.aliasOf && t.children.push(a),
    a
}
function sk(e, t) {
    const n = []
      , o = new Map;
    function a(e, n, o) {
        const i = !o
          , l = lk(e);
        l.aliasOf = o && o.record;
        const u = pk(t, e)
          , c = [l];
        if ("alias"in e) {
            const t = "string" == typeof e.alias ? [e.alias] : e.alias;
            for (const e of t)
                c.push(lk(ex({}, l, {
                    components: o ? o.record.components : l.components,
                    path: e,
                    aliasOf: o ? o.record : l
                })))
        }
        let d, p;
        for (const t of c) {
            const {path: c} = t;
            if (n && "/" !== c[0]) {
                const e = n.record.path
                  , o = "/" === e[e.length - 1] ? "" : "/";
                t.path = n.record.path + (c && o + c)
            }
            if (d = rk(t, n, u),
            o ? o.alias.push(d) : (p = p || d,
            p !== d && p.alias.push(d),
            i && e.name && !ck(d) && r(e.name)),
            fk(d) && s(d),
            l.children) {
                const e = l.children;
                for (let t = 0; t < e.length; t++)
                    a(e[t], d, o && o.children[t])
            }
            o = o || d
        }
        return p ? () => {
            r(p)
        }
        : nx
    }
    function r(e) {
        if (Zx(e)) {
            const t = o.get(e);
            t && (o.delete(e),
            n.splice(n.indexOf(t), 1),
            t.children.forEach(r),
            t.alias.forEach(r))
        } else {
            const t = n.indexOf(e);
            t > -1 && (n.splice(t, 1),
            e.record.name && o.delete(e.record.name),
            e.children.forEach(r),
            e.alias.forEach(r))
        }
    }
    function s(e) {
        const t = function(e, t) {
            let n = 0
              , o = t.length;
            for (; n !== o; ) {
                const a = n + o >> 1;
                tk(e, t[a]) < 0 ? o = a : n = a + 1
            }
            const a = function(e) {
                let t = e;
                for (; t = t.parent; )
                    if (fk(t) && 0 === tk(e, t))
                        return t;
                return
            }(e);
            a && (o = t.lastIndexOf(a, o - 1));
            return o
        }(e, n);
        n.splice(t, 0, e),
        e.record.name && !ck(e) && o.set(e.record.name, e)
    }
    return t = pk({
        strict: !1,
        end: !0,
        sensitive: !1
    }, t),
    e.forEach(e => a(e)),
    {
        addRoute: a,
        resolve: function(e, t) {
            let a, r, s, i = {};
            if ("name"in e && e.name) {
                if (a = o.get(e.name),
                !a)
                    throw Kx(1, {
                        location: e
                    });
                s = a.record.name,
                i = ex(ik(t.params, a.keys.filter(e => !e.optional).concat(a.parent ? a.parent.keys.filter(e => e.optional) : []).map(e => e.name)), e.params && ik(e.params, a.keys.map(e => e.name))),
                r = a.stringify(i)
            } else if (null != e.path)
                r = e.path,
                a = n.find(e => e.re.test(r)),
                a && (i = a.parse(r),
                s = a.record.name);
            else {
                if (a = t.name ? o.get(t.name) : n.find(e => e.re.test(t.path)),
                !a)
                    throw Kx(1, {
                        location: e,
                        currentLocation: t
                    });
                s = a.record.name,
                i = ex({}, t.params, e.params),
                r = a.stringify(i)
            }
            const l = [];
            let u = a;
            for (; u; )
                l.unshift(u.record),
                u = u.parent;
            return {
                name: s,
                path: r,
                params: i,
                matched: l,
                meta: dk(l)
            }
        },
        removeRoute: r,
        clearRoutes: function() {
            n.length = 0,
            o.clear()
        },
        getRoutes: function() {
            return n
        },
        getRecordMatcher: function(e) {
            return o.get(e)
        }
    }
}
function ik(e, t) {
    const n = {};
    for (const o of t)
        o in e && (n[o] = e[o]);
    return n
}
function lk(e) {
    const t = {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: e.aliasOf,
        beforeEnter: e.beforeEnter,
        props: uk(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components"in e ? e.components || null : e.component && {
            default: e.component
        }
    };
    return Object.defineProperty(t, "mods", {
        value: {}
    }),
    t
}
function uk(e) {
    const t = {}
      , n = e.props || !1;
    if ("component"in e)
        t.default = n;
    else
        for (const o in e.components)
            t[o] = "object" == typeof n ? n[o] : n;
    return t
}
function ck(e) {
    for (; e; ) {
        if (e.record.aliasOf)
            return !0;
        e = e.parent
    }
    return !1
}
function dk(e) {
    return e.reduce( (e, t) => ex(e, t.meta), {})
}
function pk(e, t) {
    const n = {};
    for (const o in e)
        n[o] = o in t ? t[o] : e[o];
    return n
}
function fk({record: e}) {
    return !!(e.name || e.components && Object.keys(e.components).length || e.redirect)
}
function hk(e) {
    const t = {};
    if ("" === e || "?" === e)
        return t;
    const n = ("?" === e[0] ? e.slice(1) : e).split("&");
    for (let o = 0; o < n.length; ++o) {
        const e = n[o].replace(ux, " ")
          , a = e.indexOf("=")
          , r = xx(a < 0 ? e : e.slice(0, a))
          , s = a < 0 ? null : xx(e.slice(a + 1));
        if (r in t) {
            let e = t[r];
            ox(e) || (e = t[r] = [e]),
            e.push(s)
        } else
            t[r] = s
    }
    return t
}
function vk(e) {
    let t = "";
    for (let n in e) {
        const o = e[n];
        if (n = wx(n),
        null == o) {
            void 0 !== o && (t += (t.length ? "&" : "") + n);
            continue
        }
        (ox(o) ? o.map(e => e && bx(e)) : [o && bx(o)]).forEach(e => {
            void 0 !== e && (t += (t.length ? "&" : "") + n,
            null != e && (t += "=" + e))
        }
        )
    }
    return t
}
function mk(e) {
    const t = {};
    for (const n in e) {
        const o = e[n];
        void 0 !== o && (t[n] = ox(o) ? o.map(e => null == e ? null : "" + e) : null == o ? o : "" + o)
    }
    return t
}
const gk = Symbol("")
  , yk = Symbol("")
  , bk = Symbol("")
  , wk = Symbol("")
  , _k = Symbol("");
function xk() {
    let e = [];
    return {
        add: function(t) {
            return e.push(t),
            () => {
                const n = e.indexOf(t);
                n > -1 && e.splice(n, 1)
            }
        },
        list: () => e.slice(),
        reset: function() {
            e = []
        }
    }
}
function kk(e, t, n, o, a, r=e => e()) {
    const s = o && (o.enterCallbacks[a] = o.enterCallbacks[a] || []);
    return () => new Promise( (i, l) => {
        const u = e => {
            var r;
            !1 === e ? l(Kx(4, {
                from: n,
                to: t
            })) : e instanceof Error ? l(e) : "string" == typeof (r = e) || r && "object" == typeof r ? l(Kx(2, {
                from: t,
                to: e
            })) : (s && o.enterCallbacks[a] === s && "function" == typeof e && s.push(e),
            i())
        }
          , c = r( () => e.call(o && o.instances[a], t, n, u));
        let d = Promise.resolve(c);
        e.length < 3 && (d = d.then(u)),
        d.catch(e => l(e))
    }
    )
}
function Sk(e, t, n, o, a=e => e()) {
    const r = [];
    for (const s of e)
        for (const e in s.components) {
            let i = s.components[e];
            if ("beforeRouteEnter" === t || s.instances[e])
                if (Q_(i)) {
                    const l = (i.__vccOpts || i)[t];
                    l && r.push(kk(l, n, o, s, e, a))
                } else {
                    let l = i();
                    r.push( () => l.then(r => {
                        if (!r)
                            throw new Error(`Couldn't resolve component "${e}" at "${s.path}"`);
                        const i = (l = r).__esModule || "Module" === l[Symbol.toStringTag] || l.default && Q_(l.default) ? r.default : r;
                        var l;
                        s.mods[e] = r,
                        s.components[e] = i;
                        const u = (i.__vccOpts || i)[t];
                        return u && kk(u, n, o, s, e, a)()
                    }
                    ))
                }
        }
    return r
}
function Ck(e) {
    const t = xa(bk)
      , n = xa(wk)
      , o = ms( () => {
        const n = Nt(e.to);
        return t.resolve(n)
    }
    )
      , a = ms( () => {
        const {matched: e} = o.value
          , {length: t} = e
          , a = e[t - 1]
          , r = n.matched;
        if (!a || !r.length)
            return -1;
        const s = r.findIndex(Ex.bind(null, a));
        if (s > -1)
            return s;
        const i = Tk(e[t - 2]);
        return t > 1 && Tk(a) === i && r[r.length - 1].path !== i ? r.findIndex(Ex.bind(null, e[t - 2])) : s
    }
    )
      , r = ms( () => a.value > -1 && function(e, t) {
        for (const n in t) {
            const o = t[n]
              , a = e[n];
            if ("string" == typeof o) {
                if (o !== a)
                    return !1
            } else if (!ox(a) || a.length !== o.length || o.some( (e, t) => e !== a[t]))
                return !1
        }
        return !0
    }(n.params, o.value.params))
      , s = ms( () => a.value > -1 && a.value === n.matched.length - 1 && Tx(n.params, o.value.params));
    return {
        route: o,
        href: ms( () => o.value.href),
        isActive: r,
        isExactActive: s,
        navigate: function(n={}) {
            if (function(e) {
                if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
                    return;
                if (e.defaultPrevented)
                    return;
                if (void 0 !== e.button && 0 !== e.button)
                    return;
                if (e.currentTarget && e.currentTarget.getAttribute) {
                    const t = e.currentTarget.getAttribute("target");
                    if (/\b_blank\b/i.test(t))
                        return
                }
                e.preventDefault && e.preventDefault();
                return !0
            }(n)) {
                const n = t[Nt(e.replace) ? "replace" : "push"](Nt(e.to)).catch(nx);
                return e.viewTransition && "undefined" != typeof document && "startViewTransition"in document && document.startViewTransition( () => n),
                n
            }
            return Promise.resolve()
        }
    }
}
const Ek = to({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        },
        viewTransition: Boolean
    },
    useLink: Ck,
    setup(e, {slots: t}) {
        const n = bt(Ck(e))
          , {options: o} = xa(bk)
          , a = ms( () => ({
            [Ak(e.activeClass, o.linkActiveClass, "router-link-active")]: n.isActive,
            [Ak(e.exactActiveClass, o.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
        }));
        return () => {
            const o = t.default && (1 === (r = t.default(n)).length ? r[0] : r);
            var r;
            return e.custom ? o : gs("a", {
                "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: a.value
            }, o)
        }
    }
});
function Tk(e) {
    return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const Ak = (e, t, n) => null != e ? e : null != t ? t : n;
function Ok(e, t) {
    if (!e)
        return null;
    const n = e(t);
    return 1 === n.length ? n[0] : n
}
const Mk = to({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
            default: "default"
        },
        route: Object
    },
    compatConfig: {
        MODE: 3
    },
    setup(e, {attrs: t, slots: n}) {
        const o = xa(_k)
          , a = ms( () => e.route || o.value)
          , r = xa(yk, 0)
          , s = ms( () => {
            let e = Nt(r);
            const {matched: t} = a.value;
            let n;
            for (; (n = t[e]) && !n.components; )
                e++;
            return e
        }
        )
          , i = ms( () => a.value.matched[s.value]);
        _a(yk, ms( () => s.value + 1)),
        _a(gk, i),
        _a(_k, a);
        const l = It();
        return Qa( () => [l.value, i.value, e.name], ([e,t,n], [o,a,r]) => {
            t && (t.instances[n] = e,
            a && a !== t && e && e === o && (t.leaveGuards.size || (t.leaveGuards = a.leaveGuards),
            t.updateGuards.size || (t.updateGuards = a.updateGuards))),
            !e || !t || a && Ex(t, a) && o || (t.enterCallbacks[n] || []).forEach(t => t(e))
        }
        , {
            flush: "post"
        }),
        () => {
            const o = a.value
              , r = e.name
              , s = i.value
              , u = s && s.components[r];
            if (!u)
                return Ok(n.default, {
                    Component: u,
                    route: o
                });
            const c = s.props[r]
              , d = c ? !0 === c ? o.params : "function" == typeof c ? c(o) : c : null
              , p = gs(u, ex({}, d, t, {
                onVnodeUnmounted: e => {
                    e.component.isUnmounted && (s.instances[r] = null)
                }
                ,
                ref: l
            }));
            return Ok(n.default, {
                Component: p,
                route: o
            }) || p
        }
    }
});
function Pk() {
    return xa(bk)
}
function Bk(e) {
    return xa(wk)
}
const Ik = {
    class: "flex items-center gap-2"
}
  , Lk = {
    class: ""
}
  , Rk = {
    class: "relative w-full"
}
  , zk = "Campo obrigatrio"
  , Nk = to({
    __name: "CodeModal",
    setup(e) {
        const t = Pk()
          , n = Wg({
            code: Zg({
                required_error: zk
            }).min(3, zk).max(50, "Cdigo deve ter no mximo 50 caracteres")
        })
          , {isSubmitting: o, errors: a, defineField: r, handleSubmit: s, submitCount: i} = Fy({
            validationSchema: Zy(n)
        })
          , [l,u] = r("code")
          , c = It(!1)
          , d = s(async e => {
            var n, o, a, r, s, i;
            try {
                const {data: n} = await b_.post("/affiliate/code", {
                    ...e
                });
                c.value = !0,
                await new Promise(e => setTimeout(e, 1500)),
                S_.success("Cdigo criado com sucesso!"),
                t.go(0)
            } catch (l) {
                let e = "Ocorreu um erro ao criar o cdigo";
                if (l instanceof o_) {
                    e = (null == (r = null == (a = Object.values(null == (o = null == (n = l.response) ? void 0 : n.data) ? void 0 : o.errors)) ? void 0 : a[0]) ? void 0 : r[0]) ?? (null == (i = null == (s = l.response) ? void 0 : s.data) ? void 0 : i.message) ?? e,
                    window.scrollTo({
                        top: 0,
                        behavior: "smooth"
                    })
                }
                S_.error(e)
            }
        }
        )
          , p = pm("code");
        return (e, t) => {
            const n = cm
              , r = um
              , s = im
              , f = Gv;
            return Tr(),
            Ir(f, {
                open: Nt(p),
                "onUpdate:open": t[2] || (t[2] = e => Bt(p) ? p.value = e : null)
            }, {
                heading: En( () => t[3] || (t[3] = [Dr("div", {
                    class: "-m-10 mb-0 select-none relative"
                }, [Dr("img", {
                    src: "https://ik.imagekit.io/azx3nlpdu/AFILIADO.jpg",
                    class: "size-full object-contain sm:rounded-t-lg"
                }), Dr("div", {
                    class: "absolute bg-gradient-to-b from-black/10 via-black/10 from-0% via-85% to-100% to-background size-full z-10 top-0"
                })], -1)])),
                content: En( () => [Dr("div", Ik, [jr(Nt(sm).UserPin, {
                    class: "size-7"
                }), t[4] || (t[4] = Dr("h1", {
                    class: "text-2xl font-medium"
                }, "Criar Cdigo de Afiliado", -1))]), Dr("form", {
                    onSubmit: t[1] || (t[1] = Yi( (...e) => Nt(d) && Nt(d)(...e), ["prevent"])),
                    class: "space-y-3 overflow-hidden"
                }, [Dr("div", Lk, [Dr("div", Rk, [jr(n, Gr({
                    id: "key",
                    type: "text",
                    modelValue: Nt(l),
                    "onUpdate:modelValue": t[0] || (t[0] = e => Bt(l) ? l.value = e : null)
                }, Nt(u), {
                    placeholder: "Digite seu cdigo...",
                    "aria-invalid": Nt(a).code && Nt(i) > 0
                }), null, 16, ["modelValue", "aria-invalid"])]), jr(r, {
                    message: Nt(a).code
                }, null, 8, ["message"])]), jr(s, {
                    type: "submit",
                    loading: Nt(o),
                    success: c.value
                }, {
                    default: En( () => [Nt(o) || c.value ? Ur("", !0) : (Tr(),
                    Ir(Nt(sm).Withdraw, {
                        key: 0,
                        class: "size-5"
                    })), t[5] || (t[5] = Vr(" Criar "))]),
                    _: 1,
                    __: [5]
                }, 8, ["loading", "success"])], 32)]),
                _: 1
            }, 8, ["open"])
        }
    }
})
  , Dk = to({
    __name: "Select",
    props: {
        open: {
            type: Boolean
        },
        defaultOpen: {
            type: Boolean
        },
        defaultValue: {},
        modelValue: {},
        by: {
            type: [String, Function]
        },
        dir: {},
        multiple: {
            type: Boolean
        },
        autocomplete: {},
        disabled: {
            type: Boolean
        },
        name: {},
        required: {
            type: Boolean
        }
    },
    emits: ["update:modelValue", "update:open"],
    setup(e, {emit: t}) {
        const n = Zd(e, t);
        return (e, t) => (Tr(),
        Ir(Nt(Up), Gr({
            "data-slot": "select"
        }, Nt(n)), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , jk = to({
    __name: "SelectGroup",
    props: {
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Ir(Nt(af), Gr({
            "data-slot": "select-group"
        }, t), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , Fk = {
    class: "absolute right-2 flex size-3.5 items-center justify-center"
}
  , $k = to({
    __name: "SelectItem",
    props: {
        value: {},
        disabled: {
            type: Boolean
        },
        textValue: {},
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Ud(Lf(t, "class"));
        return (e, o) => (Tr(),
        Ir(Nt(uf), Gr({
            "data-slot": "select-item"
        }, Nt(n), {
            class: Nt(hv)("focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2", t.class)
        }), {
            default: En( () => [Dr("span", Fk, [jr(Nt(cf), null, {
                default: En( () => [jr(Nt(eh), {
                    class: "size-4"
                })]),
                _: 1
            })]), jr(Nt(df), null, {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            })]),
            _: 3
        }, 16, ["class"]))
    }
})
  , Vk = to({
    __name: "SelectScrollDownButton",
    props: {
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Ud(Lf(t, "class"));
        return (e, o) => (Tr(),
        Ir(Nt(hf), Gr({
            "data-slot": "select-scroll-down-button"
        }, Nt(n), {
            class: Nt(hv)("flex cursor-default items-center justify-center py-1", t.class)
        }), {
            default: En( () => [Wo(e.$slots, "default", {}, () => [jr(Nt(th), {
                class: "size-4"
            })])]),
            _: 3
        }, 16, ["class"]))
    }
})
  , Hk = to({
    __name: "SelectScrollUpButton",
    props: {
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Ud(Lf(t, "class"));
        return (e, o) => (Tr(),
        Ir(Nt(vf), Gr({
            "data-slot": "select-scroll-up-button"
        }, Nt(n), {
            class: Nt(hv)("flex cursor-default items-center justify-center py-1", t.class)
        }), {
            default: En( () => [Wo(e.$slots, "default", {}, () => [jr(Nt(oh), {
                class: "size-4"
            })])]),
            _: 3
        }, 16, ["class"]))
    }
})
  , Uk = to({
    __name: "SelectTrigger",
    props: {
        disabled: {
            type: Boolean
        },
        reference: {},
        asChild: {
            type: Boolean
        },
        as: {},
        class: {},
        size: {
            default: "default"
        }
    },
    setup(e) {
        const t = e
          , n = Ud(Lf(t, "class", "size"));
        return (e, o) => (Tr(),
        Ir(Nt(mf), Gr({
            "data-slot": "select-trigger",
            "data-size": e.size
        }, Nt(n), {
            class: Nt(hv)("border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", t.class)
        }), {
            default: En( () => [Wo(e.$slots, "default"), jr(Nt(rf), {
                "as-child": ""
            }, {
                default: En( () => [jr(Nt(th), {
                    class: "size-4 opacity-50"
                })]),
                _: 1
            })]),
            _: 3
        }, 16, ["data-size", "class"]))
    }
})
  , Zk = to({
    inheritAttrs: !1,
    __name: "SelectContent",
    props: {
        forceMount: {
            type: Boolean
        },
        position: {
            default: "popper"
        },
        bodyLock: {
            type: Boolean
        },
        side: {},
        sideOffset: {},
        align: {},
        alignOffset: {},
        avoidCollisions: {
            type: Boolean
        },
        collisionBoundary: {},
        collisionPadding: {},
        arrowPadding: {},
        sticky: {},
        hideWhenDetached: {
            type: Boolean
        },
        positionStrategy: {},
        updatePositionStrategy: {},
        disableUpdateOnLayoutShift: {
            type: Boolean
        },
        prioritizePosition: {
            type: Boolean
        },
        reference: {},
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = Zd(Lf(n, "class"), o);
        return (e, t) => (Tr(),
        Ir(Nt(pf), null, {
            default: En( () => [jr(Nt(tf), Gr({
                "data-slot": "select-content"
            }, {
                ...Nt(a),
                ...e.$attrs
            }, {
                class: Nt(hv)("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--reka-select-content-available-height) min-w-[8rem] overflow-x-hidden overflow-y-auto rounded-md border shadow-md", "popper" === e.position && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", n.class)
            }), {
                default: En( () => [jr(Nt(Hk)), jr(Nt(gf), {
                    class: K(Nt(hv)("p-1", "popper" === e.position && "h-[var(--reka-select-trigger-height)] w-full min-w-[var(--reka-select-trigger-width)] scroll-my-1"))
                }, {
                    default: En( () => [Wo(e.$slots, "default")]),
                    _: 3
                }, 8, ["class"]), jr(Nt(Vk))]),
                _: 3
            }, 16, ["class"])]),
            _: 3
        }))
    }
})
  , qk = to({
    __name: "KeySelect",
    props: {
        modelValue: {
            default: "cpf"
        },
        modelModifiers: {}
    },
    emits: ["update:modelValue"],
    setup(e) {
        const t = or(e, "modelValue")
          , n = [{
            label: "Telefone",
            value: "phone",
            icon: sm.Phone
        }, {
            label: "Email",
            value: "email",
            icon: sm.Mail
        }, {
            label: "CPF",
            value: "cpf",
            icon: sm.Document
        }, {
            label: "CNPJ",
            value: "cnpj",
            icon: sm.Document
        }, {
            label: "Chave aleatria",
            value: "random",
            icon: sm.Asterisk
        }]
          , o = ms( () => n.find(e => e.value === t.value));
        return (e, a) => {
            const r = Uk
              , s = $k
              , i = jk
              , l = Zk
              , u = Dk;
            return Tr(),
            Ir(u, {
                modelValue: t.value,
                "onUpdate:modelValue": a[0] || (a[0] = e => t.value = e)
            }, {
                default: En( () => [jr(r, null, {
                    default: En( () => {
                        var e;
                        return [(Tr(),
                        Ir(Vo(null == (e = o.value) ? void 0 : e.icon), {
                            class: "w-4 h-4"
                        }))]
                    }
                    ),
                    _: 1
                }), jr(l, null, {
                    default: En( () => [jr(i, null, {
                        default: En( () => [(Tr(),
                        Br(_r, null, qo(n, e => jr(s, {
                            key: e.value,
                            value: e.value,
                            class: "!cursor-pointer"
                        }, {
                            default: En( () => [(Tr(),
                            Ir(Vo(e.icon), {
                                class: "w-4 h-4 mr-2"
                            })), Vr(" " + ne(e.label), 1)]),
                            _: 2
                        }, 1032, ["value"])), 64))]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            }, 8, ["modelValue"])
        }
    }
});
function Wk(e) {
    return null !== e && "object" == typeof e && "constructor"in e && e.constructor === Object
}
function Gk(e, t) {
    void 0 === e && (e = {}),
    void 0 === t && (t = {});
    const n = ["__proto__", "constructor", "prototype"];
    Object.keys(t).filter(e => n.indexOf(e) < 0).forEach(n => {
        void 0 === e[n] ? e[n] = t[n] : Wk(t[n]) && Wk(e[n]) && Object.keys(t[n]).length > 0 && Gk(e[n], t[n])
    }
    )
}
const Kk = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
        blur() {},
        nodeName: ""
    },
    querySelector: () => null,
    querySelectorAll: () => [],
    getElementById: () => null,
    createEvent: () => ({
        initEvent() {}
    }),
    createElement: () => ({
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {},
        getElementsByTagName: () => []
    }),
    createElementNS: () => ({}),
    importNode: () => null,
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};
function Yk() {
    const e = "undefined" != typeof document ? document : {};
    return Gk(e, Kk),
    e
}
const Xk = {
    document: Kk,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {}
    },
    CustomEvent: function() {
        return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle: () => ({
        getPropertyValue: () => ""
    }),
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia: () => ({}),
    requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(),
    null) : setTimeout(e, 0),
    cancelAnimationFrame(e) {
        "undefined" != typeof setTimeout && clearTimeout(e)
    }
};
function Jk() {
    const e = "undefined" != typeof window ? window : {};
    return Gk(e, Xk),
    e
}
function Qk(e, t) {
    return void 0 === t && (t = 0),
    setTimeout(e, t)
}
function eS() {
    return Date.now()
}
function tS(e, t) {
    void 0 === t && (t = "x");
    const n = Jk();
    let o, a, r;
    const s = function(e) {
        const t = Jk();
        let n;
        return t.getComputedStyle && (n = t.getComputedStyle(e, null)),
        !n && e.currentStyle && (n = e.currentStyle),
        n || (n = e.style),
        n
    }(e);
    return n.WebKitCSSMatrix ? (a = s.transform || s.webkitTransform,
    a.split(",").length > 6 && (a = a.split(", ").map(e => e.replace(",", ".")).join(", ")),
    r = new n.WebKitCSSMatrix("none" === a ? "" : a)) : (r = s.MozTransform || s.OTransform || s.MsTransform || s.msTransform || s.transform || s.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
    o = r.toString().split(",")),
    "x" === t && (a = n.WebKitCSSMatrix ? r.m41 : 16 === o.length ? parseFloat(o[12]) : parseFloat(o[4])),
    "y" === t && (a = n.WebKitCSSMatrix ? r.m42 : 16 === o.length ? parseFloat(o[13]) : parseFloat(o[5])),
    a || 0
}
function nS(e) {
    return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
}
function oS(e) {
    return "undefined" != typeof window && void 0 !== window.HTMLElement ? e instanceof HTMLElement : e && (1 === e.nodeType || 11 === e.nodeType)
}
function aS() {
    const e = Object(arguments.length <= 0 ? void 0 : arguments[0])
      , t = ["__proto__", "constructor", "prototype"];
    for (let n = 1; n < arguments.length; n += 1) {
        const o = n < 0 || arguments.length <= n ? void 0 : arguments[n];
        if (null != o && !oS(o)) {
            const n = Object.keys(Object(o)).filter(e => t.indexOf(e) < 0);
            for (let t = 0, a = n.length; t < a; t += 1) {
                const a = n[t]
                  , r = Object.getOwnPropertyDescriptor(o, a);
                void 0 !== r && r.enumerable && (nS(e[a]) && nS(o[a]) ? o[a].__swiper__ ? e[a] = o[a] : aS(e[a], o[a]) : !nS(e[a]) && nS(o[a]) ? (e[a] = {},
                o[a].__swiper__ ? e[a] = o[a] : aS(e[a], o[a])) : e[a] = o[a])
            }
        }
    }
    return e
}
function rS(e, t, n) {
    e.style.setProperty(t, n)
}
function sS(e) {
    let {swiper: t, targetPosition: n, side: o} = e;
    const a = Jk()
      , r = -t.translate;
    let s, i = null;
    const l = t.params.speed;
    t.wrapperEl.style.scrollSnapType = "none",
    a.cancelAnimationFrame(t.cssModeFrameID);
    const u = n > r ? "next" : "prev"
      , c = (e, t) => "next" === u && e >= t || "prev" === u && e <= t
      , d = () => {
        s = (new Date).getTime(),
        null === i && (i = s);
        const e = Math.max(Math.min((s - i) / l, 1), 0)
          , u = .5 - Math.cos(e * Math.PI) / 2;
        let p = r + u * (n - r);
        if (c(p, n) && (p = n),
        t.wrapperEl.scrollTo({
            [o]: p
        }),
        c(p, n))
            return t.wrapperEl.style.overflow = "hidden",
            t.wrapperEl.style.scrollSnapType = "",
            setTimeout( () => {
                t.wrapperEl.style.overflow = "",
                t.wrapperEl.scrollTo({
                    [o]: p
                })
            }
            ),
            void a.cancelAnimationFrame(t.cssModeFrameID);
        t.cssModeFrameID = a.requestAnimationFrame(d)
    }
    ;
    d()
}
function iS(e, t) {
    void 0 === t && (t = "");
    const n = Jk()
      , o = [...e.children];
    return n.HTMLSlotElement && e instanceof HTMLSlotElement && o.push(...e.assignedElements()),
    t ? o.filter(e => e.matches(t)) : o
}
function lS(e) {
    try {
        return
    } catch (t) {}
}
function uS(e, t) {
    void 0 === t && (t = []);
    const n = document.createElement(e);
    return n.classList.add(...Array.isArray(t) ? t : function(e) {
        return void 0 === e && (e = ""),
        e.trim().split(" ").filter(e => !!e.trim())
    }(t)),
    n
}
function cS(e, t) {
    return Jk().getComputedStyle(e, null).getPropertyValue(t)
}
function dS(e) {
    let t, n = e;
    if (n) {
        for (t = 0; null !== (n = n.previousSibling); )
            1 === n.nodeType && (t += 1);
        return t
    }
}
function pS(e, t) {
    const n = [];
    let o = e.parentElement;
    for (; o; )
        t ? o.matches(t) && n.push(o) : n.push(o),
        o = o.parentElement;
    return n
}
function fS(e, t, n) {
    const o = Jk();
    return e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(o.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(o.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom"))
}
function hS(e) {
    return (Array.isArray(e) ? e : [e]).filter(e => !!e)
}
function vS(e, t) {
    void 0 === t && (t = ""),
    "undefined" != typeof trustedTypes ? e.innerHTML = trustedTypes.createPolicy("html", {
        createHTML: e => e
    }).createHTML(t) : e.innerHTML = t
}
let mS, gS, yS;
function bS() {
    return mS || (mS = function() {
        const e = Jk()
          , t = Yk();
        return {
            smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior"in t.documentElement.style,
            touch: !!("ontouchstart"in e || e.DocumentTouch && t instanceof e.DocumentTouch)
        }
    }()),
    mS
}
function wS(e) {
    return void 0 === e && (e = {}),
    gS || (gS = function(e) {
        let {userAgent: t} = void 0 === e ? {} : e;
        const n = bS()
          , o = Jk()
          , a = o.navigator.platform
          , r = t || o.navigator.userAgent
          , s = {
            ios: !1,
            android: !1
        }
          , i = o.screen.width
          , l = o.screen.height
          , u = r.match(/(Android);?[\s\/]+([\d.]+)?/);
        let c = r.match(/(iPad).*OS\s([\d_]+)/);
        const d = r.match(/(iPod)(.*OS\s([\d_]+))?/)
          , p = !c && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
          , f = "Win32" === a;
        let h = "MacIntel" === a;
        return !c && h && n.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${i}x${l}`) >= 0 && (c = r.match(/(Version)\/([\d.]+)/),
        c || (c = [0, 1, "13_0_0"]),
        h = !1),
        u && !f && (s.os = "android",
        s.android = !0),
        (c || p || d) && (s.os = "ios",
        s.ios = !0),
        s
    }(e)),
    gS
}
function _S() {
    return yS || (yS = function() {
        const e = Jk()
          , t = wS();
        let n = !1;
        function o() {
            const t = e.navigator.userAgent.toLowerCase();
            return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
        }
        if (o()) {
            const t = String(e.navigator.userAgent);
            if (t.includes("Version/")) {
                const [e,o] = t.split("Version/")[1].split(" ")[0].split(".").map(e => Number(e));
                n = e < 16 || 16 === e && o < 2
            }
        }
        const a = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
          , r = o();
        return {
            isSafari: n || r,
            needPerspectiveFix: n,
            need3dFix: r || a && t.ios,
            isWebView: a
        }
    }()),
    yS
}
const xS = (e, t, n) => {
    t && !e.classList.contains(n) ? e.classList.add(n) : !t && e.classList.contains(n) && e.classList.remove(n)
}
;
const kS = (e, t, n) => {
    t && !e.classList.contains(n) ? e.classList.add(n) : !t && e.classList.contains(n) && e.classList.remove(n)
}
;
const SS = (e, t) => {
    if (!e || e.destroyed || !e.params)
        return;
    const n = t.closest(e.isElement ? "swiper-slide" : `.${e.params.slideClass}`);
    if (n) {
        let t = n.querySelector(`.${e.params.lazyPreloaderClass}`);
        !t && e.isElement && (n.shadowRoot ? t = n.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`) : requestAnimationFrame( () => {
            n.shadowRoot && (t = n.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`),
            t && t.remove())
        }
        )),
        t && t.remove()
    }
}
  , CS = (e, t) => {
    if (!e.slides[t])
        return;
    const n = e.slides[t].querySelector('[loading="lazy"]');
    n && n.removeAttribute("loading")
}
  , ES = e => {
    if (!e || e.destroyed || !e.params)
        return;
    let t = e.params.lazyPreloadPrevNext;
    const n = e.slides.length;
    if (!n || !t || t < 0)
        return;
    t = Math.min(t, n);
    const o = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView)
      , a = e.activeIndex;
    if (e.params.grid && e.params.grid.rows > 1) {
        const n = a
          , r = [n - t];
        return r.push(...Array.from({
            length: t
        }).map( (e, t) => n + o + t)),
        void e.slides.forEach( (t, n) => {
            r.includes(t.column) && CS(e, n)
        }
        )
    }
    const r = a + o - 1;
    if (e.params.rewind || e.params.loop)
        for (let s = a - t; s <= r + t; s += 1) {
            const t = (s % n + n) % n;
            (t < a || t > r) && CS(e, t)
        }
    else
        for (let s = Math.max(a - t, 0); s <= Math.min(r + t, n - 1); s += 1)
            s !== a && (s > r || s < a) && CS(e, s)
}
;
var TS = {
    getTranslate: function(e) {
        void 0 === e && (e = this.isHorizontal() ? "x" : "y");
        const {params: t, rtlTranslate: n, translate: o, wrapperEl: a} = this;
        if (t.virtualTranslate)
            return n ? -o : o;
        if (t.cssMode)
            return o;
        let r = tS(a, e);
        return r += this.cssOverflowAdjustment(),
        n && (r = -r),
        r || 0
    },
    setTranslate: function(e, t) {
        const n = this
          , {rtlTranslate: o, params: a, wrapperEl: r, progress: s} = n;
        let i, l = 0, u = 0;
        n.isHorizontal() ? l = o ? -e : e : u = e,
        a.roundLengths && (l = Math.floor(l),
        u = Math.floor(u)),
        n.previousTranslate = n.translate,
        n.translate = n.isHorizontal() ? l : u,
        a.cssMode ? r[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -l : -u : a.virtualTranslate || (n.isHorizontal() ? l -= n.cssOverflowAdjustment() : u -= n.cssOverflowAdjustment(),
        r.style.transform = `translate3d(${l}px, ${u}px, 0px)`);
        const c = n.maxTranslate() - n.minTranslate();
        i = 0 === c ? 0 : (e - n.minTranslate()) / c,
        i !== s && n.updateProgress(e),
        n.emit("setTranslate", n.translate, t)
    },
    minTranslate: function() {
        return -this.snapGrid[0]
    },
    maxTranslate: function() {
        return -this.snapGrid[this.snapGrid.length - 1]
    },
    translateTo: function(e, t, n, o, a) {
        void 0 === e && (e = 0),
        void 0 === t && (t = this.params.speed),
        void 0 === n && (n = !0),
        void 0 === o && (o = !0);
        const r = this
          , {params: s, wrapperEl: i} = r;
        if (r.animating && s.preventInteractionOnTransition)
            return !1;
        const l = r.minTranslate()
          , u = r.maxTranslate();
        let c;
        if (c = o && e > l ? l : o && e < u ? u : e,
        r.updateProgress(c),
        s.cssMode) {
            const e = r.isHorizontal();
            if (0 === t)
                i[e ? "scrollLeft" : "scrollTop"] = -c;
            else {
                if (!r.support.smoothScroll)
                    return sS({
                        swiper: r,
                        targetPosition: -c,
                        side: e ? "left" : "top"
                    }),
                    !0;
                i.scrollTo({
                    [e ? "left" : "top"]: -c,
                    behavior: "smooth"
                })
            }
            return !0
        }
        return 0 === t ? (r.setTransition(0),
        r.setTranslate(c),
        n && (r.emit("beforeTransitionStart", t, a),
        r.emit("transitionEnd"))) : (r.setTransition(t),
        r.setTranslate(c),
        n && (r.emit("beforeTransitionStart", t, a),
        r.emit("transitionStart")),
        r.animating || (r.animating = !0,
        r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function(e) {
            r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd),
            r.onTranslateToWrapperTransitionEnd = null,
            delete r.onTranslateToWrapperTransitionEnd,
            r.animating = !1,
            n && r.emit("transitionEnd"))
        }
        ),
        r.wrapperEl.addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd))),
        !0
    }
};
function AS(e) {
    let {swiper: t, runCallbacks: n, direction: o, step: a} = e;
    const {activeIndex: r, previousIndex: s} = t;
    let i = o;
    i || (i = r > s ? "next" : r < s ? "prev" : "reset"),
    t.emit(`transition${a}`),
    n && "reset" === i ? t.emit(`slideResetTransition${a}`) : n && r !== s && (t.emit(`slideChangeTransition${a}`),
    "next" === i ? t.emit(`slideNextTransition${a}`) : t.emit(`slidePrevTransition${a}`))
}
var OS = {
    slideTo: function(e, t, n, o, a) {
        void 0 === e && (e = 0),
        void 0 === n && (n = !0),
        "string" == typeof e && (e = parseInt(e, 10));
        const r = this;
        let s = e;
        s < 0 && (s = 0);
        const {params: i, snapGrid: l, slidesGrid: u, previousIndex: c, activeIndex: d, rtlTranslate: p, wrapperEl: f, enabled: h} = r;
        if (!h && !o && !a || r.destroyed || r.animating && i.preventInteractionOnTransition)
            return !1;
        void 0 === t && (t = r.params.speed);
        const v = Math.min(r.params.slidesPerGroupSkip, s);
        let m = v + Math.floor((s - v) / r.params.slidesPerGroup);
        m >= l.length && (m = l.length - 1);
        const g = -l[m];
        if (i.normalizeSlideIndex)
            for (let _ = 0; _ < u.length; _ += 1) {
                const e = -Math.floor(100 * g)
                  , t = Math.floor(100 * u[_])
                  , n = Math.floor(100 * u[_ + 1]);
                void 0 !== u[_ + 1] ? e >= t && e < n - (n - t) / 2 ? s = _ : e >= t && e < n && (s = _ + 1) : e >= t && (s = _)
            }
        if (r.initialized && s !== d) {
            if (!r.allowSlideNext && (p ? g > r.translate && g > r.minTranslate() : g < r.translate && g < r.minTranslate()))
                return !1;
            if (!r.allowSlidePrev && g > r.translate && g > r.maxTranslate() && (d || 0) !== s)
                return !1
        }
        let y;
        s !== (c || 0) && n && r.emit("beforeSlideChangeStart"),
        r.updateProgress(g),
        y = s > d ? "next" : s < d ? "prev" : "reset";
        const b = r.virtual && r.params.virtual.enabled;
        if (!(b && a) && (p && -g === r.translate || !p && g === r.translate))
            return r.updateActiveIndex(s),
            i.autoHeight && r.updateAutoHeight(),
            r.updateSlidesClasses(),
            "slide" !== i.effect && r.setTranslate(g),
            "reset" !== y && (r.transitionStart(n, y),
            r.transitionEnd(n, y)),
            !1;
        if (i.cssMode) {
            const e = r.isHorizontal()
              , n = p ? g : -g;
            if (0 === t)
                b && (r.wrapperEl.style.scrollSnapType = "none",
                r._immediateVirtual = !0),
                b && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0,
                requestAnimationFrame( () => {
                    f[e ? "scrollLeft" : "scrollTop"] = n
                }
                )) : f[e ? "scrollLeft" : "scrollTop"] = n,
                b && requestAnimationFrame( () => {
                    r.wrapperEl.style.scrollSnapType = "",
                    r._immediateVirtual = !1
                }
                );
            else {
                if (!r.support.smoothScroll)
                    return sS({
                        swiper: r,
                        targetPosition: n,
                        side: e ? "left" : "top"
                    }),
                    !0;
                f.scrollTo({
                    [e ? "left" : "top"]: n,
                    behavior: "smooth"
                })
            }
            return !0
        }
        const w = _S().isSafari;
        return b && !a && w && r.isElement && r.virtual.update(!1, !1, s),
        r.setTransition(t),
        r.setTranslate(g),
        r.updateActiveIndex(s),
        r.updateSlidesClasses(),
        r.emit("beforeTransitionStart", t, o),
        r.transitionStart(n, y),
        0 === t ? r.transitionEnd(n, y) : r.animating || (r.animating = !0,
        r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function(e) {
            r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd),
            r.onSlideToWrapperTransitionEnd = null,
            delete r.onSlideToWrapperTransitionEnd,
            r.transitionEnd(n, y))
        }
        ),
        r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)),
        !0
    },
    slideToLoop: function(e, t, n, o) {
        if (void 0 === e && (e = 0),
        void 0 === n && (n = !0),
        "string" == typeof e) {
            e = parseInt(e, 10)
        }
        const a = this;
        if (a.destroyed)
            return;
        void 0 === t && (t = a.params.speed);
        const r = a.grid && a.params.grid && a.params.grid.rows > 1;
        let s = e;
        if (a.params.loop)
            if (a.virtual && a.params.virtual.enabled)
                s += a.virtual.slidesBefore;
            else {
                let e;
                if (r) {
                    const t = s * a.params.grid.rows;
                    e = a.slides.find(e => 1 * e.getAttribute("data-swiper-slide-index") === t).column
                } else
                    e = a.getSlideIndexByData(s);
                const t = r ? Math.ceil(a.slides.length / a.params.grid.rows) : a.slides.length
                  , {centeredSlides: n} = a.params;
                let i = a.params.slidesPerView;
                "auto" === i ? i = a.slidesPerViewDynamic() : (i = Math.ceil(parseFloat(a.params.slidesPerView, 10)),
                n && i % 2 == 0 && (i += 1));
                let l = t - e < i;
                if (n && (l = l || e < Math.ceil(i / 2)),
                o && n && "auto" !== a.params.slidesPerView && !r && (l = !1),
                l) {
                    const o = n ? e < a.activeIndex ? "prev" : "next" : e - a.activeIndex - 1 < a.params.slidesPerView ? "next" : "prev";
                    a.loopFix({
                        direction: o,
                        slideTo: !0,
                        activeSlideIndex: "next" === o ? e + 1 : e - t + 1,
                        slideRealIndex: "next" === o ? a.realIndex : void 0
                    })
                }
                if (r) {
                    const e = s * a.params.grid.rows;
                    s = a.slides.find(t => 1 * t.getAttribute("data-swiper-slide-index") === e).column
                } else
                    s = a.getSlideIndexByData(s)
            }
        return requestAnimationFrame( () => {
            a.slideTo(s, t, n, o)
        }
        ),
        a
    },
    slideNext: function(e, t, n) {
        void 0 === t && (t = !0);
        const o = this
          , {enabled: a, params: r, animating: s} = o;
        if (!a || o.destroyed)
            return o;
        void 0 === e && (e = o.params.speed);
        let i = r.slidesPerGroup;
        "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (i = Math.max(o.slidesPerViewDynamic("current", !0), 1));
        const l = o.activeIndex < r.slidesPerGroupSkip ? 1 : i
          , u = o.virtual && r.virtual.enabled;
        if (r.loop) {
            if (s && !u && r.loopPreventsSliding)
                return !1;
            if (o.loopFix({
                direction: "next"
            }),
            o._clientLeft = o.wrapperEl.clientLeft,
            o.activeIndex === o.slides.length - 1 && r.cssMode)
                return requestAnimationFrame( () => {
                    o.slideTo(o.activeIndex + l, e, t, n)
                }
                ),
                !0
        }
        return r.rewind && o.isEnd ? o.slideTo(0, e, t, n) : o.slideTo(o.activeIndex + l, e, t, n)
    },
    slidePrev: function(e, t, n) {
        void 0 === t && (t = !0);
        const o = this
          , {params: a, snapGrid: r, slidesGrid: s, rtlTranslate: i, enabled: l, animating: u} = o;
        if (!l || o.destroyed)
            return o;
        void 0 === e && (e = o.params.speed);
        const c = o.virtual && a.virtual.enabled;
        if (a.loop) {
            if (u && !c && a.loopPreventsSliding)
                return !1;
            o.loopFix({
                direction: "prev"
            }),
            o._clientLeft = o.wrapperEl.clientLeft
        }
        function d(e) {
            return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
        }
        const p = d(i ? o.translate : -o.translate)
          , f = r.map(e => d(e))
          , h = a.freeMode && a.freeMode.enabled;
        let v = r[f.indexOf(p) - 1];
        if (void 0 === v && (a.cssMode || h)) {
            let e;
            r.forEach( (t, n) => {
                p >= t && (e = n)
            }
            ),
            void 0 !== e && (v = h ? r[e] : r[e > 0 ? e - 1 : e])
        }
        let m = 0;
        if (void 0 !== v && (m = s.indexOf(v),
        m < 0 && (m = o.activeIndex - 1),
        "auto" === a.slidesPerView && 1 === a.slidesPerGroup && a.slidesPerGroupAuto && (m = m - o.slidesPerViewDynamic("previous", !0) + 1,
        m = Math.max(m, 0))),
        a.rewind && o.isBeginning) {
            const a = o.params.virtual && o.params.virtual.enabled && o.virtual ? o.virtual.slides.length - 1 : o.slides.length - 1;
            return o.slideTo(a, e, t, n)
        }
        return a.loop && 0 === o.activeIndex && a.cssMode ? (requestAnimationFrame( () => {
            o.slideTo(m, e, t, n)
        }
        ),
        !0) : o.slideTo(m, e, t, n)
    },
    slideReset: function(e, t, n) {
        void 0 === t && (t = !0);
        const o = this;
        if (!o.destroyed)
            return void 0 === e && (e = o.params.speed),
            o.slideTo(o.activeIndex, e, t, n)
    },
    slideToClosest: function(e, t, n, o) {
        void 0 === t && (t = !0),
        void 0 === o && (o = .5);
        const a = this;
        if (a.destroyed)
            return;
        void 0 === e && (e = a.params.speed);
        let r = a.activeIndex;
        const s = Math.min(a.params.slidesPerGroupSkip, r)
          , i = s + Math.floor((r - s) / a.params.slidesPerGroup)
          , l = a.rtlTranslate ? a.translate : -a.translate;
        if (l >= a.snapGrid[i]) {
            const e = a.snapGrid[i];
            l - e > (a.snapGrid[i + 1] - e) * o && (r += a.params.slidesPerGroup)
        } else {
            const e = a.snapGrid[i - 1];
            l - e <= (a.snapGrid[i] - e) * o && (r -= a.params.slidesPerGroup)
        }
        return r = Math.max(r, 0),
        r = Math.min(r, a.slidesGrid.length - 1),
        a.slideTo(r, e, t, n)
    },
    slideToClickedSlide: function() {
        const e = this;
        if (e.destroyed)
            return;
        const {params: t, slidesEl: n} = e
          , o = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
        let a, r = e.getSlideIndexWhenGrid(e.clickedIndex);
        const s = e.isElement ? "swiper-slide" : `.${t.slideClass}`
          , i = e.grid && e.params.grid && e.params.grid.rows > 1;
        if (t.loop) {
            if (e.animating)
                return;
            a = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10),
            t.centeredSlides ? e.slideToLoop(a) : r > (i ? (e.slides.length - o) / 2 - (e.params.grid.rows - 1) : e.slides.length - o) ? (e.loopFix(),
            r = e.getSlideIndex(iS(n, `${s}[data-swiper-slide-index="${a}"]`)[0]),
            Qk( () => {
                e.slideTo(r)
            }
            )) : e.slideTo(r)
        } else
            e.slideTo(r)
    }
};
function MS(e, t, n) {
    const o = Jk()
      , {params: a} = e
      , r = a.edgeSwipeDetection
      , s = a.edgeSwipeThreshold;
    return !r || !(n <= s || n >= o.innerWidth - s) || "prevent" === r && (t.preventDefault(),
    !0)
}
function PS(e) {
    const t = this
      , n = Yk();
    let o = e;
    o.originalEvent && (o = o.originalEvent);
    const a = t.touchEventsData;
    if ("pointerdown" === o.type) {
        if (null !== a.pointerId && a.pointerId !== o.pointerId)
            return;
        a.pointerId = o.pointerId
    } else
        "touchstart" === o.type && 1 === o.targetTouches.length && (a.touchId = o.targetTouches[0].identifier);
    if ("touchstart" === o.type)
        return void MS(t, o, o.targetTouches[0].pageX);
    const {params: r, touches: s, enabled: i} = t;
    if (!i)
        return;
    if (!r.simulateTouch && "mouse" === o.pointerType)
        return;
    if (t.animating && r.preventInteractionOnTransition)
        return;
    !t.animating && r.cssMode && r.loop && t.loopFix();
    let l = o.target;
    if ("wrapper" === r.touchEventsTarget && !function(e, t) {
        const n = Jk();
        let o = t.contains(e);
        !o && n.HTMLSlotElement && t instanceof HTMLSlotElement && (o = [...t.assignedElements()].includes(e),
        o || (o = function(e, t) {
            const n = [t];
            for (; n.length > 0; ) {
                const t = n.shift();
                if (e === t)
                    return !0;
                n.push(...t.children, ...t.shadowRoot ? t.shadowRoot.children : [], ...t.assignedElements ? t.assignedElements() : [])
            }
        }(e, t)));
        return o
    }(l, t.wrapperEl))
        return;
    if ("which"in o && 3 === o.which)
        return;
    if ("button"in o && o.button > 0)
        return;
    if (a.isTouched && a.isMoved)
        return;
    const u = !!r.noSwipingClass && "" !== r.noSwipingClass
      , c = o.composedPath ? o.composedPath() : o.path;
    u && o.target && o.target.shadowRoot && c && (l = c[0]);
    const d = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`
      , p = !(!o.target || !o.target.shadowRoot);
    if (r.noSwiping && (p ? function(e, t) {
        return void 0 === t && (t = this),
        function t(n) {
            if (!n || n === Yk() || n === Jk())
                return null;
            n.assignedSlot && (n = n.assignedSlot);
            const o = n.closest(e);
            return o || n.getRootNode ? o || t(n.getRootNode().host) : null
        }(t)
    }(d, l) : l.closest(d)))
        return void (t.allowClick = !0);
    if (r.swipeHandler && !l.closest(r.swipeHandler))
        return;
    s.currentX = o.pageX,
    s.currentY = o.pageY;
    const f = s.currentX
      , h = s.currentY;
    if (!MS(t, o, f))
        return;
    Object.assign(a, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0
    }),
    s.startX = f,
    s.startY = h,
    a.touchStartTime = eS(),
    t.allowClick = !0,
    t.updateSize(),
    t.swipeDirection = void 0,
    r.threshold > 0 && (a.allowThresholdMove = !1);
    let v = !0;
    l.matches(a.focusableElements) && (v = !1,
    "SELECT" === l.nodeName && (a.isTouched = !1)),
    n.activeElement && n.activeElement.matches(a.focusableElements) && n.activeElement !== l && ("mouse" === o.pointerType || "mouse" !== o.pointerType && !l.matches(a.focusableElements)) && n.activeElement.blur();
    const m = v && t.allowTouchMove && r.touchStartPreventDefault;
    !r.touchStartForcePreventDefault && !m || l.isContentEditable || o.preventDefault(),
    r.freeMode && r.freeMode.enabled && t.freeMode && t.animating && !r.cssMode && t.freeMode.onTouchStart(),
    t.emit("touchStart", o)
}
function BS(e) {
    const t = Yk()
      , n = this
      , o = n.touchEventsData
      , {params: a, touches: r, rtlTranslate: s, enabled: i} = n;
    if (!i)
        return;
    if (!a.simulateTouch && "mouse" === e.pointerType)
        return;
    let l, u = e;
    if (u.originalEvent && (u = u.originalEvent),
    "pointermove" === u.type) {
        if (null !== o.touchId)
            return;
        if (u.pointerId !== o.pointerId)
            return
    }
    if ("touchmove" === u.type) {
        if (l = [...u.changedTouches].find(e => e.identifier === o.touchId),
        !l || l.identifier !== o.touchId)
            return
    } else
        l = u;
    if (!o.isTouched)
        return void (o.startMoving && o.isScrolling && n.emit("touchMoveOpposite", u));
    const c = l.pageX
      , d = l.pageY;
    if (u.preventedByNestedSwiper)
        return r.startX = c,
        void (r.startY = d);
    if (!n.allowTouchMove)
        return u.target.matches(o.focusableElements) || (n.allowClick = !1),
        void (o.isTouched && (Object.assign(r, {
            startX: c,
            startY: d,
            currentX: c,
            currentY: d
        }),
        o.touchStartTime = eS()));
    if (a.touchReleaseOnEdges && !a.loop)
        if (n.isVertical()) {
            if (d < r.startY && n.translate <= n.maxTranslate() || d > r.startY && n.translate >= n.minTranslate())
                return o.isTouched = !1,
                void (o.isMoved = !1)
        } else {
            if (s && (c > r.startX && -n.translate <= n.maxTranslate() || c < r.startX && -n.translate >= n.minTranslate()))
                return;
            if (!s && (c < r.startX && n.translate <= n.maxTranslate() || c > r.startX && n.translate >= n.minTranslate()))
                return
        }
    if (t.activeElement && t.activeElement.matches(o.focusableElements) && t.activeElement !== u.target && "mouse" !== u.pointerType && t.activeElement.blur(),
    t.activeElement && u.target === t.activeElement && u.target.matches(o.focusableElements))
        return o.isMoved = !0,
        void (n.allowClick = !1);
    o.allowTouchCallbacks && n.emit("touchMove", u),
    r.previousX = r.currentX,
    r.previousY = r.currentY,
    r.currentX = c,
    r.currentY = d;
    const p = r.currentX - r.startX
      , f = r.currentY - r.startY;
    if (n.params.threshold && Math.sqrt(p ** 2 + f ** 2) < n.params.threshold)
        return;
    if (void 0 === o.isScrolling) {
        let e;
        n.isHorizontal() && r.currentY === r.startY || n.isVertical() && r.currentX === r.startX ? o.isScrolling = !1 : p * p + f * f >= 25 && (e = 180 * Math.atan2(Math.abs(f), Math.abs(p)) / Math.PI,
        o.isScrolling = n.isHorizontal() ? e > a.touchAngle : 90 - e > a.touchAngle)
    }
    if (o.isScrolling && n.emit("touchMoveOpposite", u),
    void 0 === o.startMoving && (r.currentX === r.startX && r.currentY === r.startY || (o.startMoving = !0)),
    o.isScrolling || "touchmove" === u.type && o.preventTouchMoveFromPointerMove)
        return void (o.isTouched = !1);
    if (!o.startMoving)
        return;
    n.allowClick = !1,
    !a.cssMode && u.cancelable && u.preventDefault(),
    a.touchMoveStopPropagation && !a.nested && u.stopPropagation();
    let h = n.isHorizontal() ? p : f
      , v = n.isHorizontal() ? r.currentX - r.previousX : r.currentY - r.previousY;
    a.oneWayMovement && (h = Math.abs(h) * (s ? 1 : -1),
    v = Math.abs(v) * (s ? 1 : -1)),
    r.diff = h,
    h *= a.touchRatio,
    s && (h = -h,
    v = -v);
    const m = n.touchesDirection;
    n.swipeDirection = h > 0 ? "prev" : "next",
    n.touchesDirection = v > 0 ? "prev" : "next";
    const g = n.params.loop && !a.cssMode
      , y = "next" === n.touchesDirection && n.allowSlideNext || "prev" === n.touchesDirection && n.allowSlidePrev;
    if (!o.isMoved) {
        if (g && y && n.loopFix({
            direction: n.swipeDirection
        }),
        o.startTranslate = n.getTranslate(),
        n.setTransition(0),
        n.animating) {
            const e = new window.CustomEvent("transitionend",{
                bubbles: !0,
                cancelable: !0,
                detail: {
                    bySwiperTouchMove: !0
                }
            });
            n.wrapperEl.dispatchEvent(e)
        }
        o.allowMomentumBounce = !1,
        !a.grabCursor || !0 !== n.allowSlideNext && !0 !== n.allowSlidePrev || n.setGrabCursor(!0),
        n.emit("sliderFirstMove", u)
    }
    if ((new Date).getTime(),
    !1 !== a._loopSwapReset && o.isMoved && o.allowThresholdMove && m !== n.touchesDirection && g && y && Math.abs(h) >= 1)
        return Object.assign(r, {
            startX: c,
            startY: d,
            currentX: c,
            currentY: d,
            startTranslate: o.currentTranslate
        }),
        o.loopSwapReset = !0,
        void (o.startTranslate = o.currentTranslate);
    n.emit("sliderMove", u),
    o.isMoved = !0,
    o.currentTranslate = h + o.startTranslate;
    let b = !0
      , w = a.resistanceRatio;
    if (a.touchReleaseOnEdges && (w = 0),
    h > 0 ? (g && y && o.allowThresholdMove && o.currentTranslate > (a.centeredSlides ? n.minTranslate() - n.slidesSizesGrid[n.activeIndex + 1] - ("auto" !== a.slidesPerView && n.slides.length - a.slidesPerView >= 2 ? n.slidesSizesGrid[n.activeIndex + 1] + n.params.spaceBetween : 0) - n.params.spaceBetween : n.minTranslate()) && n.loopFix({
        direction: "prev",
        setTranslate: !0,
        activeSlideIndex: 0
    }),
    o.currentTranslate > n.minTranslate() && (b = !1,
    a.resistance && (o.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + o.startTranslate + h) ** w))) : h < 0 && (g && y && o.allowThresholdMove && o.currentTranslate < (a.centeredSlides ? n.maxTranslate() + n.slidesSizesGrid[n.slidesSizesGrid.length - 1] + n.params.spaceBetween + ("auto" !== a.slidesPerView && n.slides.length - a.slidesPerView >= 2 ? n.slidesSizesGrid[n.slidesSizesGrid.length - 1] + n.params.spaceBetween : 0) : n.maxTranslate()) && n.loopFix({
        direction: "next",
        setTranslate: !0,
        activeSlideIndex: n.slides.length - ("auto" === a.slidesPerView ? n.slidesPerViewDynamic() : Math.ceil(parseFloat(a.slidesPerView, 10)))
    }),
    o.currentTranslate < n.maxTranslate() && (b = !1,
    a.resistance && (o.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - o.startTranslate - h) ** w))),
    b && (u.preventedByNestedSwiper = !0),
    !n.allowSlideNext && "next" === n.swipeDirection && o.currentTranslate < o.startTranslate && (o.currentTranslate = o.startTranslate),
    !n.allowSlidePrev && "prev" === n.swipeDirection && o.currentTranslate > o.startTranslate && (o.currentTranslate = o.startTranslate),
    n.allowSlidePrev || n.allowSlideNext || (o.currentTranslate = o.startTranslate),
    a.threshold > 0) {
        if (!(Math.abs(h) > a.threshold || o.allowThresholdMove))
            return void (o.currentTranslate = o.startTranslate);
        if (!o.allowThresholdMove)
            return o.allowThresholdMove = !0,
            r.startX = r.currentX,
            r.startY = r.currentY,
            o.currentTranslate = o.startTranslate,
            void (r.diff = n.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY)
    }
    a.followFinger && !a.cssMode && ((a.freeMode && a.freeMode.enabled && n.freeMode || a.watchSlidesProgress) && (n.updateActiveIndex(),
    n.updateSlidesClasses()),
    a.freeMode && a.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(),
    n.updateProgress(o.currentTranslate),
    n.setTranslate(o.currentTranslate))
}
function IS(e) {
    const t = this
      , n = t.touchEventsData;
    let o, a = e;
    a.originalEvent && (a = a.originalEvent);
    if ("touchend" === a.type || "touchcancel" === a.type) {
        if (o = [...a.changedTouches].find(e => e.identifier === n.touchId),
        !o || o.identifier !== n.touchId)
            return
    } else {
        if (null !== n.touchId)
            return;
        if (a.pointerId !== n.pointerId)
            return;
        o = a
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(a.type)) {
        if (!(["pointercancel", "contextmenu"].includes(a.type) && (t.browser.isSafari || t.browser.isWebView)))
            return
    }
    n.pointerId = null,
    n.touchId = null;
    const {params: r, touches: s, rtlTranslate: i, slidesGrid: l, enabled: u} = t;
    if (!u)
        return;
    if (!r.simulateTouch && "mouse" === a.pointerType)
        return;
    if (n.allowTouchCallbacks && t.emit("touchEnd", a),
    n.allowTouchCallbacks = !1,
    !n.isTouched)
        return n.isMoved && r.grabCursor && t.setGrabCursor(!1),
        n.isMoved = !1,
        void (n.startMoving = !1);
    r.grabCursor && n.isMoved && n.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
    const c = eS()
      , d = c - n.touchStartTime;
    if (t.allowClick) {
        const e = a.path || a.composedPath && a.composedPath();
        t.updateClickedSlide(e && e[0] || a.target, e),
        t.emit("tap click", a),
        d < 300 && c - n.lastClickTime < 300 && t.emit("doubleTap doubleClick", a)
    }
    if (n.lastClickTime = eS(),
    Qk( () => {
        t.destroyed || (t.allowClick = !0)
    }
    ),
    !n.isTouched || !n.isMoved || !t.swipeDirection || 0 === s.diff && !n.loopSwapReset || n.currentTranslate === n.startTranslate && !n.loopSwapReset)
        return n.isTouched = !1,
        n.isMoved = !1,
        void (n.startMoving = !1);
    let p;
    if (n.isTouched = !1,
    n.isMoved = !1,
    n.startMoving = !1,
    p = r.followFinger ? i ? t.translate : -t.translate : -n.currentTranslate,
    r.cssMode)
        return;
    if (r.freeMode && r.freeMode.enabled)
        return void t.freeMode.onTouchEnd({
            currentPos: p
        });
    const f = p >= -t.maxTranslate() && !t.params.loop;
    let h = 0
      , v = t.slidesSizesGrid[0];
    for (let w = 0; w < l.length; w += w < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup) {
        const e = w < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
        void 0 !== l[w + e] ? (f || p >= l[w] && p < l[w + e]) && (h = w,
        v = l[w + e] - l[w]) : (f || p >= l[w]) && (h = w,
        v = l[l.length - 1] - l[l.length - 2])
    }
    let m = null
      , g = null;
    r.rewind && (t.isBeginning ? g = r.virtual && r.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (m = 0));
    const y = (p - l[h]) / v
      , b = h < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
    if (d > r.longSwipesMs) {
        if (!r.longSwipes)
            return void t.slideTo(t.activeIndex);
        "next" === t.swipeDirection && (y >= r.longSwipesRatio ? t.slideTo(r.rewind && t.isEnd ? m : h + b) : t.slideTo(h)),
        "prev" === t.swipeDirection && (y > 1 - r.longSwipesRatio ? t.slideTo(h + b) : null !== g && y < 0 && Math.abs(y) > r.longSwipesRatio ? t.slideTo(g) : t.slideTo(h))
    } else {
        if (!r.shortSwipes)
            return void t.slideTo(t.activeIndex);
        t.navigation && (a.target === t.navigation.nextEl || a.target === t.navigation.prevEl) ? a.target === t.navigation.nextEl ? t.slideTo(h + b) : t.slideTo(h) : ("next" === t.swipeDirection && t.slideTo(null !== m ? m : h + b),
        "prev" === t.swipeDirection && t.slideTo(null !== g ? g : h))
    }
}
function LS() {
    const e = this
      , {params: t, el: n} = e;
    if (n && 0 === n.offsetWidth)
        return;
    t.breakpoints && e.setBreakpoint();
    const {allowSlideNext: o, allowSlidePrev: a, snapGrid: r} = e
      , s = e.virtual && e.params.virtual.enabled;
    e.allowSlideNext = !0,
    e.allowSlidePrev = !0,
    e.updateSize(),
    e.updateSlides(),
    e.updateSlidesClasses();
    const i = s && t.loop;
    !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || i ? e.params.loop && !s ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0),
    e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout),
    e.autoplay.resizeTimeout = setTimeout( () => {
        e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume()
    }
    , 500)),
    e.allowSlidePrev = a,
    e.allowSlideNext = o,
    e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow()
}
function RS(e) {
    const t = this;
    t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(),
    t.params.preventClicksPropagation && t.animating && (e.stopPropagation(),
    e.stopImmediatePropagation())))
}
function zS() {
    const e = this
      , {wrapperEl: t, rtlTranslate: n, enabled: o} = e;
    if (!o)
        return;
    let a;
    e.previousTranslate = e.translate,
    e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop,
    0 === e.translate && (e.translate = 0),
    e.updateActiveIndex(),
    e.updateSlidesClasses();
    const r = e.maxTranslate() - e.minTranslate();
    a = 0 === r ? 0 : (e.translate - e.minTranslate()) / r,
    a !== e.progress && e.updateProgress(n ? -e.translate : e.translate),
    e.emit("setTranslate", e.translate, !1)
}
function NS(e) {
    const t = this;
    SS(t, e.target),
    t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update()
}
function DS() {
    const e = this;
    e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0,
    e.params.touchReleaseOnEdges && (e.el.style.touchAction = "auto"))
}
const jS = (e, t) => {
    const n = Yk()
      , {params: o, el: a, wrapperEl: r, device: s} = e
      , i = !!o.nested
      , l = "on" === t ? "addEventListener" : "removeEventListener"
      , u = t;
    a && "string" != typeof a && (n[l]("touchstart", e.onDocumentTouchStart, {
        passive: !1,
        capture: i
    }),
    a[l]("touchstart", e.onTouchStart, {
        passive: !1
    }),
    a[l]("pointerdown", e.onTouchStart, {
        passive: !1
    }),
    n[l]("touchmove", e.onTouchMove, {
        passive: !1,
        capture: i
    }),
    n[l]("pointermove", e.onTouchMove, {
        passive: !1,
        capture: i
    }),
    n[l]("touchend", e.onTouchEnd, {
        passive: !0
    }),
    n[l]("pointerup", e.onTouchEnd, {
        passive: !0
    }),
    n[l]("pointercancel", e.onTouchEnd, {
        passive: !0
    }),
    n[l]("touchcancel", e.onTouchEnd, {
        passive: !0
    }),
    n[l]("pointerout", e.onTouchEnd, {
        passive: !0
    }),
    n[l]("pointerleave", e.onTouchEnd, {
        passive: !0
    }),
    n[l]("contextmenu", e.onTouchEnd, {
        passive: !0
    }),
    (o.preventClicks || o.preventClicksPropagation) && a[l]("click", e.onClick, !0),
    o.cssMode && r[l]("scroll", e.onScroll),
    o.updateOnWindowResize ? e[u](s.ios || s.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", LS, !0) : e[u]("observerUpdate", LS, !0),
    a[l]("load", e.onLoad, {
        capture: !0
    }))
}
;
const FS = (e, t) => e.grid && t.grid && t.grid.rows > 1;
var $S = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    eventsPrefix: "swiper",
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: .5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: .85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    loop: !1,
    loopAddBlankSlides: !0,
    loopAdditionalSlides: 0,
    loopPreventsSliding: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    runCallbacksOnInit: !0,
    _emitClasses: !1
};
function VS(e, t) {
    return function(n) {
        void 0 === n && (n = {});
        const o = Object.keys(n)[0]
          , a = n[o];
        "object" == typeof a && null !== a ? (!0 === e[o] && (e[o] = {
            enabled: !0
        }),
        "navigation" === o && e[o] && e[o].enabled && !e[o].prevEl && !e[o].nextEl && (e[o].auto = !0),
        ["pagination", "scrollbar"].indexOf(o) >= 0 && e[o] && e[o].enabled && !e[o].el && (e[o].auto = !0),
        o in e && "enabled"in a ? ("object" != typeof e[o] || "enabled"in e[o] || (e[o].enabled = !0),
        e[o] || (e[o] = {
            enabled: !1
        }),
        aS(t, n)) : aS(t, n)) : aS(t, n)
    }
}
const HS = {
    eventsEmitter: {
        on(e, t, n) {
            const o = this;
            if (!o.eventsListeners || o.destroyed)
                return o;
            if ("function" != typeof t)
                return o;
            const a = n ? "unshift" : "push";
            return e.split(" ").forEach(e => {
                o.eventsListeners[e] || (o.eventsListeners[e] = []),
                o.eventsListeners[e][a](t)
            }
            ),
            o
        },
        once(e, t, n) {
            const o = this;
            if (!o.eventsListeners || o.destroyed)
                return o;
            if ("function" != typeof t)
                return o;
            function a() {
                o.off(e, a),
                a.__emitterProxy && delete a.__emitterProxy;
                for (var n = arguments.length, r = new Array(n), s = 0; s < n; s++)
                    r[s] = arguments[s];
                t.apply(o, r)
            }
            return a.__emitterProxy = t,
            o.on(e, a, n)
        },
        onAny(e, t) {
            const n = this;
            if (!n.eventsListeners || n.destroyed)
                return n;
            if ("function" != typeof e)
                return n;
            const o = t ? "unshift" : "push";
            return n.eventsAnyListeners.indexOf(e) < 0 && n.eventsAnyListeners[o](e),
            n
        },
        offAny(e) {
            const t = this;
            if (!t.eventsListeners || t.destroyed)
                return t;
            if (!t.eventsAnyListeners)
                return t;
            const n = t.eventsAnyListeners.indexOf(e);
            return n >= 0 && t.eventsAnyListeners.splice(n, 1),
            t
        },
        off(e, t) {
            const n = this;
            return !n.eventsListeners || n.destroyed ? n : n.eventsListeners ? (e.split(" ").forEach(e => {
                void 0 === t ? n.eventsListeners[e] = [] : n.eventsListeners[e] && n.eventsListeners[e].forEach( (o, a) => {
                    (o === t || o.__emitterProxy && o.__emitterProxy === t) && n.eventsListeners[e].splice(a, 1)
                }
                )
            }
            ),
            n) : n
        },
        emit() {
            const e = this;
            if (!e.eventsListeners || e.destroyed)
                return e;
            if (!e.eventsListeners)
                return e;
            let t, n, o;
            for (var a = arguments.length, r = new Array(a), s = 0; s < a; s++)
                r[s] = arguments[s];
            "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0],
            n = r.slice(1, r.length),
            o = e) : (t = r[0].events,
            n = r[0].data,
            o = r[0].context || e),
            n.unshift(o);
            return (Array.isArray(t) ? t : t.split(" ")).forEach(t => {
                e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach(e => {
                    e.apply(o, [t, ...n])
                }
                ),
                e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach(e => {
                    e.apply(o, n)
                }
                )
            }
            ),
            e
        }
    },
    update: {
        updateSize: function() {
            const e = this;
            let t, n;
            const o = e.el;
            t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : o.clientWidth,
            n = void 0 !== e.params.height && null !== e.params.height ? e.params.height : o.clientHeight,
            0 === t && e.isHorizontal() || 0 === n && e.isVertical() || (t = t - parseInt(cS(o, "padding-left") || 0, 10) - parseInt(cS(o, "padding-right") || 0, 10),
            n = n - parseInt(cS(o, "padding-top") || 0, 10) - parseInt(cS(o, "padding-bottom") || 0, 10),
            Number.isNaN(t) && (t = 0),
            Number.isNaN(n) && (n = 0),
            Object.assign(e, {
                width: t,
                height: n,
                size: e.isHorizontal() ? t : n
            }))
        },
        updateSlides: function() {
            const e = this;
            function t(t, n) {
                return parseFloat(t.getPropertyValue(e.getDirectionLabel(n)) || 0)
            }
            const n = e.params
              , {wrapperEl: o, slidesEl: a, size: r, rtlTranslate: s, wrongRTL: i} = e
              , l = e.virtual && n.virtual.enabled
              , u = l ? e.virtual.slides.length : e.slides.length
              , c = iS(a, `.${e.params.slideClass}, swiper-slide`)
              , d = l ? e.virtual.slides.length : c.length;
            let p = [];
            const f = []
              , h = [];
            let v = n.slidesOffsetBefore;
            "function" == typeof v && (v = n.slidesOffsetBefore.call(e));
            let m = n.slidesOffsetAfter;
            "function" == typeof m && (m = n.slidesOffsetAfter.call(e));
            const g = e.snapGrid.length
              , y = e.slidesGrid.length;
            let b = n.spaceBetween
              , w = -v
              , _ = 0
              , x = 0;
            if (void 0 === r)
                return;
            "string" == typeof b && b.indexOf("%") >= 0 ? b = parseFloat(b.replace("%", "")) / 100 * r : "string" == typeof b && (b = parseFloat(b)),
            e.virtualSize = -b,
            c.forEach(e => {
                s ? e.style.marginLeft = "" : e.style.marginRight = "",
                e.style.marginBottom = "",
                e.style.marginTop = ""
            }
            ),
            n.centeredSlides && n.cssMode && (rS(o, "--swiper-centered-offset-before", ""),
            rS(o, "--swiper-centered-offset-after", ""));
            const k = n.grid && n.grid.rows > 1 && e.grid;
            let S;
            k ? e.grid.initSlides(c) : e.grid && e.grid.unsetSlides();
            const C = "auto" === n.slidesPerView && n.breakpoints && Object.keys(n.breakpoints).filter(e => void 0 !== n.breakpoints[e].slidesPerView).length > 0;
            for (let E = 0; E < d; E += 1) {
                let o;
                if (S = 0,
                c[E] && (o = c[E]),
                k && e.grid.updateSlide(E, o, c),
                !c[E] || "none" !== cS(o, "display")) {
                    if ("auto" === n.slidesPerView) {
                        C && (c[E].style[e.getDirectionLabel("width")] = "");
                        const a = getComputedStyle(o)
                          , r = o.style.transform
                          , s = o.style.webkitTransform;
                        if (r && (o.style.transform = "none"),
                        s && (o.style.webkitTransform = "none"),
                        n.roundLengths)
                            S = e.isHorizontal() ? fS(o, "width") : fS(o, "height");
                        else {
                            const e = t(a, "width")
                              , n = t(a, "padding-left")
                              , r = t(a, "padding-right")
                              , s = t(a, "margin-left")
                              , i = t(a, "margin-right")
                              , l = a.getPropertyValue("box-sizing");
                            if (l && "border-box" === l)
                                S = e + s + i;
                            else {
                                const {clientWidth: t, offsetWidth: a} = o;
                                S = e + n + r + s + i + (a - t)
                            }
                        }
                        r && (o.style.transform = r),
                        s && (o.style.webkitTransform = s),
                        n.roundLengths && (S = Math.floor(S))
                    } else
                        S = (r - (n.slidesPerView - 1) * b) / n.slidesPerView,
                        n.roundLengths && (S = Math.floor(S)),
                        c[E] && (c[E].style[e.getDirectionLabel("width")] = `${S}px`);
                    c[E] && (c[E].swiperSlideSize = S),
                    h.push(S),
                    n.centeredSlides ? (w = w + S / 2 + _ / 2 + b,
                    0 === _ && 0 !== E && (w = w - r / 2 - b),
                    0 === E && (w = w - r / 2 - b),
                    Math.abs(w) < .001 && (w = 0),
                    n.roundLengths && (w = Math.floor(w)),
                    x % n.slidesPerGroup === 0 && p.push(w),
                    f.push(w)) : (n.roundLengths && (w = Math.floor(w)),
                    (x - Math.min(e.params.slidesPerGroupSkip, x)) % e.params.slidesPerGroup === 0 && p.push(w),
                    f.push(w),
                    w = w + S + b),
                    e.virtualSize += S + b,
                    _ = S,
                    x += 1
                }
            }
            if (e.virtualSize = Math.max(e.virtualSize, r) + m,
            s && i && ("slide" === n.effect || "coverflow" === n.effect) && (o.style.width = `${e.virtualSize + b}px`),
            n.setWrapperSize && (o.style[e.getDirectionLabel("width")] = `${e.virtualSize + b}px`),
            k && e.grid.updateWrapperSize(S, p),
            !n.centeredSlides) {
                const t = [];
                for (let o = 0; o < p.length; o += 1) {
                    let a = p[o];
                    n.roundLengths && (a = Math.floor(a)),
                    p[o] <= e.virtualSize - r && t.push(a)
                }
                p = t,
                Math.floor(e.virtualSize - r) - Math.floor(p[p.length - 1]) > 1 && p.push(e.virtualSize - r)
            }
            if (l && n.loop) {
                const t = h[0] + b;
                if (n.slidesPerGroup > 1) {
                    const o = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / n.slidesPerGroup)
                      , a = t * n.slidesPerGroup;
                    for (let e = 0; e < o; e += 1)
                        p.push(p[p.length - 1] + a)
                }
                for (let o = 0; o < e.virtual.slidesBefore + e.virtual.slidesAfter; o += 1)
                    1 === n.slidesPerGroup && p.push(p[p.length - 1] + t),
                    f.push(f[f.length - 1] + t),
                    e.virtualSize += t
            }
            if (0 === p.length && (p = [0]),
            0 !== b) {
                const t = e.isHorizontal() && s ? "marginLeft" : e.getDirectionLabel("marginRight");
                c.filter( (e, t) => !(n.cssMode && !n.loop) || t !== c.length - 1).forEach(e => {
                    e.style[t] = `${b}px`
                }
                )
            }
            if (n.centeredSlides && n.centeredSlidesBounds) {
                let e = 0;
                h.forEach(t => {
                    e += t + (b || 0)
                }
                ),
                e -= b;
                const t = e > r ? e - r : 0;
                p = p.map(e => e <= 0 ? -v : e > t ? t + m : e)
            }
            if (n.centerInsufficientSlides) {
                let e = 0;
                h.forEach(t => {
                    e += t + (b || 0)
                }
                ),
                e -= b;
                const t = (n.slidesOffsetBefore || 0) + (n.slidesOffsetAfter || 0);
                if (e + t < r) {
                    const n = (r - e - t) / 2;
                    p.forEach( (e, t) => {
                        p[t] = e - n
                    }
                    ),
                    f.forEach( (e, t) => {
                        f[t] = e + n
                    }
                    )
                }
            }
            if (Object.assign(e, {
                slides: c,
                snapGrid: p,
                slidesGrid: f,
                slidesSizesGrid: h
            }),
            n.centeredSlides && n.cssMode && !n.centeredSlidesBounds) {
                rS(o, "--swiper-centered-offset-before", -p[0] + "px"),
                rS(o, "--swiper-centered-offset-after", e.size / 2 - h[h.length - 1] / 2 + "px");
                const t = -e.snapGrid[0]
                  , n = -e.slidesGrid[0];
                e.snapGrid = e.snapGrid.map(e => e + t),
                e.slidesGrid = e.slidesGrid.map(e => e + n)
            }
            if (d !== u && e.emit("slidesLengthChange"),
            p.length !== g && (e.params.watchOverflow && e.checkOverflow(),
            e.emit("snapGridLengthChange")),
            f.length !== y && e.emit("slidesGridLengthChange"),
            n.watchSlidesProgress && e.updateSlidesOffset(),
            e.emit("slidesUpdated"),
            !(l || n.cssMode || "slide" !== n.effect && "fade" !== n.effect)) {
                const t = `${n.containerModifierClass}backface-hidden`
                  , o = e.el.classList.contains(t);
                d <= n.maxBackfaceHiddenSlides ? o || e.el.classList.add(t) : o && e.el.classList.remove(t)
            }
        },
        updateAutoHeight: function(e) {
            const t = this
              , n = []
              , o = t.virtual && t.params.virtual.enabled;
            let a, r = 0;
            "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
            const s = e => o ? t.slides[t.getSlideIndexByData(e)] : t.slides[e];
            if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
                if (t.params.centeredSlides)
                    (t.visibleSlides || []).forEach(e => {
                        n.push(e)
                    }
                    );
                else
                    for (a = 0; a < Math.ceil(t.params.slidesPerView); a += 1) {
                        const e = t.activeIndex + a;
                        if (e > t.slides.length && !o)
                            break;
                        n.push(s(e))
                    }
            else
                n.push(s(t.activeIndex));
            for (a = 0; a < n.length; a += 1)
                if (void 0 !== n[a]) {
                    const e = n[a].offsetHeight;
                    r = e > r ? e : r
                }
            (r || 0 === r) && (t.wrapperEl.style.height = `${r}px`)
        },
        updateSlidesOffset: function() {
            const e = this
              , t = e.slides
              , n = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0;
            for (let o = 0; o < t.length; o += 1)
                t[o].swiperSlideOffset = (e.isHorizontal() ? t[o].offsetLeft : t[o].offsetTop) - n - e.cssOverflowAdjustment()
        },
        updateSlidesProgress: function(e) {
            void 0 === e && (e = this && this.translate || 0);
            const t = this
              , n = t.params
              , {slides: o, rtlTranslate: a, snapGrid: r} = t;
            if (0 === o.length)
                return;
            void 0 === o[0].swiperSlideOffset && t.updateSlidesOffset();
            let s = -e;
            a && (s = e),
            t.visibleSlidesIndexes = [],
            t.visibleSlides = [];
            let i = n.spaceBetween;
            "string" == typeof i && i.indexOf("%") >= 0 ? i = parseFloat(i.replace("%", "")) / 100 * t.size : "string" == typeof i && (i = parseFloat(i));
            for (let l = 0; l < o.length; l += 1) {
                const e = o[l];
                let u = e.swiperSlideOffset;
                n.cssMode && n.centeredSlides && (u -= o[0].swiperSlideOffset);
                const c = (s + (n.centeredSlides ? t.minTranslate() : 0) - u) / (e.swiperSlideSize + i)
                  , d = (s - r[0] + (n.centeredSlides ? t.minTranslate() : 0) - u) / (e.swiperSlideSize + i)
                  , p = -(s - u)
                  , f = p + t.slidesSizesGrid[l]
                  , h = p >= 0 && p <= t.size - t.slidesSizesGrid[l]
                  , v = p >= 0 && p < t.size - 1 || f > 1 && f <= t.size || p <= 0 && f >= t.size;
                v && (t.visibleSlides.push(e),
                t.visibleSlidesIndexes.push(l)),
                xS(e, v, n.slideVisibleClass),
                xS(e, h, n.slideFullyVisibleClass),
                e.progress = a ? -c : c,
                e.originalProgress = a ? -d : d
            }
        },
        updateProgress: function(e) {
            const t = this;
            if (void 0 === e) {
                const n = t.rtlTranslate ? -1 : 1;
                e = t && t.translate && t.translate * n || 0
            }
            const n = t.params
              , o = t.maxTranslate() - t.minTranslate();
            let {progress: a, isBeginning: r, isEnd: s, progressLoop: i} = t;
            const l = r
              , u = s;
            if (0 === o)
                a = 0,
                r = !0,
                s = !0;
            else {
                a = (e - t.minTranslate()) / o;
                const n = Math.abs(e - t.minTranslate()) < 1
                  , i = Math.abs(e - t.maxTranslate()) < 1;
                r = n || a <= 0,
                s = i || a >= 1,
                n && (a = 0),
                i && (a = 1)
            }
            if (n.loop) {
                const n = t.getSlideIndexByData(0)
                  , o = t.getSlideIndexByData(t.slides.length - 1)
                  , a = t.slidesGrid[n]
                  , r = t.slidesGrid[o]
                  , s = t.slidesGrid[t.slidesGrid.length - 1]
                  , l = Math.abs(e);
                i = l >= a ? (l - a) / s : (l + s - r) / s,
                i > 1 && (i -= 1)
            }
            Object.assign(t, {
                progress: a,
                progressLoop: i,
                isBeginning: r,
                isEnd: s
            }),
            (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && t.updateSlidesProgress(e),
            r && !l && t.emit("reachBeginning toEdge"),
            s && !u && t.emit("reachEnd toEdge"),
            (l && !r || u && !s) && t.emit("fromEdge"),
            t.emit("progress", a)
        },
        updateSlidesClasses: function() {
            const e = this
              , {slides: t, params: n, slidesEl: o, activeIndex: a} = e
              , r = e.virtual && n.virtual.enabled
              , s = e.grid && n.grid && n.grid.rows > 1
              , i = e => iS(o, `.${n.slideClass}${e}, swiper-slide${e}`)[0];
            let l, u, c;
            if (r)
                if (n.loop) {
                    let t = a - e.virtual.slidesBefore;
                    t < 0 && (t = e.virtual.slides.length + t),
                    t >= e.virtual.slides.length && (t -= e.virtual.slides.length),
                    l = i(`[data-swiper-slide-index="${t}"]`)
                } else
                    l = i(`[data-swiper-slide-index="${a}"]`);
            else
                s ? (l = t.find(e => e.column === a),
                c = t.find(e => e.column === a + 1),
                u = t.find(e => e.column === a - 1)) : l = t[a];
            l && (s || (c = function(e, t) {
                const n = [];
                for (; e.nextElementSibling; ) {
                    const o = e.nextElementSibling;
                    t ? o.matches(t) && n.push(o) : n.push(o),
                    e = o
                }
                return n
            }(l, `.${n.slideClass}, swiper-slide`)[0],
            n.loop && !c && (c = t[0]),
            u = function(e, t) {
                const n = [];
                for (; e.previousElementSibling; ) {
                    const o = e.previousElementSibling;
                    t ? o.matches(t) && n.push(o) : n.push(o),
                    e = o
                }
                return n
            }(l, `.${n.slideClass}, swiper-slide`)[0],
            n.loop && 0 === !u && (u = t[t.length - 1]))),
            t.forEach(e => {
                kS(e, e === l, n.slideActiveClass),
                kS(e, e === c, n.slideNextClass),
                kS(e, e === u, n.slidePrevClass)
            }
            ),
            e.emitSlidesClasses()
        },
        updateActiveIndex: function(e) {
            const t = this
              , n = t.rtlTranslate ? t.translate : -t.translate
              , {snapGrid: o, params: a, activeIndex: r, realIndex: s, snapIndex: i} = t;
            let l, u = e;
            const c = e => {
                let n = e - t.virtual.slidesBefore;
                return n < 0 && (n = t.virtual.slides.length + n),
                n >= t.virtual.slides.length && (n -= t.virtual.slides.length),
                n
            }
            ;
            if (void 0 === u && (u = function(e) {
                const {slidesGrid: t, params: n} = e
                  , o = e.rtlTranslate ? e.translate : -e.translate;
                let a;
                for (let r = 0; r < t.length; r += 1)
                    void 0 !== t[r + 1] ? o >= t[r] && o < t[r + 1] - (t[r + 1] - t[r]) / 2 ? a = r : o >= t[r] && o < t[r + 1] && (a = r + 1) : o >= t[r] && (a = r);
                return n.normalizeSlideIndex && (a < 0 || void 0 === a) && (a = 0),
                a
            }(t)),
            o.indexOf(n) >= 0)
                l = o.indexOf(n);
            else {
                const e = Math.min(a.slidesPerGroupSkip, u);
                l = e + Math.floor((u - e) / a.slidesPerGroup)
            }
            if (l >= o.length && (l = o.length - 1),
            u === r && !t.params.loop)
                return void (l !== i && (t.snapIndex = l,
                t.emit("snapIndexChange")));
            if (u === r && t.params.loop && t.virtual && t.params.virtual.enabled)
                return void (t.realIndex = c(u));
            const d = t.grid && a.grid && a.grid.rows > 1;
            let p;
            if (t.virtual && a.virtual.enabled && a.loop)
                p = c(u);
            else if (d) {
                const e = t.slides.find(e => e.column === u);
                let n = parseInt(e.getAttribute("data-swiper-slide-index"), 10);
                Number.isNaN(n) && (n = Math.max(t.slides.indexOf(e), 0)),
                p = Math.floor(n / a.grid.rows)
            } else if (t.slides[u]) {
                const e = t.slides[u].getAttribute("data-swiper-slide-index");
                p = e ? parseInt(e, 10) : u
            } else
                p = u;
            Object.assign(t, {
                previousSnapIndex: i,
                snapIndex: l,
                previousRealIndex: s,
                realIndex: p,
                previousIndex: r,
                activeIndex: u
            }),
            t.initialized && ES(t),
            t.emit("activeIndexChange"),
            t.emit("snapIndexChange"),
            (t.initialized || t.params.runCallbacksOnInit) && (s !== p && t.emit("realIndexChange"),
            t.emit("slideChange"))
        },
        updateClickedSlide: function(e, t) {
            const n = this
              , o = n.params;
            let a = e.closest(`.${o.slideClass}, swiper-slide`);
            !a && n.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach(e => {
                !a && e.matches && e.matches(`.${o.slideClass}, swiper-slide`) && (a = e)
            }
            );
            let r, s = !1;
            if (a)
                for (let i = 0; i < n.slides.length; i += 1)
                    if (n.slides[i] === a) {
                        s = !0,
                        r = i;
                        break
                    }
            if (!a || !s)
                return n.clickedSlide = void 0,
                void (n.clickedIndex = void 0);
            n.clickedSlide = a,
            n.virtual && n.params.virtual.enabled ? n.clickedIndex = parseInt(a.getAttribute("data-swiper-slide-index"), 10) : n.clickedIndex = r,
            o.slideToClickedSlide && void 0 !== n.clickedIndex && n.clickedIndex !== n.activeIndex && n.slideToClickedSlide()
        }
    },
    translate: TS,
    transition: {
        setTransition: function(e, t) {
            const n = this;
            n.params.cssMode || (n.wrapperEl.style.transitionDuration = `${e}ms`,
            n.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""),
            n.emit("setTransition", e, t)
        },
        transitionStart: function(e, t) {
            void 0 === e && (e = !0);
            const n = this
              , {params: o} = n;
            o.cssMode || (o.autoHeight && n.updateAutoHeight(),
            AS({
                swiper: n,
                runCallbacks: e,
                direction: t,
                step: "Start"
            }))
        },
        transitionEnd: function(e, t) {
            void 0 === e && (e = !0);
            const n = this
              , {params: o} = n;
            n.animating = !1,
            o.cssMode || (n.setTransition(0),
            AS({
                swiper: n,
                runCallbacks: e,
                direction: t,
                step: "End"
            }))
        }
    },
    slide: OS,
    loop: {
        loopCreate: function(e, t) {
            const n = this
              , {params: o, slidesEl: a} = n;
            if (!o.loop || n.virtual && n.params.virtual.enabled)
                return;
            const r = () => {
                iS(a, `.${o.slideClass}, swiper-slide`).forEach( (e, t) => {
                    e.setAttribute("data-swiper-slide-index", t)
                }
                )
            }
              , s = n.grid && o.grid && o.grid.rows > 1;
            o.loopAddBlankSlides && (o.slidesPerGroup > 1 || s) && ( () => {
                const e = iS(a, `.${o.slideBlankClass}`);
                e.forEach(e => {
                    e.remove()
                }
                ),
                e.length > 0 && (n.recalcSlides(),
                n.updateSlides())
            }
            )();
            const i = o.slidesPerGroup * (s ? o.grid.rows : 1)
              , l = n.slides.length % i !== 0
              , u = s && n.slides.length % o.grid.rows !== 0
              , c = e => {
                for (let t = 0; t < e; t += 1) {
                    const e = n.isElement ? uS("swiper-slide", [o.slideBlankClass]) : uS("div", [o.slideClass, o.slideBlankClass]);
                    n.slidesEl.append(e)
                }
            }
            ;
            if (l) {
                if (o.loopAddBlankSlides) {
                    c(i - n.slides.length % i),
                    n.recalcSlides(),
                    n.updateSlides()
                } else
                    lS();
                r()
            } else if (u) {
                if (o.loopAddBlankSlides) {
                    c(o.grid.rows - n.slides.length % o.grid.rows),
                    n.recalcSlides(),
                    n.updateSlides()
                } else
                    lS();
                r()
            } else
                r();
            n.loopFix({
                slideRealIndex: e,
                direction: o.centeredSlides ? void 0 : "next",
                initial: t
            })
        },
        loopFix: function(e) {
            let {slideRealIndex: t, slideTo: n=!0, direction: o, setTranslate: a, activeSlideIndex: r, initial: s, byController: i, byMousewheel: l} = void 0 === e ? {} : e;
            const u = this;
            if (!u.params.loop)
                return;
            u.emit("beforeLoopFix");
            const {slides: c, allowSlidePrev: d, allowSlideNext: p, slidesEl: f, params: h} = u
              , {centeredSlides: v, initialSlide: m} = h;
            if (u.allowSlidePrev = !0,
            u.allowSlideNext = !0,
            u.virtual && h.virtual.enabled)
                return n && (h.centeredSlides || 0 !== u.snapIndex ? h.centeredSlides && u.snapIndex < h.slidesPerView ? u.slideTo(u.virtual.slides.length + u.snapIndex, 0, !1, !0) : u.snapIndex === u.snapGrid.length - 1 && u.slideTo(u.virtual.slidesBefore, 0, !1, !0) : u.slideTo(u.virtual.slides.length, 0, !1, !0)),
                u.allowSlidePrev = d,
                u.allowSlideNext = p,
                void u.emit("loopFix");
            let g = h.slidesPerView;
            "auto" === g ? g = u.slidesPerViewDynamic() : (g = Math.ceil(parseFloat(h.slidesPerView, 10)),
            v && g % 2 == 0 && (g += 1));
            const y = h.slidesPerGroupAuto ? g : h.slidesPerGroup;
            let b = v ? Math.max(y, Math.ceil(g / 2)) : y;
            b % y !== 0 && (b += y - b % y),
            b += h.loopAdditionalSlides,
            u.loopedSlides = b;
            const w = u.grid && h.grid && h.grid.rows > 1;
            (c.length < g + b || "cards" === u.params.effect && c.length < g + 2 * b || w && "row" === h.grid.fill) && lS();
            const _ = []
              , x = []
              , k = w ? Math.ceil(c.length / h.grid.rows) : c.length
              , S = s && k - m < g && !v;
            let C = S ? m : u.activeIndex;
            void 0 === r ? r = u.getSlideIndex(c.find(e => e.classList.contains(h.slideActiveClass))) : C = r;
            const E = "next" === o || !o
              , T = "prev" === o || !o;
            let A = 0
              , O = 0;
            const M = (w ? c[r].column : r) + (v && void 0 === a ? -g / 2 + .5 : 0);
            if (M < b) {
                A = Math.max(b - M, y);
                for (let e = 0; e < b - M; e += 1) {
                    const t = e - Math.floor(e / k) * k;
                    if (w) {
                        const e = k - t - 1;
                        for (let t = c.length - 1; t >= 0; t -= 1)
                            c[t].column === e && _.push(t)
                    } else
                        _.push(k - t - 1)
                }
            } else if (M + g > k - b) {
                O = Math.max(M - (k - 2 * b), y),
                S && (O = Math.max(O, g - k + m + 1));
                for (let e = 0; e < O; e += 1) {
                    const t = e - Math.floor(e / k) * k;
                    w ? c.forEach( (e, n) => {
                        e.column === t && x.push(n)
                    }
                    ) : x.push(t)
                }
            }
            if (u.__preventObserver__ = !0,
            requestAnimationFrame( () => {
                u.__preventObserver__ = !1
            }
            ),
            "cards" === u.params.effect && c.length < g + 2 * b && (x.includes(r) && x.splice(x.indexOf(r), 1),
            _.includes(r) && _.splice(_.indexOf(r), 1)),
            T && _.forEach(e => {
                c[e].swiperLoopMoveDOM = !0,
                f.prepend(c[e]),
                c[e].swiperLoopMoveDOM = !1
            }
            ),
            E && x.forEach(e => {
                c[e].swiperLoopMoveDOM = !0,
                f.append(c[e]),
                c[e].swiperLoopMoveDOM = !1
            }
            ),
            u.recalcSlides(),
            "auto" === h.slidesPerView ? u.updateSlides() : w && (_.length > 0 && T || x.length > 0 && E) && u.slides.forEach( (e, t) => {
                u.grid.updateSlide(t, e, u.slides)
            }
            ),
            h.watchSlidesProgress && u.updateSlidesOffset(),
            n)
                if (_.length > 0 && T) {
                    if (void 0 === t) {
                        const e = u.slidesGrid[C]
                          , t = u.slidesGrid[C + A] - e;
                        l ? u.setTranslate(u.translate - t) : (u.slideTo(C + Math.ceil(A), 0, !1, !0),
                        a && (u.touchEventsData.startTranslate = u.touchEventsData.startTranslate - t,
                        u.touchEventsData.currentTranslate = u.touchEventsData.currentTranslate - t))
                    } else if (a) {
                        const e = w ? _.length / h.grid.rows : _.length;
                        u.slideTo(u.activeIndex + e, 0, !1, !0),
                        u.touchEventsData.currentTranslate = u.translate
                    }
                } else if (x.length > 0 && E)
                    if (void 0 === t) {
                        const e = u.slidesGrid[C]
                          , t = u.slidesGrid[C - O] - e;
                        l ? u.setTranslate(u.translate - t) : (u.slideTo(C - O, 0, !1, !0),
                        a && (u.touchEventsData.startTranslate = u.touchEventsData.startTranslate - t,
                        u.touchEventsData.currentTranslate = u.touchEventsData.currentTranslate - t))
                    } else {
                        const e = w ? x.length / h.grid.rows : x.length;
                        u.slideTo(u.activeIndex - e, 0, !1, !0)
                    }
            if (u.allowSlidePrev = d,
            u.allowSlideNext = p,
            u.controller && u.controller.control && !i) {
                const e = {
                    slideRealIndex: t,
                    direction: o,
                    setTranslate: a,
                    activeSlideIndex: r,
                    byController: !0
                };
                Array.isArray(u.controller.control) ? u.controller.control.forEach(t => {
                    !t.destroyed && t.params.loop && t.loopFix({
                        ...e,
                        slideTo: t.params.slidesPerView === h.slidesPerView && n
                    })
                }
                ) : u.controller.control instanceof u.constructor && u.controller.control.params.loop && u.controller.control.loopFix({
                    ...e,
                    slideTo: u.controller.control.params.slidesPerView === h.slidesPerView && n
                })
            }
            u.emit("loopFix")
        },
        loopDestroy: function() {
            const e = this
              , {params: t, slidesEl: n} = e;
            if (!t.loop || !n || e.virtual && e.params.virtual.enabled)
                return;
            e.recalcSlides();
            const o = [];
            e.slides.forEach(e => {
                const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex;
                o[t] = e
            }
            ),
            e.slides.forEach(e => {
                e.removeAttribute("data-swiper-slide-index")
            }
            ),
            o.forEach(e => {
                n.append(e)
            }
            ),
            e.recalcSlides(),
            e.slideTo(e.realIndex, 0)
        }
    },
    grabCursor: {
        setGrabCursor: function(e) {
            const t = this;
            if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode)
                return;
            const n = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
            t.isElement && (t.__preventObserver__ = !0),
            n.style.cursor = "move",
            n.style.cursor = e ? "grabbing" : "grab",
            t.isElement && requestAnimationFrame( () => {
                t.__preventObserver__ = !1
            }
            )
        },
        unsetGrabCursor: function() {
            const e = this;
            e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0),
            e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "",
            e.isElement && requestAnimationFrame( () => {
                e.__preventObserver__ = !1
            }
            ))
        }
    },
    events: {
        attachEvents: function() {
            const e = this
              , {params: t} = e;
            e.onTouchStart = PS.bind(e),
            e.onTouchMove = BS.bind(e),
            e.onTouchEnd = IS.bind(e),
            e.onDocumentTouchStart = DS.bind(e),
            t.cssMode && (e.onScroll = zS.bind(e)),
            e.onClick = RS.bind(e),
            e.onLoad = NS.bind(e),
            jS(e, "on")
        },
        detachEvents: function() {
            jS(this, "off")
        }
    },
    breakpoints: {
        setBreakpoint: function() {
            const e = this
              , {realIndex: t, initialized: n, params: o, el: a} = e
              , r = o.breakpoints;
            if (!r || r && 0 === Object.keys(r).length)
                return;
            const s = Yk()
              , i = "window" !== o.breakpointsBase && o.breakpointsBase ? "container" : o.breakpointsBase
              , l = ["window", "container"].includes(o.breakpointsBase) || !o.breakpointsBase ? e.el : s.querySelector(o.breakpointsBase)
              , u = e.getBreakpoint(r, i, l);
            if (!u || e.currentBreakpoint === u)
                return;
            const c = (u in r ? r[u] : void 0) || e.originalParams
              , d = FS(e, o)
              , p = FS(e, c)
              , f = e.params.grabCursor
              , h = c.grabCursor
              , v = o.enabled;
            d && !p ? (a.classList.remove(`${o.containerModifierClass}grid`, `${o.containerModifierClass}grid-column`),
            e.emitContainerClasses()) : !d && p && (a.classList.add(`${o.containerModifierClass}grid`),
            (c.grid.fill && "column" === c.grid.fill || !c.grid.fill && "column" === o.grid.fill) && a.classList.add(`${o.containerModifierClass}grid-column`),
            e.emitContainerClasses()),
            f && !h ? e.unsetGrabCursor() : !f && h && e.setGrabCursor(),
            ["navigation", "pagination", "scrollbar"].forEach(t => {
                if (void 0 === c[t])
                    return;
                const n = o[t] && o[t].enabled
                  , a = c[t] && c[t].enabled;
                n && !a && e[t].disable(),
                !n && a && e[t].enable()
            }
            );
            const m = c.direction && c.direction !== o.direction
              , g = o.loop && (c.slidesPerView !== o.slidesPerView || m)
              , y = o.loop;
            m && n && e.changeDirection(),
            aS(e.params, c);
            const b = e.params.enabled
              , w = e.params.loop;
            Object.assign(e, {
                allowTouchMove: e.params.allowTouchMove,
                allowSlideNext: e.params.allowSlideNext,
                allowSlidePrev: e.params.allowSlidePrev
            }),
            v && !b ? e.disable() : !v && b && e.enable(),
            e.currentBreakpoint = u,
            e.emit("_beforeBreakpoint", c),
            n && (g ? (e.loopDestroy(),
            e.loopCreate(t),
            e.updateSlides()) : !y && w ? (e.loopCreate(t),
            e.updateSlides()) : y && !w && e.loopDestroy()),
            e.emit("breakpoint", c)
        },
        getBreakpoint: function(e, t, n) {
            if (void 0 === t && (t = "window"),
            !e || "container" === t && !n)
                return;
            let o = !1;
            const a = Jk()
              , r = "window" === t ? a.innerHeight : n.clientHeight
              , s = Object.keys(e).map(e => {
                if ("string" == typeof e && 0 === e.indexOf("@")) {
                    const t = parseFloat(e.substr(1));
                    return {
                        value: r * t,
                        point: e
                    }
                }
                return {
                    value: e,
                    point: e
                }
            }
            );
            s.sort( (e, t) => parseInt(e.value, 10) - parseInt(t.value, 10));
            for (let i = 0; i < s.length; i += 1) {
                const {point: e, value: r} = s[i];
                "window" === t ? a.matchMedia(`(min-width: ${r}px)`).matches && (o = e) : r <= n.clientWidth && (o = e)
            }
            return o || "max"
        }
    },
    checkOverflow: {
        checkOverflow: function() {
            const e = this
              , {isLocked: t, params: n} = e
              , {slidesOffsetBefore: o} = n;
            if (o) {
                const t = e.slides.length - 1
                  , n = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * o;
                e.isLocked = e.size > n
            } else
                e.isLocked = 1 === e.snapGrid.length;
            !0 === n.allowSlideNext && (e.allowSlideNext = !e.isLocked),
            !0 === n.allowSlidePrev && (e.allowSlidePrev = !e.isLocked),
            t && t !== e.isLocked && (e.isEnd = !1),
            t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
        }
    },
    classes: {
        addClasses: function() {
            const e = this
              , {classNames: t, params: n, rtl: o, el: a, device: r} = e
              , s = function(e, t) {
                const n = [];
                return e.forEach(e => {
                    "object" == typeof e ? Object.keys(e).forEach(o => {
                        e[o] && n.push(t + o)
                    }
                    ) : "string" == typeof e && n.push(t + e)
                }
                ),
                n
            }(["initialized", n.direction, {
                "free-mode": e.params.freeMode && n.freeMode.enabled
            }, {
                autoheight: n.autoHeight
            }, {
                rtl: o
            }, {
                grid: n.grid && n.grid.rows > 1
            }, {
                "grid-column": n.grid && n.grid.rows > 1 && "column" === n.grid.fill
            }, {
                android: r.android
            }, {
                ios: r.ios
            }, {
                "css-mode": n.cssMode
            }, {
                centered: n.cssMode && n.centeredSlides
            }, {
                "watch-progress": n.watchSlidesProgress
            }], n.containerModifierClass);
            t.push(...s),
            a.classList.add(...t),
            e.emitContainerClasses()
        },
        removeClasses: function() {
            const {el: e, classNames: t} = this;
            e && "string" != typeof e && (e.classList.remove(...t),
            this.emitContainerClasses())
        }
    }
}
  , US = {};
let ZS = class e {
    constructor() {
        let t, n;
        for (var o = arguments.length, a = new Array(o), r = 0; r < o; r++)
            a[r] = arguments[r];
        1 === a.length && a[0].constructor && "Object" === Object.prototype.toString.call(a[0]).slice(8, -1) ? n = a[0] : [t,n] = a,
        n || (n = {}),
        n = aS({}, n),
        t && !n.el && (n.el = t);
        const s = Yk();
        if (n.el && "string" == typeof n.el && s.querySelectorAll(n.el).length > 1) {
            const t = [];
            return s.querySelectorAll(n.el).forEach(o => {
                const a = aS({}, n, {
                    el: o
                });
                t.push(new e(a))
            }
            ),
            t
        }
        const i = this;
        i.__swiper__ = !0,
        i.support = bS(),
        i.device = wS({
            userAgent: n.userAgent
        }),
        i.browser = _S(),
        i.eventsListeners = {},
        i.eventsAnyListeners = [],
        i.modules = [...i.__modules__],
        n.modules && Array.isArray(n.modules) && i.modules.push(...n.modules);
        const l = {};
        i.modules.forEach(e => {
            e({
                params: n,
                swiper: i,
                extendParams: VS(n, l),
                on: i.on.bind(i),
                once: i.once.bind(i),
                off: i.off.bind(i),
                emit: i.emit.bind(i)
            })
        }
        );
        const u = aS({}, $S, l);
        return i.params = aS({}, u, US, n),
        i.originalParams = aS({}, i.params),
        i.passedParams = aS({}, n),
        i.params && i.params.on && Object.keys(i.params.on).forEach(e => {
            i.on(e, i.params.on[e])
        }
        ),
        i.params && i.params.onAny && i.onAny(i.params.onAny),
        Object.assign(i, {
            enabled: i.params.enabled,
            el: t,
            classNames: [],
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal: () => "horizontal" === i.params.direction,
            isVertical: () => "vertical" === i.params.direction,
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            cssOverflowAdjustment() {
                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
            },
            allowSlideNext: i.params.allowSlideNext,
            allowSlidePrev: i.params.allowSlidePrev,
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: i.params.focusableElements,
                lastClickTime: 0,
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                startMoving: void 0,
                pointerId: null,
                touchId: null
            },
            allowClick: !0,
            allowTouchMove: i.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        }),
        i.emit("_swiper"),
        i.params.init && i.init(),
        i
    }
    getDirectionLabel(e) {
        return this.isHorizontal() ? e : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[e]
    }
    getSlideIndex(e) {
        const {slidesEl: t, params: n} = this
          , o = dS(iS(t, `.${n.slideClass}, swiper-slide`)[0]);
        return dS(e) - o
    }
    getSlideIndexByData(e) {
        return this.getSlideIndex(this.slides.find(t => 1 * t.getAttribute("data-swiper-slide-index") === e))
    }
    getSlideIndexWhenGrid(e) {
        return this.grid && this.params.grid && this.params.grid.rows > 1 && ("column" === this.params.grid.fill ? e = Math.floor(e / this.params.grid.rows) : "row" === this.params.grid.fill && (e %= Math.ceil(this.slides.length / this.params.grid.rows))),
        e
    }
    recalcSlides() {
        const {slidesEl: e, params: t} = this;
        this.slides = iS(e, `.${t.slideClass}, swiper-slide`)
    }
    enable() {
        const e = this;
        e.enabled || (e.enabled = !0,
        e.params.grabCursor && e.setGrabCursor(),
        e.emit("enable"))
    }
    disable() {
        const e = this;
        e.enabled && (e.enabled = !1,
        e.params.grabCursor && e.unsetGrabCursor(),
        e.emit("disable"))
    }
    setProgress(e, t) {
        const n = this;
        e = Math.min(Math.max(e, 0), 1);
        const o = n.minTranslate()
          , a = (n.maxTranslate() - o) * e + o;
        n.translateTo(a, void 0 === t ? 0 : t),
        n.updateActiveIndex(),
        n.updateSlidesClasses()
    }
    emitContainerClasses() {
        const e = this;
        if (!e.params._emitClasses || !e.el)
            return;
        const t = e.el.className.split(" ").filter(t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass));
        e.emit("_containerClasses", t.join(" "))
    }
    getSlideClasses(e) {
        const t = this;
        return t.destroyed ? "" : e.className.split(" ").filter(e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass)).join(" ")
    }
    emitSlidesClasses() {
        const e = this;
        if (!e.params._emitClasses || !e.el)
            return;
        const t = [];
        e.slides.forEach(n => {
            const o = e.getSlideClasses(n);
            t.push({
                slideEl: n,
                classNames: o
            }),
            e.emit("_slideClass", n, o)
        }
        ),
        e.emit("_slideClasses", t)
    }
    slidesPerViewDynamic(e, t) {
        void 0 === e && (e = "current"),
        void 0 === t && (t = !1);
        const {params: n, slides: o, slidesGrid: a, slidesSizesGrid: r, size: s, activeIndex: i} = this;
        let l = 1;
        if ("number" == typeof n.slidesPerView)
            return n.slidesPerView;
        if (n.centeredSlides) {
            let e, t = o[i] ? Math.ceil(o[i].swiperSlideSize) : 0;
            for (let n = i + 1; n < o.length; n += 1)
                o[n] && !e && (t += Math.ceil(o[n].swiperSlideSize),
                l += 1,
                t > s && (e = !0));
            for (let n = i - 1; n >= 0; n -= 1)
                o[n] && !e && (t += o[n].swiperSlideSize,
                l += 1,
                t > s && (e = !0))
        } else if ("current" === e)
            for (let u = i + 1; u < o.length; u += 1) {
                (t ? a[u] + r[u] - a[i] < s : a[u] - a[i] < s) && (l += 1)
            }
        else
            for (let u = i - 1; u >= 0; u -= 1) {
                a[i] - a[u] < s && (l += 1)
            }
        return l
    }
    update() {
        const e = this;
        if (!e || e.destroyed)
            return;
        const {snapGrid: t, params: n} = e;
        function o() {
            const t = e.rtlTranslate ? -1 * e.translate : e.translate
              , n = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
            e.setTranslate(n),
            e.updateActiveIndex(),
            e.updateSlidesClasses()
        }
        let a;
        if (n.breakpoints && e.setBreakpoint(),
        [...e.el.querySelectorAll('[loading="lazy"]')].forEach(t => {
            t.complete && SS(e, t)
        }
        ),
        e.updateSize(),
        e.updateSlides(),
        e.updateProgress(),
        e.updateSlidesClasses(),
        n.freeMode && n.freeMode.enabled && !n.cssMode)
            o(),
            n.autoHeight && e.updateAutoHeight();
        else {
            if (("auto" === n.slidesPerView || n.slidesPerView > 1) && e.isEnd && !n.centeredSlides) {
                const t = e.virtual && n.virtual.enabled ? e.virtual.slides : e.slides;
                a = e.slideTo(t.length - 1, 0, !1, !0)
            } else
                a = e.slideTo(e.activeIndex, 0, !1, !0);
            a || o()
        }
        n.watchOverflow && t !== e.snapGrid && e.checkOverflow(),
        e.emit("update")
    }
    changeDirection(e, t) {
        void 0 === t && (t = !0);
        const n = this
          , o = n.params.direction;
        return e || (e = "horizontal" === o ? "vertical" : "horizontal"),
        e === o || "horizontal" !== e && "vertical" !== e || (n.el.classList.remove(`${n.params.containerModifierClass}${o}`),
        n.el.classList.add(`${n.params.containerModifierClass}${e}`),
        n.emitContainerClasses(),
        n.params.direction = e,
        n.slides.forEach(t => {
            "vertical" === e ? t.style.width = "" : t.style.height = ""
        }
        ),
        n.emit("changeDirection"),
        t && n.update()),
        n
    }
    changeLanguageDirection(e) {
        const t = this;
        t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e,
        t.rtlTranslate = "horizontal" === t.params.direction && t.rtl,
        t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`),
        t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`),
        t.el.dir = "ltr"),
        t.update())
    }
    mount(e) {
        const t = this;
        if (t.mounted)
            return !0;
        let n = e || t.params.el;
        if ("string" == typeof n && (n = document.querySelector(n)),
        !n)
            return !1;
        n.swiper = t,
        n.parentNode && n.parentNode.host && n.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
        const o = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
        let a = ( () => {
            if (n && n.shadowRoot && n.shadowRoot.querySelector) {
                return n.shadowRoot.querySelector(o())
            }
            return iS(n, o())[0]
        }
        )();
        return !a && t.params.createElements && (a = uS("div", t.params.wrapperClass),
        n.append(a),
        iS(n, `.${t.params.slideClass}`).forEach(e => {
            a.append(e)
        }
        )),
        Object.assign(t, {
            el: n,
            wrapperEl: a,
            slidesEl: t.isElement && !n.parentNode.host.slideSlots ? n.parentNode.host : a,
            hostEl: t.isElement ? n.parentNode.host : n,
            mounted: !0,
            rtl: "rtl" === n.dir.toLowerCase() || "rtl" === cS(n, "direction"),
            rtlTranslate: "horizontal" === t.params.direction && ("rtl" === n.dir.toLowerCase() || "rtl" === cS(n, "direction")),
            wrongRTL: "-webkit-box" === cS(a, "display")
        }),
        !0
    }
    init(e) {
        const t = this;
        if (t.initialized)
            return t;
        if (!1 === t.mount(e))
            return t;
        t.emit("beforeInit"),
        t.params.breakpoints && t.setBreakpoint(),
        t.addClasses(),
        t.updateSize(),
        t.updateSlides(),
        t.params.watchOverflow && t.checkOverflow(),
        t.params.grabCursor && t.enabled && t.setGrabCursor(),
        t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0),
        t.params.loop && t.loopCreate(void 0, !0),
        t.attachEvents();
        const n = [...t.el.querySelectorAll('[loading="lazy"]')];
        return t.isElement && n.push(...t.hostEl.querySelectorAll('[loading="lazy"]')),
        n.forEach(e => {
            e.complete ? SS(t, e) : e.addEventListener("load", e => {
                SS(t, e.target)
            }
            )
        }
        ),
        ES(t),
        t.initialized = !0,
        ES(t),
        t.emit("init"),
        t.emit("afterInit"),
        t
    }
    destroy(e, t) {
        void 0 === e && (e = !0),
        void 0 === t && (t = !0);
        const n = this
          , {params: o, el: a, wrapperEl: r, slides: s} = n;
        return void 0 === n.params || n.destroyed || (n.emit("beforeDestroy"),
        n.initialized = !1,
        n.detachEvents(),
        o.loop && n.loopDestroy(),
        t && (n.removeClasses(),
        a && "string" != typeof a && a.removeAttribute("style"),
        r && r.removeAttribute("style"),
        s && s.length && s.forEach(e => {
            e.classList.remove(o.slideVisibleClass, o.slideFullyVisibleClass, o.slideActiveClass, o.slideNextClass, o.slidePrevClass),
            e.removeAttribute("style"),
            e.removeAttribute("data-swiper-slide-index")
        }
        )),
        n.emit("destroy"),
        Object.keys(n.eventsListeners).forEach(e => {
            n.off(e)
        }
        ),
        !1 !== e && (n.el && "string" != typeof n.el && (n.el.swiper = null),
        function(e) {
            const t = e;
            Object.keys(t).forEach(e => {
                try {
                    t[e] = null
                } catch (pC) {}
                try {
                    delete t[e]
                } catch (pC) {}
            }
            )
        }(n)),
        n.destroyed = !0),
        null
    }
    static extendDefaults(e) {
        aS(US, e)
    }
    static get extendedDefaults() {
        return US
    }
    static get defaults() {
        return $S
    }
    static installModule(t) {
        e.prototype.__modules__ || (e.prototype.__modules__ = []);
        const n = e.prototype.__modules__;
        "function" == typeof t && n.indexOf(t) < 0 && n.push(t)
    }
    static use(t) {
        return Array.isArray(t) ? (t.forEach(t => e.installModule(t)),
        e) : (e.installModule(t),
        e)
    }
}
;
Object.keys(HS).forEach(e => {
    Object.keys(HS[e]).forEach(t => {
        ZS.prototype[t] = HS[e][t]
    }
    )
}
),
ZS.use([function(e) {
    let {swiper: t, on: n, emit: o} = e;
    const a = Jk();
    let r = null
      , s = null;
    const i = () => {
        t && !t.destroyed && t.initialized && (o("beforeResize"),
        o("resize"))
    }
      , l = () => {
        t && !t.destroyed && t.initialized && o("orientationchange")
    }
    ;
    n("init", () => {
        t.params.resizeObserver && void 0 !== a.ResizeObserver ? t && !t.destroyed && t.initialized && (r = new ResizeObserver(e => {
            s = a.requestAnimationFrame( () => {
                const {width: n, height: o} = t;
                let a = n
                  , r = o;
                e.forEach(e => {
                    let {contentBoxSize: n, contentRect: o, target: s} = e;
                    s && s !== t.el || (a = o ? o.width : (n[0] || n).inlineSize,
                    r = o ? o.height : (n[0] || n).blockSize)
                }
                ),
                a === n && r === o || i()
            }
            )
        }
        ),
        r.observe(t.el)) : (a.addEventListener("resize", i),
        a.addEventListener("orientationchange", l))
    }
    ),
    n("destroy", () => {
        s && a.cancelAnimationFrame(s),
        r && r.unobserve && t.el && (r.unobserve(t.el),
        r = null),
        a.removeEventListener("resize", i),
        a.removeEventListener("orientationchange", l)
    }
    )
}
, function(e) {
    let {swiper: t, extendParams: n, on: o, emit: a} = e;
    const r = []
      , s = Jk()
      , i = function(e, n) {
        void 0 === n && (n = {});
        const o = new (s.MutationObserver || s.WebkitMutationObserver)(e => {
            if (t.__preventObserver__)
                return;
            if (1 === e.length)
                return void a("observerUpdate", e[0]);
            const n = function() {
                a("observerUpdate", e[0])
            };
            s.requestAnimationFrame ? s.requestAnimationFrame(n) : s.setTimeout(n, 0)
        }
        );
        o.observe(e, {
            attributes: void 0 === n.attributes || n.attributes,
            childList: t.isElement || (void 0 === n.childList || n).childList,
            characterData: void 0 === n.characterData || n.characterData
        }),
        r.push(o)
    };
    n({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }),
    o("init", () => {
        if (t.params.observer) {
            if (t.params.observeParents) {
                const e = pS(t.hostEl);
                for (let t = 0; t < e.length; t += 1)
                    i(e[t])
            }
            i(t.hostEl, {
                childList: t.params.observeSlideChildren
            }),
            i(t.wrapperEl, {
                attributes: !1
            })
        }
    }
    ),
    o("destroy", () => {
        r.forEach(e => {
            e.disconnect()
        }
        ),
        r.splice(0, r.length)
    }
    )
}
]);
const qS = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "swiperElementNodeName", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "breakpointsBase", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopAdditionalSlides", "loopAddBlankSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideFullyVisibleClass", "slideNextClass", "slidePrevClass", "slideBlankClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"];
function WS(e) {
    return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) && !e.__swiper__
}
function GS(e, t) {
    const n = ["__proto__", "constructor", "prototype"];
    Object.keys(t).filter(e => n.indexOf(e) < 0).forEach(n => {
        void 0 === e[n] ? e[n] = t[n] : WS(t[n]) && WS(e[n]) && Object.keys(t[n]).length > 0 ? t[n].__swiper__ ? e[n] = t[n] : GS(e[n], t[n]) : e[n] = t[n]
    }
    )
}
function KS(e) {
    return void 0 === e && (e = {}),
    e.navigation && void 0 === e.navigation.nextEl && void 0 === e.navigation.prevEl
}
function YS(e) {
    return void 0 === e && (e = {}),
    e.pagination && void 0 === e.pagination.el
}
function XS(e) {
    return void 0 === e && (e = {}),
    e.scrollbar && void 0 === e.scrollbar.el
}
function JS(e) {
    void 0 === e && (e = "");
    const t = e.split(" ").map(e => e.trim()).filter(e => !!e)
      , n = [];
    return t.forEach(e => {
        n.indexOf(e) < 0 && n.push(e)
    }
    ),
    n.join(" ")
}
function QS(e, t) {
    void 0 === e && (e = {});
    const n = {
        on: {}
    }
      , o = {};
    GS(n, $S),
    n._emitClasses = !0,
    n.init = !1;
    const a = {}
      , r = qS.map(e => e.replace(/_/, ""))
      , s = Object.assign({}, e);
    return Object.keys(s).forEach(t => {
        void 0 !== e[t] && (r.indexOf(t) >= 0 ? WS(e[t]) ? (n[t] = {},
        o[t] = {},
        GS(n[t], e[t]),
        GS(o[t], e[t])) : (n[t] = e[t],
        o[t] = e[t]) : 0 === t.search(/on[A-Z]/) && "function" == typeof e[t] ? n.on[`${t[2].toLowerCase()}${t.substr(3)}`] = e[t] : a[t] = e[t])
    }
    ),
    ["navigation", "pagination", "scrollbar"].forEach(e => {
        !0 === n[e] && (n[e] = {}),
        !1 === n[e] && delete n[e]
    }
    ),
    {
        params: n,
        passedParams: o,
        rest: a,
        events: {}
    }
}
function eC(e, t, n) {
    void 0 === e && (e = {});
    const o = []
      , a = {
        "container-start": [],
        "container-end": [],
        "wrapper-start": [],
        "wrapper-end": []
    }
      , r = (e, t) => {
        Array.isArray(e) && e.forEach(e => {
            const n = "symbol" == typeof e.type;
            "default" === t && (t = "container-end"),
            n && e.children ? r(e.children, t) : e.type && ("SwiperSlide" === e.type.name || "AsyncComponentWrapper" === e.type.name) || e.componentOptions && "SwiperSlide" === e.componentOptions.tag ? o.push(e) : a[t] && a[t].push(e)
        }
        )
    }
    ;
    return Object.keys(e).forEach(t => {
        if ("function" != typeof e[t])
            return;
        const n = e[t]();
        r(n, t)
    }
    ),
    n.value = t.value,
    t.value = o,
    {
        slides: o,
        slots: a
    }
}
const tC = {
    name: "Swiper",
    props: {
        tag: {
            type: String,
            default: "div"
        },
        wrapperTag: {
            type: String,
            default: "div"
        },
        modules: {
            type: Array,
            default: void 0
        },
        init: {
            type: Boolean,
            default: void 0
        },
        direction: {
            type: String,
            default: void 0
        },
        oneWayMovement: {
            type: Boolean,
            default: void 0
        },
        swiperElementNodeName: {
            type: String,
            default: "SWIPER-CONTAINER"
        },
        touchEventsTarget: {
            type: String,
            default: void 0
        },
        initialSlide: {
            type: Number,
            default: void 0
        },
        speed: {
            type: Number,
            default: void 0
        },
        cssMode: {
            type: Boolean,
            default: void 0
        },
        updateOnWindowResize: {
            type: Boolean,
            default: void 0
        },
        resizeObserver: {
            type: Boolean,
            default: void 0
        },
        nested: {
            type: Boolean,
            default: void 0
        },
        focusableElements: {
            type: String,
            default: void 0
        },
        width: {
            type: Number,
            default: void 0
        },
        height: {
            type: Number,
            default: void 0
        },
        preventInteractionOnTransition: {
            type: Boolean,
            default: void 0
        },
        userAgent: {
            type: String,
            default: void 0
        },
        url: {
            type: String,
            default: void 0
        },
        edgeSwipeDetection: {
            type: [Boolean, String],
            default: void 0
        },
        edgeSwipeThreshold: {
            type: Number,
            default: void 0
        },
        autoHeight: {
            type: Boolean,
            default: void 0
        },
        setWrapperSize: {
            type: Boolean,
            default: void 0
        },
        virtualTranslate: {
            type: Boolean,
            default: void 0
        },
        effect: {
            type: String,
            default: void 0
        },
        breakpoints: {
            type: Object,
            default: void 0
        },
        breakpointsBase: {
            type: String,
            default: void 0
        },
        spaceBetween: {
            type: [Number, String],
            default: void 0
        },
        slidesPerView: {
            type: [Number, String],
            default: void 0
        },
        maxBackfaceHiddenSlides: {
            type: Number,
            default: void 0
        },
        slidesPerGroup: {
            type: Number,
            default: void 0
        },
        slidesPerGroupSkip: {
            type: Number,
            default: void 0
        },
        slidesPerGroupAuto: {
            type: Boolean,
            default: void 0
        },
        centeredSlides: {
            type: Boolean,
            default: void 0
        },
        centeredSlidesBounds: {
            type: Boolean,
            default: void 0
        },
        slidesOffsetBefore: {
            type: Number,
            default: void 0
        },
        slidesOffsetAfter: {
            type: Number,
            default: void 0
        },
        normalizeSlideIndex: {
            type: Boolean,
            default: void 0
        },
        centerInsufficientSlides: {
            type: Boolean,
            default: void 0
        },
        watchOverflow: {
            type: Boolean,
            default: void 0
        },
        roundLengths: {
            type: Boolean,
            default: void 0
        },
        touchRatio: {
            type: Number,
            default: void 0
        },
        touchAngle: {
            type: Number,
            default: void 0
        },
        simulateTouch: {
            type: Boolean,
            default: void 0
        },
        shortSwipes: {
            type: Boolean,
            default: void 0
        },
        longSwipes: {
            type: Boolean,
            default: void 0
        },
        longSwipesRatio: {
            type: Number,
            default: void 0
        },
        longSwipesMs: {
            type: Number,
            default: void 0
        },
        followFinger: {
            type: Boolean,
            default: void 0
        },
        allowTouchMove: {
            type: Boolean,
            default: void 0
        },
        threshold: {
            type: Number,
            default: void 0
        },
        touchMoveStopPropagation: {
            type: Boolean,
            default: void 0
        },
        touchStartPreventDefault: {
            type: Boolean,
            default: void 0
        },
        touchStartForcePreventDefault: {
            type: Boolean,
            default: void 0
        },
        touchReleaseOnEdges: {
            type: Boolean,
            default: void 0
        },
        uniqueNavElements: {
            type: Boolean,
            default: void 0
        },
        resistance: {
            type: Boolean,
            default: void 0
        },
        resistanceRatio: {
            type: Number,
            default: void 0
        },
        watchSlidesProgress: {
            type: Boolean,
            default: void 0
        },
        grabCursor: {
            type: Boolean,
            default: void 0
        },
        preventClicks: {
            type: Boolean,
            default: void 0
        },
        preventClicksPropagation: {
            type: Boolean,
            default: void 0
        },
        slideToClickedSlide: {
            type: Boolean,
            default: void 0
        },
        loop: {
            type: Boolean,
            default: void 0
        },
        loopedSlides: {
            type: Number,
            default: void 0
        },
        loopPreventsSliding: {
            type: Boolean,
            default: void 0
        },
        loopAdditionalSlides: {
            type: Number,
            default: void 0
        },
        loopAddBlankSlides: {
            type: Boolean,
            default: void 0
        },
        rewind: {
            type: Boolean,
            default: void 0
        },
        allowSlidePrev: {
            type: Boolean,
            default: void 0
        },
        allowSlideNext: {
            type: Boolean,
            default: void 0
        },
        swipeHandler: {
            type: Boolean,
            default: void 0
        },
        noSwiping: {
            type: Boolean,
            default: void 0
        },
        noSwipingClass: {
            type: String,
            default: void 0
        },
        noSwipingSelector: {
            type: String,
            default: void 0
        },
        passiveListeners: {
            type: Boolean,
            default: void 0
        },
        containerModifierClass: {
            type: String,
            default: void 0
        },
        slideClass: {
            type: String,
            default: void 0
        },
        slideActiveClass: {
            type: String,
            default: void 0
        },
        slideVisibleClass: {
            type: String,
            default: void 0
        },
        slideFullyVisibleClass: {
            type: String,
            default: void 0
        },
        slideBlankClass: {
            type: String,
            default: void 0
        },
        slideNextClass: {
            type: String,
            default: void 0
        },
        slidePrevClass: {
            type: String,
            default: void 0
        },
        wrapperClass: {
            type: String,
            default: void 0
        },
        lazyPreloaderClass: {
            type: String,
            default: void 0
        },
        lazyPreloadPrevNext: {
            type: Number,
            default: void 0
        },
        runCallbacksOnInit: {
            type: Boolean,
            default: void 0
        },
        observer: {
            type: Boolean,
            default: void 0
        },
        observeParents: {
            type: Boolean,
            default: void 0
        },
        observeSlideChildren: {
            type: Boolean,
            default: void 0
        },
        a11y: {
            type: [Boolean, Object],
            default: void 0
        },
        autoplay: {
            type: [Boolean, Object],
            default: void 0
        },
        controller: {
            type: Object,
            default: void 0
        },
        coverflowEffect: {
            type: Object,
            default: void 0
        },
        cubeEffect: {
            type: Object,
            default: void 0
        },
        fadeEffect: {
            type: Object,
            default: void 0
        },
        flipEffect: {
            type: Object,
            default: void 0
        },
        creativeEffect: {
            type: Object,
            default: void 0
        },
        cardsEffect: {
            type: Object,
            default: void 0
        },
        hashNavigation: {
            type: [Boolean, Object],
            default: void 0
        },
        history: {
            type: [Boolean, Object],
            default: void 0
        },
        keyboard: {
            type: [Boolean, Object],
            default: void 0
        },
        mousewheel: {
            type: [Boolean, Object],
            default: void 0
        },
        navigation: {
            type: [Boolean, Object],
            default: void 0
        },
        pagination: {
            type: [Boolean, Object],
            default: void 0
        },
        parallax: {
            type: [Boolean, Object],
            default: void 0
        },
        scrollbar: {
            type: [Boolean, Object],
            default: void 0
        },
        thumbs: {
            type: Object,
            default: void 0
        },
        virtual: {
            type: [Boolean, Object],
            default: void 0
        },
        zoom: {
            type: [Boolean, Object],
            default: void 0
        },
        grid: {
            type: [Object],
            default: void 0
        },
        freeMode: {
            type: [Boolean, Object],
            default: void 0
        },
        enabled: {
            type: Boolean,
            default: void 0
        }
    },
    emits: ["_beforeBreakpoint", "_containerClasses", "_slideClass", "_slideClasses", "_swiper", "_freeModeNoMomentumRelease", "_virtualUpdated", "activeIndexChange", "afterInit", "autoplay", "autoplayStart", "autoplayStop", "autoplayPause", "autoplayResume", "autoplayTimeLeft", "beforeDestroy", "beforeInit", "beforeLoopFix", "beforeResize", "beforeSlideChangeStart", "beforeTransitionStart", "breakpoint", "changeDirection", "click", "disable", "doubleTap", "doubleClick", "destroy", "enable", "fromEdge", "hashChange", "hashSet", "init", "keyPress", "lock", "loopFix", "momentumBounce", "navigationHide", "navigationShow", "navigationPrev", "navigationNext", "observerUpdate", "orientationchange", "paginationHide", "paginationRender", "paginationShow", "paginationUpdate", "progress", "reachBeginning", "reachEnd", "realIndexChange", "resize", "scroll", "scrollbarDragEnd", "scrollbarDragMove", "scrollbarDragStart", "setTransition", "setTranslate", "slidesUpdated", "slideChange", "slideChangeTransitionEnd", "slideChangeTransitionStart", "slideNextTransitionEnd", "slideNextTransitionStart", "slidePrevTransitionEnd", "slidePrevTransitionStart", "slideResetTransitionStart", "slideResetTransitionEnd", "sliderMove", "sliderFirstMove", "slidesLengthChange", "slidesGridLengthChange", "snapGridLengthChange", "snapIndexChange", "swiper", "tap", "toEdge", "touchEnd", "touchMove", "touchMoveOpposite", "touchStart", "transitionEnd", "transitionStart", "unlock", "update", "virtualUpdate", "zoomChange"],
    setup(e, t) {
        let {slots: n, emit: o} = t;
        const {tag: a, wrapperTag: r} = e
          , s = It("swiper")
          , i = It(null)
          , l = It(!1)
          , u = It(!1)
          , c = It(null)
          , d = It(null)
          , p = It(null)
          , f = {
            value: []
        }
          , h = {
            value: []
        }
          , v = It(null)
          , m = It(null)
          , g = It(null)
          , y = It(null)
          , {params: b, passedParams: w} = QS(e);
        eC(n, f, h),
        p.value = w,
        h.value = f.value;
        b.onAny = function(e) {
            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
                n[a - 1] = arguments[a];
            o(e, ...n)
        }
        ,
        Object.assign(b.on, {
            _beforeBreakpoint: () => {
                eC(n, f, h),
                l.value = !0
            }
            ,
            _containerClasses(e, t) {
                s.value = t
            }
        });
        const _ = {
            ...b
        };
        if (delete _.wrapperClass,
        d.value = new ZS(_),
        d.value.virtual && d.value.params.virtual.enabled) {
            d.value.virtual.slides = f.value;
            const e = {
                cache: !1,
                slides: f.value,
                renderExternal: e => {
                    i.value = e
                }
                ,
                renderExternalUpdate: !1
            };
            GS(d.value.params.virtual, e),
            GS(d.value.originalParams.virtual, e)
        }
        function x(e) {
            return b.virtual ? function(e, t, n) {
                if (!n)
                    return null;
                const o = e => {
                    let n = e;
                    return e < 0 ? n = t.length + e : n >= t.length && (n -= t.length),
                    n
                }
                  , a = e.value.isHorizontal() ? {
                    [e.value.rtlTranslate ? "right" : "left"]: `${n.offset}px`
                } : {
                    top: `${n.offset}px`
                }
                  , {from: r, to: s} = n
                  , i = e.value.params.loop ? -t.length : 0
                  , l = e.value.params.loop ? 2 * t.length : t.length
                  , u = [];
                for (let c = i; c < l; c += 1)
                    c >= r && c <= s && u.length < t.length && u.push(t[o(c)]);
                return u.map(t => (t.props || (t.props = {}),
                t.props.style || (t.props.style = {}),
                t.props.swiperRef = e,
                t.props.style = a,
                t.type ? gs(t.type, {
                    ...t.props
                }, t.children) : t.componentOptions ? gs(t.componentOptions.Ctor, {
                    ...t.props
                }, t.componentOptions.children) : void 0))
            }(d, e, i.value) : (e.forEach( (e, t) => {
                e.props || (e.props = {}),
                e.props.swiperRef = d,
                e.props.swiperSlideIndex = t
            }
            ),
            e)
        }
        return Bo( () => {
            !u.value && d.value && (d.value.emitSlidesClasses(),
            u.value = !0);
            const {passedParams: t} = QS(e)
              , n = function(e, t, n, o, a) {
                const r = [];
                if (!t)
                    return r;
                const s = e => {
                    r.indexOf(e) < 0 && r.push(e)
                }
                ;
                if (n && o) {
                    const e = o.map(a)
                      , t = n.map(a);
                    e.join("") !== t.join("") && s("children"),
                    o.length !== n.length && s("children")
                }
                return qS.filter(e => "_" === e[0]).map(e => e.replace(/_/, "")).forEach(n => {
                    if (n in e && n in t)
                        if (WS(e[n]) && WS(t[n])) {
                            const o = Object.keys(e[n])
                              , a = Object.keys(t[n]);
                            o.length !== a.length ? s(n) : (o.forEach(o => {
                                e[n][o] !== t[n][o] && s(n)
                            }
                            ),
                            a.forEach(o => {
                                e[n][o] !== t[n][o] && s(n)
                            }
                            ))
                        } else
                            e[n] !== t[n] && s(n)
                }
                ),
                r
            }(t, p.value, f.value, h.value, e => e.props && e.props.key);
            p.value = t,
            (n.length || l.value) && d.value && !d.value.destroyed && function(e) {
                let {swiper: t, slides: n, passedParams: o, changedParams: a, nextEl: r, prevEl: s, scrollbarEl: i, paginationEl: l} = e;
                const u = a.filter(e => "children" !== e && "direction" !== e && "wrapperClass" !== e)
                  , {params: c, pagination: d, navigation: p, scrollbar: f, virtual: h, thumbs: v} = t;
                let m, g, y, b, w, _, x, k;
                a.includes("thumbs") && o.thumbs && o.thumbs.swiper && !o.thumbs.swiper.destroyed && c.thumbs && (!c.thumbs.swiper || c.thumbs.swiper.destroyed) && (m = !0),
                a.includes("controller") && o.controller && o.controller.control && c.controller && !c.controller.control && (g = !0),
                a.includes("pagination") && o.pagination && (o.pagination.el || l) && (c.pagination || !1 === c.pagination) && d && !d.el && (y = !0),
                a.includes("scrollbar") && o.scrollbar && (o.scrollbar.el || i) && (c.scrollbar || !1 === c.scrollbar) && f && !f.el && (b = !0),
                a.includes("navigation") && o.navigation && (o.navigation.prevEl || s) && (o.navigation.nextEl || r) && (c.navigation || !1 === c.navigation) && p && !p.prevEl && !p.nextEl && (w = !0);
                const S = e => {
                    t[e] && (t[e].destroy(),
                    "navigation" === e ? (t.isElement && (t[e].prevEl.remove(),
                    t[e].nextEl.remove()),
                    c[e].prevEl = void 0,
                    c[e].nextEl = void 0,
                    t[e].prevEl = void 0,
                    t[e].nextEl = void 0) : (t.isElement && t[e].el.remove(),
                    c[e].el = void 0,
                    t[e].el = void 0))
                }
                ;
                a.includes("loop") && t.isElement && (c.loop && !o.loop ? _ = !0 : !c.loop && o.loop ? x = !0 : k = !0),
                u.forEach(e => {
                    if (WS(c[e]) && WS(o[e]))
                        Object.assign(c[e], o[e]),
                        "navigation" !== e && "pagination" !== e && "scrollbar" !== e || !("enabled"in o[e]) || o[e].enabled || S(e);
                    else {
                        const t = o[e];
                        !0 !== t && !1 !== t || "navigation" !== e && "pagination" !== e && "scrollbar" !== e ? c[e] = o[e] : !1 === t && S(e)
                    }
                }
                ),
                u.includes("controller") && !g && t.controller && t.controller.control && c.controller && c.controller.control && (t.controller.control = c.controller.control),
                a.includes("children") && n && h && c.virtual.enabled ? (h.slides = n,
                h.update(!0)) : a.includes("virtual") && h && c.virtual.enabled && (n && (h.slides = n),
                h.update(!0)),
                a.includes("children") && n && c.loop && (k = !0),
                m && v.init() && v.update(!0);
                g && (t.controller.control = c.controller.control),
                y && (!t.isElement || l && "string" != typeof l || (l = document.createElement("div"),
                l.classList.add("swiper-pagination"),
                l.part.add("pagination"),
                t.el.appendChild(l)),
                l && (c.pagination.el = l),
                d.init(),
                d.render(),
                d.update()),
                b && (!t.isElement || i && "string" != typeof i || (i = document.createElement("div"),
                i.classList.add("swiper-scrollbar"),
                i.part.add("scrollbar"),
                t.el.appendChild(i)),
                i && (c.scrollbar.el = i),
                f.init(),
                f.updateSize(),
                f.setTranslate()),
                w && (t.isElement && (r && "string" != typeof r || (r = document.createElement("div"),
                r.classList.add("swiper-button-next"),
                vS(r, t.hostEl.constructor.nextButtonSvg),
                r.part.add("button-next"),
                t.el.appendChild(r)),
                s && "string" != typeof s || (s = document.createElement("div"),
                s.classList.add("swiper-button-prev"),
                vS(s, t.hostEl.constructor.prevButtonSvg),
                s.part.add("button-prev"),
                t.el.appendChild(s))),
                r && (c.navigation.nextEl = r),
                s && (c.navigation.prevEl = s),
                p.init(),
                p.update()),
                a.includes("allowSlideNext") && (t.allowSlideNext = o.allowSlideNext),
                a.includes("allowSlidePrev") && (t.allowSlidePrev = o.allowSlidePrev),
                a.includes("direction") && t.changeDirection(o.direction, !1),
                (_ || k) && t.loopDestroy(),
                (x || k) && t.loopCreate(),
                t.update()
            }({
                swiper: d.value,
                slides: f.value,
                passedParams: t,
                changedParams: n,
                nextEl: v.value,
                prevEl: m.value,
                scrollbarEl: y.value,
                paginationEl: g.value
            }),
            l.value = !1
        }
        ),
        _a("swiper", d),
        Qa(i, () => {
            fn( () => {
                var e;
                !(e = d.value) || e.destroyed || !e.params.virtual || e.params.virtual && !e.params.virtual.enabled || (e.updateSlides(),
                e.updateProgress(),
                e.updateSlidesClasses(),
                e.emit("_virtualUpdated"),
                e.parallax && e.params.parallax && e.params.parallax.enabled && e.parallax.setTranslate())
            }
            )
        }
        ),
        Mo( () => {
            c.value && (!function(e, t) {
                let {el: n, nextEl: o, prevEl: a, paginationEl: r, scrollbarEl: s, swiper: i} = e;
                KS(t) && o && a && (i.params.navigation.nextEl = o,
                i.originalParams.navigation.nextEl = o,
                i.params.navigation.prevEl = a,
                i.originalParams.navigation.prevEl = a),
                YS(t) && r && (i.params.pagination.el = r,
                i.originalParams.pagination.el = r),
                XS(t) && s && (i.params.scrollbar.el = s,
                i.originalParams.scrollbar.el = s),
                i.init(n)
            }({
                el: c.value,
                nextEl: v.value,
                prevEl: m.value,
                paginationEl: g.value,
                scrollbarEl: y.value,
                swiper: d.value
            }, b),
            o("swiper", d.value))
        }
        ),
        Io( () => {
            d.value && !d.value.destroyed && d.value.destroy(!0, !1)
        }
        ),
        () => {
            const {slides: t, slots: o} = eC(n, f, h);
            return gs(a, {
                ref: c,
                class: JS(s.value)
            }, [o["container-start"], gs(r, {
                class: (i = b.wrapperClass,
                void 0 === i && (i = ""),
                i ? i.includes("swiper-wrapper") ? i : `swiper-wrapper ${i}` : "swiper-wrapper")
            }, [o["wrapper-start"], x(t), o["wrapper-end"]]), KS(e) && [gs("div", {
                ref: m,
                class: "swiper-button-prev"
            }), gs("div", {
                ref: v,
                class: "swiper-button-next"
            })], XS(e) && gs("div", {
                ref: y,
                class: "swiper-scrollbar"
            }), YS(e) && gs("div", {
                ref: g,
                class: "swiper-pagination"
            }), o["container-end"]]);
            var i
        }
    }
}
  , nC = {
    name: "SwiperSlide",
    props: {
        tag: {
            type: String,
            default: "div"
        },
        swiperRef: {
            type: Object,
            required: !1
        },
        swiperSlideIndex: {
            type: Number,
            default: void 0,
            required: !1
        },
        zoom: {
            type: Boolean,
            default: void 0,
            required: !1
        },
        lazy: {
            type: Boolean,
            default: !1,
            required: !1
        },
        virtualIndex: {
            type: [String, Number],
            default: void 0
        }
    },
    setup(e, t) {
        let {slots: n} = t
          , o = !1;
        const {swiperRef: a} = e
          , r = It(null)
          , s = It("swiper-slide")
          , i = It(!1);
        function l(e, t, n) {
            t === r.value && (s.value = n)
        }
        Mo( () => {
            a && a.value && (a.value.on("_slideClass", l),
            o = !0)
        }
        ),
        Po( () => {
            !o && a && a.value && (a.value.on("_slideClass", l),
            o = !0)
        }
        ),
        Bo( () => {
            r.value && a && a.value && (void 0 !== e.swiperSlideIndex && (r.value.swiperSlideIndex = e.swiperSlideIndex),
            a.value.destroyed && "swiper-slide" !== s.value && (s.value = "swiper-slide"))
        }
        ),
        Io( () => {
            a && a.value && a.value.off("_slideClass", l)
        }
        );
        const u = ms( () => ({
            isActive: s.value.indexOf("swiper-slide-active") >= 0,
            isVisible: s.value.indexOf("swiper-slide-visible") >= 0,
            isPrev: s.value.indexOf("swiper-slide-prev") >= 0,
            isNext: s.value.indexOf("swiper-slide-next") >= 0
        }));
        _a("swiperSlide", u);
        const c = () => {
            i.value = !0
        }
        ;
        return () => gs(e.tag, {
            class: JS(`${s.value}`),
            ref: r,
            "data-swiper-slide-index": void 0 === e.virtualIndex && a && a.value && a.value.params.loop ? e.swiperSlideIndex : e.virtualIndex,
            onLoadCapture: c
        }, e.zoom ? gs("div", {
            class: "swiper-zoom-container",
            "data-swiper-zoom": "number" == typeof e.zoom ? e.zoom : void 0
        }, [n.default && n.default(u.value), e.lazy && !i.value && gs("div", {
            class: "swiper-lazy-preloader"
        })]) : [n.default && n.default(u.value), e.lazy && !i.value && gs("div", {
            class: "swiper-lazy-preloader"
        })])
    }
};
function oC(e) {
    let {swiper: t, extendParams: n, on: o, emit: a} = e;
    const r = Jk();
    let s;
    n({
        mousewheel: {
            enabled: !1,
            releaseOnEdges: !1,
            invert: !1,
            forceToAxis: !1,
            sensitivity: 1,
            eventsTarget: "container",
            thresholdDelta: null,
            thresholdTime: null,
            noMousewheelClass: "swiper-no-mousewheel"
        }
    }),
    t.mousewheel = {
        enabled: !1
    };
    let i, l = eS();
    const u = [];
    function c() {
        t.enabled && (t.mouseEntered = !0)
    }
    function d() {
        t.enabled && (t.mouseEntered = !1)
    }
    function p(e) {
        return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta) && (!(t.params.mousewheel.thresholdTime && eS() - l < t.params.mousewheel.thresholdTime) && (e.delta >= 6 && eS() - l < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(),
        a("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(),
        a("scroll", e.raw)),
        l = (new r.Date).getTime(),
        !1)))
    }
    function f(e) {
        let n = e
          , o = !0;
        if (!t.enabled)
            return;
        if (e.target.closest(`.${t.params.mousewheel.noMousewheelClass}`))
            return;
        const r = t.params.mousewheel;
        t.params.cssMode && n.preventDefault();
        let l = t.el;
        "container" !== t.params.mousewheel.eventsTarget && (l = document.querySelector(t.params.mousewheel.eventsTarget));
        const c = l && l.contains(n.target);
        if (!t.mouseEntered && !c && !r.releaseOnEdges)
            return !0;
        n.originalEvent && (n = n.originalEvent);
        let d = 0;
        const f = t.rtlTranslate ? -1 : 1
          , h = function(e) {
            let t = 0
              , n = 0
              , o = 0
              , a = 0;
            return "detail"in e && (n = e.detail),
            "wheelDelta"in e && (n = -e.wheelDelta / 120),
            "wheelDeltaY"in e && (n = -e.wheelDeltaY / 120),
            "wheelDeltaX"in e && (t = -e.wheelDeltaX / 120),
            "axis"in e && e.axis === e.HORIZONTAL_AXIS && (t = n,
            n = 0),
            o = 10 * t,
            a = 10 * n,
            "deltaY"in e && (a = e.deltaY),
            "deltaX"in e && (o = e.deltaX),
            e.shiftKey && !o && (o = a,
            a = 0),
            (o || a) && e.deltaMode && (1 === e.deltaMode ? (o *= 40,
            a *= 40) : (o *= 800,
            a *= 800)),
            o && !t && (t = o < 1 ? -1 : 1),
            a && !n && (n = a < 1 ? -1 : 1),
            {
                spinX: t,
                spinY: n,
                pixelX: o,
                pixelY: a
            }
        }(n);
        if (r.forceToAxis)
            if (t.isHorizontal()) {
                if (!(Math.abs(h.pixelX) > Math.abs(h.pixelY)))
                    return !0;
                d = -h.pixelX * f
            } else {
                if (!(Math.abs(h.pixelY) > Math.abs(h.pixelX)))
                    return !0;
                d = -h.pixelY
            }
        else
            d = Math.abs(h.pixelX) > Math.abs(h.pixelY) ? -h.pixelX * f : -h.pixelY;
        if (0 === d)
            return !0;
        r.invert && (d = -d);
        let v = t.getTranslate() + d * r.sensitivity;
        if (v >= t.minTranslate() && (v = t.minTranslate()),
        v <= t.maxTranslate() && (v = t.maxTranslate()),
        o = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()),
        o && t.params.nested && n.stopPropagation(),
        t.params.freeMode && t.params.freeMode.enabled) {
            const e = {
                time: eS(),
                delta: Math.abs(d),
                direction: Math.sign(d)
            }
              , o = i && e.time < i.time + 500 && e.delta <= i.delta && e.direction === i.direction;
            if (!o) {
                i = void 0;
                let l = t.getTranslate() + d * r.sensitivity;
                const c = t.isBeginning
                  , p = t.isEnd;
                if (l >= t.minTranslate() && (l = t.minTranslate()),
                l <= t.maxTranslate() && (l = t.maxTranslate()),
                t.setTransition(0),
                t.setTranslate(l),
                t.updateProgress(),
                t.updateActiveIndex(),
                t.updateSlidesClasses(),
                (!c && t.isBeginning || !p && t.isEnd) && t.updateSlidesClasses(),
                t.params.loop && t.loopFix({
                    direction: e.direction < 0 ? "next" : "prev",
                    byMousewheel: !0
                }),
                t.params.freeMode.sticky) {
                    clearTimeout(s),
                    s = void 0,
                    u.length >= 15 && u.shift();
                    const n = u.length ? u[u.length - 1] : void 0
                      , o = u[0];
                    if (u.push(e),
                    n && (e.delta > n.delta || e.direction !== n.direction))
                        u.splice(0);
                    else if (u.length >= 15 && e.time - o.time < 500 && o.delta - e.delta >= 1 && e.delta <= 6) {
                        const n = d > 0 ? .8 : .2;
                        i = e,
                        u.splice(0),
                        s = Qk( () => {
                            !t.destroyed && t.params && t.slideToClosest(t.params.speed, !0, void 0, n)
                        }
                        , 0)
                    }
                    s || (s = Qk( () => {
                        if (t.destroyed || !t.params)
                            return;
                        i = e,
                        u.splice(0),
                        t.slideToClosest(t.params.speed, !0, void 0, .5)
                    }
                    , 500))
                }
                if (o || a("scroll", n),
                t.params.autoplay && t.params.autoplay.disableOnInteraction && t.autoplay.stop(),
                r.releaseOnEdges && (l === t.minTranslate() || l === t.maxTranslate()))
                    return !0
            }
        } else {
            const n = {
                time: eS(),
                delta: Math.abs(d),
                direction: Math.sign(d),
                raw: e
            };
            u.length >= 2 && u.shift();
            const o = u.length ? u[u.length - 1] : void 0;
            if (u.push(n),
            o ? (n.direction !== o.direction || n.delta > o.delta || n.time > o.time + 150) && p(n) : p(n),
            function(e) {
                const n = t.params.mousewheel;
                if (e.direction < 0) {
                    if (t.isEnd && !t.params.loop && n.releaseOnEdges)
                        return !0
                } else if (t.isBeginning && !t.params.loop && n.releaseOnEdges)
                    return !0;
                return !1
            }(n))
                return !0
        }
        return n.preventDefault ? n.preventDefault() : n.returnValue = !1,
        !1
    }
    function h(e) {
        let n = t.el;
        "container" !== t.params.mousewheel.eventsTarget && (n = document.querySelector(t.params.mousewheel.eventsTarget)),
        n[e]("mouseenter", c),
        n[e]("mouseleave", d),
        n[e]("wheel", f)
    }
    function v() {
        return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", f),
        !0) : !t.mousewheel.enabled && (h("addEventListener"),
        t.mousewheel.enabled = !0,
        !0)
    }
    function m() {
        return t.params.cssMode ? (t.wrapperEl.addEventListener(event, f),
        !0) : !!t.mousewheel.enabled && (h("removeEventListener"),
        t.mousewheel.enabled = !1,
        !0)
    }
    o("init", () => {
        !t.params.mousewheel.enabled && t.params.cssMode && m(),
        t.params.mousewheel.enabled && v()
    }
    ),
    o("destroy", () => {
        t.params.cssMode && v(),
        t.mousewheel.enabled && m()
    }
    ),
    Object.assign(t.mousewheel, {
        enable: v,
        disable: m
    })
}
function aC(e, t, n, o) {
    return e.params.createElements && Object.keys(o).forEach(a => {
        if (!n[a] && !0 === n.auto) {
            let r = iS(e.el, `.${o[a]}`)[0];
            r || (r = uS("div", o[a]),
            r.className = o[a],
            e.el.append(r)),
            n[a] = r,
            t[a] = r
        }
    }
    ),
    n
}
function rC(e) {
    let {swiper: t, extendParams: n, on: o, emit: a} = e;
    function r(e) {
        let n;
        return e && "string" == typeof e && t.isElement && (n = t.el.querySelector(e) || t.hostEl.querySelector(e),
        n) ? n : (e && ("string" == typeof e && (n = [...document.querySelectorAll(e)]),
        t.params.uniqueNavElements && "string" == typeof e && n && n.length > 1 && 1 === t.el.querySelectorAll(e).length ? n = t.el.querySelector(e) : n && 1 === n.length && (n = n[0])),
        e && !n ? e : n)
    }
    function s(e, n) {
        const o = t.params.navigation;
        (e = hS(e)).forEach(e => {
            e && (e.classList[n ? "add" : "remove"](...o.disabledClass.split(" ")),
            "BUTTON" === e.tagName && (e.disabled = n),
            t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](o.lockClass))
        }
        )
    }
    function i() {
        const {nextEl: e, prevEl: n} = t.navigation;
        if (t.params.loop)
            return s(n, !1),
            void s(e, !1);
        s(n, t.isBeginning && !t.params.rewind),
        s(e, t.isEnd && !t.params.rewind)
    }
    function l(e) {
        e.preventDefault(),
        (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(),
        a("navigationPrev"))
    }
    function u(e) {
        e.preventDefault(),
        (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(),
        a("navigationNext"))
    }
    function c() {
        const e = t.params.navigation;
        if (t.params.navigation = aC(t, t.originalParams.navigation, t.params.navigation, {
            nextEl: "swiper-button-next",
            prevEl: "swiper-button-prev"
        }),
        !e.nextEl && !e.prevEl)
            return;
        let n = r(e.nextEl)
          , o = r(e.prevEl);
        Object.assign(t.navigation, {
            nextEl: n,
            prevEl: o
        }),
        n = hS(n),
        o = hS(o);
        const a = (n, o) => {
            n && n.addEventListener("click", "next" === o ? u : l),
            !t.enabled && n && n.classList.add(...e.lockClass.split(" "))
        }
        ;
        n.forEach(e => a(e, "next")),
        o.forEach(e => a(e, "prev"))
    }
    function d() {
        let {nextEl: e, prevEl: n} = t.navigation;
        e = hS(e),
        n = hS(n);
        const o = (e, n) => {
            e.removeEventListener("click", "next" === n ? u : l),
            e.classList.remove(...t.params.navigation.disabledClass.split(" "))
        }
        ;
        e.forEach(e => o(e, "next")),
        n.forEach(e => o(e, "prev"))
    }
    n({
        navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: !1,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock",
            navigationDisabledClass: "swiper-navigation-disabled"
        }
    }),
    t.navigation = {
        nextEl: null,
        prevEl: null
    },
    o("init", () => {
        !1 === t.params.navigation.enabled ? p() : (c(),
        i())
    }
    ),
    o("toEdge fromEdge lock unlock", () => {
        i()
    }
    ),
    o("destroy", () => {
        d()
    }
    ),
    o("enable disable", () => {
        let {nextEl: e, prevEl: n} = t.navigation;
        e = hS(e),
        n = hS(n),
        t.enabled ? i() : [...e, ...n].filter(e => !!e).forEach(e => e.classList.add(t.params.navigation.lockClass))
    }
    ),
    o("click", (e, n) => {
        let {nextEl: o, prevEl: r} = t.navigation;
        o = hS(o),
        r = hS(r);
        const s = n.target;
        let i = r.includes(s) || o.includes(s);
        if (t.isElement && !i) {
            const e = n.path || n.composedPath && n.composedPath();
            e && (i = e.find(e => o.includes(e) || r.includes(e)))
        }
        if (t.params.navigation.hideOnClick && !i) {
            if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === s || t.pagination.el.contains(s)))
                return;
            let e;
            o.length ? e = o[0].classList.contains(t.params.navigation.hiddenClass) : r.length && (e = r[0].classList.contains(t.params.navigation.hiddenClass)),
            a(!0 === e ? "navigationShow" : "navigationHide"),
            [...o, ...r].filter(e => !!e).forEach(e => e.classList.toggle(t.params.navigation.hiddenClass))
        }
    }
    );
    const p = () => {
        t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")),
        d()
    }
    ;
    Object.assign(t.navigation, {
        enable: () => {
            t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")),
            c(),
            i()
        }
        ,
        disable: p,
        update: i,
        init: c,
        destroy: d
    })
}
function sC(e) {
    return void 0 === e && (e = ""),
    `.${e.trim().replace(/([\.:!+\/()[\]])/g, "\\$1").replace(/ /g, ".")}`
}
function iC(e) {
    let {swiper: t, extendParams: n, on: o, emit: a} = e;
    const r = "swiper-pagination";
    let s;
    n({
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: !1,
            hideOnClick: !1,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: !1,
            type: "bullets",
            dynamicBullets: !1,
            dynamicMainBullets: 1,
            formatFractionCurrent: e => e,
            formatFractionTotal: e => e,
            bulletClass: `${r}-bullet`,
            bulletActiveClass: `${r}-bullet-active`,
            modifierClass: `${r}-`,
            currentClass: `${r}-current`,
            totalClass: `${r}-total`,
            hiddenClass: `${r}-hidden`,
            progressbarFillClass: `${r}-progressbar-fill`,
            progressbarOppositeClass: `${r}-progressbar-opposite`,
            clickableClass: `${r}-clickable`,
            lockClass: `${r}-lock`,
            horizontalClass: `${r}-horizontal`,
            verticalClass: `${r}-vertical`,
            paginationDisabledClass: `${r}-disabled`
        }
    }),
    t.pagination = {
        el: null,
        bullets: []
    };
    let i = 0;
    function l() {
        return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && 0 === t.pagination.el.length
    }
    function u(e, n) {
        const {bulletActiveClass: o} = t.params.pagination;
        e && (e = e[("prev" === n ? "previous" : "next") + "ElementSibling"]) && (e.classList.add(`${o}-${n}`),
        (e = e[("prev" === n ? "previous" : "next") + "ElementSibling"]) && e.classList.add(`${o}-${n}-${n}`))
    }
    function c(e) {
        const n = e.target.closest(sC(t.params.pagination.bulletClass));
        if (!n)
            return;
        e.preventDefault();
        const o = dS(n) * t.params.slidesPerGroup;
        if (t.params.loop) {
            if (t.realIndex === o)
                return;
            const e = (a = t.realIndex,
            r = o,
            s = t.slides.length,
            (r %= s) === 1 + (a %= s) ? "next" : r === a - 1 ? "previous" : void 0);
            "next" === e ? t.slideNext() : "previous" === e ? t.slidePrev() : t.slideToLoop(o)
        } else
            t.slideTo(o);
        var a, r, s
    }
    function d() {
        const e = t.rtl
          , n = t.params.pagination;
        if (l())
            return;
        let o, r, c = t.pagination.el;
        c = hS(c);
        const d = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length
          , p = t.params.loop ? Math.ceil(d / t.params.slidesPerGroup) : t.snapGrid.length;
        if (t.params.loop ? (r = t.previousRealIndex || 0,
        o = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : void 0 !== t.snapIndex ? (o = t.snapIndex,
        r = t.previousSnapIndex) : (r = t.previousIndex || 0,
        o = t.activeIndex || 0),
        "bullets" === n.type && t.pagination.bullets && t.pagination.bullets.length > 0) {
            const a = t.pagination.bullets;
            let l, d, p;
            if (n.dynamicBullets && (s = fS(a[0], t.isHorizontal() ? "width" : "height"),
            c.forEach(e => {
                e.style[t.isHorizontal() ? "width" : "height"] = s * (n.dynamicMainBullets + 4) + "px"
            }
            ),
            n.dynamicMainBullets > 1 && void 0 !== r && (i += o - (r || 0),
            i > n.dynamicMainBullets - 1 ? i = n.dynamicMainBullets - 1 : i < 0 && (i = 0)),
            l = Math.max(o - i, 0),
            d = l + (Math.min(a.length, n.dynamicMainBullets) - 1),
            p = (d + l) / 2),
            a.forEach(e => {
                const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(e => `${n.bulletActiveClass}${e}`)].map(e => "string" == typeof e && e.includes(" ") ? e.split(" ") : e).flat();
                e.classList.remove(...t)
            }
            ),
            c.length > 1)
                a.forEach(e => {
                    const a = dS(e);
                    a === o ? e.classList.add(...n.bulletActiveClass.split(" ")) : t.isElement && e.setAttribute("part", "bullet"),
                    n.dynamicBullets && (a >= l && a <= d && e.classList.add(...`${n.bulletActiveClass}-main`.split(" ")),
                    a === l && u(e, "prev"),
                    a === d && u(e, "next"))
                }
                );
            else {
                const e = a[o];
                if (e && e.classList.add(...n.bulletActiveClass.split(" ")),
                t.isElement && a.forEach( (e, t) => {
                    e.setAttribute("part", t === o ? "bullet-active" : "bullet")
                }
                ),
                n.dynamicBullets) {
                    const e = a[l]
                      , t = a[d];
                    for (let o = l; o <= d; o += 1)
                        a[o] && a[o].classList.add(...`${n.bulletActiveClass}-main`.split(" "));
                    u(e, "prev"),
                    u(t, "next")
                }
            }
            if (n.dynamicBullets) {
                const o = Math.min(a.length, n.dynamicMainBullets + 4)
                  , r = (s * o - s) / 2 - p * s
                  , i = e ? "right" : "left";
                a.forEach(e => {
                    e.style[t.isHorizontal() ? i : "top"] = `${r}px`
                }
                )
            }
        }
        c.forEach( (e, r) => {
            if ("fraction" === n.type && (e.querySelectorAll(sC(n.currentClass)).forEach(e => {
                e.textContent = n.formatFractionCurrent(o + 1)
            }
            ),
            e.querySelectorAll(sC(n.totalClass)).forEach(e => {
                e.textContent = n.formatFractionTotal(p)
            }
            )),
            "progressbar" === n.type) {
                let a;
                a = n.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical";
                const r = (o + 1) / p;
                let s = 1
                  , i = 1;
                "horizontal" === a ? s = r : i = r,
                e.querySelectorAll(sC(n.progressbarFillClass)).forEach(e => {
                    e.style.transform = `translate3d(0,0,0) scaleX(${s}) scaleY(${i})`,
                    e.style.transitionDuration = `${t.params.speed}ms`
                }
                )
            }
            "custom" === n.type && n.renderCustom ? (vS(e, n.renderCustom(t, o + 1, p)),
            0 === r && a("paginationRender", e)) : (0 === r && a("paginationRender", e),
            a("paginationUpdate", e)),
            t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](n.lockClass)
        }
        )
    }
    function p() {
        const e = t.params.pagination;
        if (l())
            return;
        const n = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.grid && t.params.grid.rows > 1 ? t.slides.length / Math.ceil(t.params.grid.rows) : t.slides.length;
        let o = t.pagination.el;
        o = hS(o);
        let r = "";
        if ("bullets" === e.type) {
            let o = t.params.loop ? Math.ceil(n / t.params.slidesPerGroup) : t.snapGrid.length;
            t.params.freeMode && t.params.freeMode.enabled && o > n && (o = n);
            for (let n = 0; n < o; n += 1)
                e.renderBullet ? r += e.renderBullet.call(t, n, e.bulletClass) : r += `<${e.bulletElement} ${t.isElement ? 'part="bullet"' : ""} class="${e.bulletClass}"></${e.bulletElement}>`
        }
        "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`),
        "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`),
        t.pagination.bullets = [],
        o.forEach(n => {
            "custom" !== e.type && vS(n, r || ""),
            "bullets" === e.type && t.pagination.bullets.push(...n.querySelectorAll(sC(e.bulletClass)))
        }
        ),
        "custom" !== e.type && a("paginationRender", o[0])
    }
    function f() {
        t.params.pagination = aC(t, t.originalParams.pagination, t.params.pagination, {
            el: "swiper-pagination"
        });
        const e = t.params.pagination;
        if (!e.el)
            return;
        let n;
        "string" == typeof e.el && t.isElement && (n = t.el.querySelector(e.el)),
        n || "string" != typeof e.el || (n = [...document.querySelectorAll(e.el)]),
        n || (n = e.el),
        n && 0 !== n.length && (t.params.uniqueNavElements && "string" == typeof e.el && Array.isArray(n) && n.length > 1 && (n = [...t.el.querySelectorAll(e.el)],
        n.length > 1 && (n = n.find(e => pS(e, ".swiper")[0] === t.el))),
        Array.isArray(n) && 1 === n.length && (n = n[0]),
        Object.assign(t.pagination, {
            el: n
        }),
        n = hS(n),
        n.forEach(n => {
            "bullets" === e.type && e.clickable && n.classList.add(...(e.clickableClass || "").split(" ")),
            n.classList.add(e.modifierClass + e.type),
            n.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass),
            "bullets" === e.type && e.dynamicBullets && (n.classList.add(`${e.modifierClass}${e.type}-dynamic`),
            i = 0,
            e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)),
            "progressbar" === e.type && e.progressbarOpposite && n.classList.add(e.progressbarOppositeClass),
            e.clickable && n.addEventListener("click", c),
            t.enabled || n.classList.add(e.lockClass)
        }
        ))
    }
    function h() {
        const e = t.params.pagination;
        if (l())
            return;
        let n = t.pagination.el;
        n && (n = hS(n),
        n.forEach(n => {
            n.classList.remove(e.hiddenClass),
            n.classList.remove(e.modifierClass + e.type),
            n.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass),
            e.clickable && (n.classList.remove(...(e.clickableClass || "").split(" ")),
            n.removeEventListener("click", c))
        }
        )),
        t.pagination.bullets && t.pagination.bullets.forEach(t => t.classList.remove(...e.bulletActiveClass.split(" ")))
    }
    o("changeDirection", () => {
        if (!t.pagination || !t.pagination.el)
            return;
        const e = t.params.pagination;
        let {el: n} = t.pagination;
        n = hS(n),
        n.forEach(n => {
            n.classList.remove(e.horizontalClass, e.verticalClass),
            n.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass)
        }
        )
    }
    ),
    o("init", () => {
        !1 === t.params.pagination.enabled ? v() : (f(),
        p(),
        d())
    }
    ),
    o("activeIndexChange", () => {
        void 0 === t.snapIndex && d()
    }
    ),
    o("snapIndexChange", () => {
        d()
    }
    ),
    o("snapGridLengthChange", () => {
        p(),
        d()
    }
    ),
    o("destroy", () => {
        h()
    }
    ),
    o("enable disable", () => {
        let {el: e} = t.pagination;
        e && (e = hS(e),
        e.forEach(e => e.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass)))
    }
    ),
    o("lock unlock", () => {
        d()
    }
    ),
    o("click", (e, n) => {
        const o = n.target
          , r = hS(t.pagination.el);
        if (t.params.pagination.el && t.params.pagination.hideOnClick && r && r.length > 0 && !o.classList.contains(t.params.pagination.bulletClass)) {
            if (t.navigation && (t.navigation.nextEl && o === t.navigation.nextEl || t.navigation.prevEl && o === t.navigation.prevEl))
                return;
            const e = r[0].classList.contains(t.params.pagination.hiddenClass);
            a(!0 === e ? "paginationShow" : "paginationHide"),
            r.forEach(e => e.classList.toggle(t.params.pagination.hiddenClass))
        }
    }
    );
    const v = () => {
        t.el.classList.add(t.params.pagination.paginationDisabledClass);
        let {el: e} = t.pagination;
        e && (e = hS(e),
        e.forEach(e => e.classList.add(t.params.pagination.paginationDisabledClass))),
        h()
    }
    ;
    Object.assign(t.pagination, {
        enable: () => {
            t.el.classList.remove(t.params.pagination.paginationDisabledClass);
            let {el: e} = t.pagination;
            e && (e = hS(e),
            e.forEach(e => e.classList.remove(t.params.pagination.paginationDisabledClass))),
            f(),
            p(),
            d()
        }
        ,
        disable: v,
        render: p,
        update: d,
        init: f,
        destroy: h
    })
}
function lC(e) {
    let t, n, {swiper: o, extendParams: a, on: r, emit: s, params: i} = e;
    o.autoplay = {
        running: !1,
        paused: !1,
        timeLeft: 0
    },
    a({
        autoplay: {
            enabled: !1,
            delay: 3e3,
            waitForTransition: !0,
            disableOnInteraction: !1,
            stopOnLastSlide: !1,
            reverseDirection: !1,
            pauseOnMouseEnter: !1
        }
    });
    let l, u, c, d, p, f, h, v, m = i && i.autoplay ? i.autoplay.delay : 3e3, g = i && i.autoplay ? i.autoplay.delay : 3e3, y = (new Date).getTime();
    function b(e) {
        o && !o.destroyed && o.wrapperEl && e.target === o.wrapperEl && (o.wrapperEl.removeEventListener("transitionend", b),
        v || e.detail && e.detail.bySwiperTouchMove || C())
    }
    const w = () => {
        if (o.destroyed || !o.autoplay.running)
            return;
        o.autoplay.paused ? u = !0 : u && (g = l,
        u = !1);
        const e = o.autoplay.paused ? l : y + g - (new Date).getTime();
        o.autoplay.timeLeft = e,
        s("autoplayTimeLeft", e, e / m),
        n = requestAnimationFrame( () => {
            w()
        }
        )
    }
      , _ = e => {
        if (o.destroyed || !o.autoplay.running)
            return;
        cancelAnimationFrame(n),
        w();
        let a = void 0 === e ? o.params.autoplay.delay : e;
        m = o.params.autoplay.delay,
        g = o.params.autoplay.delay;
        const r = ( () => {
            let e;
            if (e = o.virtual && o.params.virtual.enabled ? o.slides.find(e => e.classList.contains("swiper-slide-active")) : o.slides[o.activeIndex],
            !e)
                return;
            return parseInt(e.getAttribute("data-swiper-autoplay"), 10)
        }
        )();
        !Number.isNaN(r) && r > 0 && void 0 === e && (a = r,
        m = r,
        g = r),
        l = a;
        const i = o.params.speed
          , u = () => {
            o && !o.destroyed && (o.params.autoplay.reverseDirection ? !o.isBeginning || o.params.loop || o.params.rewind ? (o.slidePrev(i, !0, !0),
            s("autoplay")) : o.params.autoplay.stopOnLastSlide || (o.slideTo(o.slides.length - 1, i, !0, !0),
            s("autoplay")) : !o.isEnd || o.params.loop || o.params.rewind ? (o.slideNext(i, !0, !0),
            s("autoplay")) : o.params.autoplay.stopOnLastSlide || (o.slideTo(0, i, !0, !0),
            s("autoplay")),
            o.params.cssMode && (y = (new Date).getTime(),
            requestAnimationFrame( () => {
                _()
            }
            )))
        }
        ;
        return a > 0 ? (clearTimeout(t),
        t = setTimeout( () => {
            u()
        }
        , a)) : requestAnimationFrame( () => {
            u()
        }
        ),
        a
    }
      , x = () => {
        y = (new Date).getTime(),
        o.autoplay.running = !0,
        _(),
        s("autoplayStart")
    }
      , k = () => {
        o.autoplay.running = !1,
        clearTimeout(t),
        cancelAnimationFrame(n),
        s("autoplayStop")
    }
      , S = (e, n) => {
        if (o.destroyed || !o.autoplay.running)
            return;
        clearTimeout(t),
        e || (h = !0);
        const a = () => {
            s("autoplayPause"),
            o.params.autoplay.waitForTransition ? o.wrapperEl.addEventListener("transitionend", b) : C()
        }
        ;
        if (o.autoplay.paused = !0,
        n)
            return f && (l = o.params.autoplay.delay),
            f = !1,
            void a();
        const r = l || o.params.autoplay.delay;
        l = r - ((new Date).getTime() - y),
        o.isEnd && l < 0 && !o.params.loop || (l < 0 && (l = 0),
        a())
    }
      , C = () => {
        o.isEnd && l < 0 && !o.params.loop || o.destroyed || !o.autoplay.running || (y = (new Date).getTime(),
        h ? (h = !1,
        _(l)) : _(),
        o.autoplay.paused = !1,
        s("autoplayResume"))
    }
      , E = () => {
        if (o.destroyed || !o.autoplay.running)
            return;
        const e = Yk();
        "hidden" === e.visibilityState && (h = !0,
        S(!0)),
        "visible" === e.visibilityState && C()
    }
      , T = e => {
        "mouse" === e.pointerType && (h = !0,
        v = !0,
        o.animating || o.autoplay.paused || S(!0))
    }
      , A = e => {
        "mouse" === e.pointerType && (v = !1,
        o.autoplay.paused && C())
    }
    ;
    r("init", () => {
        o.params.autoplay.enabled && (o.params.autoplay.pauseOnMouseEnter && (o.el.addEventListener("pointerenter", T),
        o.el.addEventListener("pointerleave", A)),
        Yk().addEventListener("visibilitychange", E),
        x())
    }
    ),
    r("destroy", () => {
        o.el && "string" != typeof o.el && (o.el.removeEventListener("pointerenter", T),
        o.el.removeEventListener("pointerleave", A)),
        Yk().removeEventListener("visibilitychange", E),
        o.autoplay.running && k()
    }
    ),
    r("_freeModeStaticRelease", () => {
        (d || h) && C()
    }
    ),
    r("_freeModeNoMomentumRelease", () => {
        o.params.autoplay.disableOnInteraction ? k() : S(!0, !0)
    }
    ),
    r("beforeTransitionStart", (e, t, n) => {
        !o.destroyed && o.autoplay.running && (n || !o.params.autoplay.disableOnInteraction ? S(!0, !0) : k())
    }
    ),
    r("sliderFirstMove", () => {
        !o.destroyed && o.autoplay.running && (o.params.autoplay.disableOnInteraction ? k() : (c = !0,
        d = !1,
        h = !1,
        p = setTimeout( () => {
            h = !0,
            d = !0,
            S(!0)
        }
        , 200)))
    }
    ),
    r("touchEnd", () => {
        if (!o.destroyed && o.autoplay.running && c) {
            if (clearTimeout(p),
            clearTimeout(t),
            o.params.autoplay.disableOnInteraction)
                return d = !1,
                void (c = !1);
            d && o.params.cssMode && C(),
            d = !1,
            c = !1
        }
    }
    ),
    r("slideChange", () => {
        !o.destroyed && o.autoplay.running && (f = !0)
    }
    ),
    Object.assign(o.autoplay, {
        start: x,
        stop: k,
        pause: S,
        resume: C
    })
}
var uC, cC, dC, pC, fC;
function hC(e, t=!0) {
    const n = t ? e / 100 : e;
    return Intl.NumberFormat("pt-br", {
        style: "currency",
        currency: "BRL"
    }).format(n)
}
function vC(e, t=!0) {
    const n = t ? e / 100 : e;
    return Intl.NumberFormat("pt-BR", {
        style: "decimal",
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    }).format(n)
}
function mC(e) {
    if (!e)
        return "";
    const t = new Date(e);
    return new Intl.DateTimeFormat("en-US",{
        month: "short",
        day: "2-digit",
        year: "numeric"
    }).format(t)
}
(pC = dC || (dC = {})).UATP = "uatp",
pC.AMEX = "amex",
pC.DINERS = "diners",
pC.DISCOVER = "discover",
pC.MASTERCARD = "mastercard",
pC.DANKORT = "dankort",
pC.INSTAPAYMENT = "instapayment",
pC.JCB15 = "jcb15",
pC.JCB = "jcb",
pC.MAESTRO = "maestro",
pC.VISA = "visa",
pC.MIR = "mir",
pC.UNIONPAY = "unionpay",
pC.GENERAL = "general",
(uC = {})[dC.UATP] = [4, 5, 6],
uC[dC.AMEX] = [4, 6, 5],
uC[dC.DINERS] = [4, 6, 4],
uC[dC.DISCOVER] = [4, 4, 4, 4],
uC[dC.MASTERCARD] = [4, 4, 4, 4],
uC[dC.DANKORT] = [4, 4, 4, 4],
uC[dC.INSTAPAYMENT] = [4, 4, 4, 4],
uC[dC.JCB15] = [4, 6, 5],
uC[dC.JCB] = [4, 4, 4, 4],
uC[dC.MAESTRO] = [4, 4, 4, 4],
uC[dC.VISA] = [4, 4, 4, 4],
uC[dC.MIR] = [4, 4, 4, 4],
uC[dC.UNIONPAY] = [4, 4, 4, 4],
uC[dC.GENERAL] = [4, 4, 4, 4],
(cC = {})[dC.UATP] = /^(?!1800)1\d{0,14}/,
cC[dC.AMEX] = /^3[47]\d{0,13}/,
cC[dC.DISCOVER] = /^(?:6011|65\d{0,2}|64[4-9]\d?)\d{0,12}/,
cC[dC.DINERS] = /^3(?:0([0-5]|9)|[689]\d?)\d{0,11}/,
cC[dC.MASTERCARD] = /^(5[1-5]\d{0,2}|22[2-9]\d{0,1}|2[3-7]\d{0,2})\d{0,12}/,
cC[dC.DANKORT] = /^(5019|4175|4571)\d{0,12}/,
cC[dC.INSTAPAYMENT] = /^63[7-9]\d{0,13}/,
cC[dC.JCB15] = /^(?:2131|1800)\d{0,11}/,
cC[dC.JCB] = /^(?:35\d{0,2})\d{0,12}/,
cC[dC.MAESTRO] = /^(?:5[0678]\d{0,2}|6304|67\d{0,2})\d{0,12}/,
cC[dC.MIR] = /^220[0-4]\d{0,12}/,
cC[dC.VISA] = /^4\d{0,15}/,
cC[dC.UNIONPAY] = /^(62|81)\d{0,14}/,
function(e) {
    e.THOUSAND = "thousand",
    e.LAKH = "lakh",
    e.WAN = "wan",
    e.NONE = "none"
}(fC || (fC = {})),
fC.THOUSAND;
const gC = {
    key: 0,
    class: "bg-yellow-400 rounded-md absolute -top-0.5 left-2/4 -translate-y-2/4 -translate-x-2/4 text-xs text-black leading-4 px-1 uppercase flex gap-1 items-center text-nowrap"
}
  , yC = to({
    __name: "AmountSwipper",
    props: {
        values: {},
        selected: {},
        hot: {
            type: Boolean
        }
    },
    emits: ["select"],
    setup(e, {emit: t}) {
        const n = t;
        return (e, t) => (Tr(),
        Ir(Nt(tC), {
            freeMode: !0,
            pagination: !1,
            spaceBetween: 8,
            slidesPerView: "auto",
            mousewheel: !0,
            modules: [Nt(oC)],
            resistanceRatio: .54,
            class: "!mb-2 !pt-3 !pb-1 !pl-[2px] !select-none",
            wrapperClass: "swiper-wrapper"
        }, {
            default: En( () => [(Tr(!0),
            Br(_r, null, qo(e.values, (o, a) => (Tr(),
            Ir(Nt(nC), {
                key: o,
                onClick: e => function(e) {
                    n("select", e)
                }(o),
                class: K(["bg-primary/10 text-primary text-base font-semibold !w-fit !rounded-md !p-3 !py-2 !cursor-pointer !relative !hover:bg-primary/20", {
                    "ring-2 ring-yellow-400": 1 === a && e.hot
                }])
            }, {
                default: En( () => [1 === a && e.hot ? (Tr(),
                Br("span", gC, [jr(Nt(rm), {
                    class: "size-[0.64rem] inline"
                }), t[0] || (t[0] = Vr(" QUENTE "))])) : Ur("", !0), Vr(" " + ne(Nt(hC)(o)), 1)]),
                _: 2
            }, 1032, ["onClick", "class"]))), 128))]),
            _: 1
        }, 8, ["modules"]))
    }
});
var bC = Object.defineProperty
  , wC = (e, t, n) => (( (e, t, n) => {
    t in e ? bC(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n
}
)(e, "symbol" != typeof t ? t + "" : t, n),
n);
const _C = {
    debug: !1,
    masked: !1,
    prefix: "",
    suffix: "",
    thousands: ",",
    decimal: ".",
    precision: 2,
    disableNegative: !1,
    disabled: !1,
    min: null,
    max: null,
    allowBlank: !1,
    minimumNumberOfCharacters: 0,
    modelModifiers: {
        number: !1
    },
    shouldRound: !0,
    focusOnRight: !1
}
  , xC = ["+", "-"]
  , kC = ["decimal", "thousands", "prefix", "suffix"];
function SC(e) {
    return Math.max(0, Math.min(e, 1e3))
}
function CC(e, t) {
    return e = e.padStart(t + 1, "0"),
    0 === t ? e : `${e.slice(0, -t)}.${e.slice(-t)}`
}
function EC(e) {
    return (e = e ? e.toString() : "").replace(/\D+/g, "") || "0"
}
function TC(e, t) {
    return !xC.includes(e) && !/\d/g.test(e)
}
function AC(e) {
    for (const t of kC) {
        e[t] = e[t].replace(/\d+/g, "");
        for (const n of xC)
            e[t] = e[t].replaceAll(n, "")
    }
    return e
}
function OC(e) {
    return e.length - (e.indexOf(".") + 1)
}
function MC(e) {
    return e.replace(/^(-?)0+(?!\.)(.+)/, "$1$2")
}
function PC(e) {
    return /^-?[\d]+$/g.test(e)
}
function BC(e) {
    return /^-?[\d]+(\.[\d]+)$/g.test(e)
}
function IC(e, t, n) {
    return t > e.length - 1 ? e : e.substring(0, t) + n + e.substring(t + 1)
}
function LC(e, t) {
    const n = t - OC(e);
    if (n >= 0)
        return e;
    let o = e.slice(0, n);
    const a = e.slice(n);
    if ("." === o.charAt(o.length - 1) && (o = o.slice(0, -1)),
    parseInt(a.charAt(0), 10) >= 5) {
        for (let e = o.length - 1; e >= 0; e -= 1) {
            const t = o.charAt(e);
            if ("." !== t && "-" !== t) {
                const n = parseInt(t, 10) + 1;
                if (n < 10)
                    return IC(o, e, n);
                o = IC(o, e, "0")
            }
        }
        return `1${o}`
    }
    return o
}
function RC(e, t) {
    const n = () => {
        e.setSelectionRange(t, t)
    }
    ;
    e === document.activeElement && (n(),
    setTimeout(n, 1))
}
function zC(e) {
    return new Event(e,{
        bubbles: !0,
        cancelable: !1
    })
}
class NC {
    constructor(e) {
        wC(this, "number", 0n),
        wC(this, "decimal", 0),
        this.setNumber(e)
    }
    getNumber() {
        return this.number
    }
    getDecimalPrecision() {
        return this.decimal
    }
    setNumber(e) {
        this.decimal = 0,
        "bigint" == typeof e ? this.number = e : "number" == typeof e ? this.setupString(e.toString()) : this.setupString(e)
    }
    toFixed(e=0, t=!0) {
        let n = this.toString();
        const o = e - this.getDecimalPrecision();
        return o > 0 ? (n.includes(".") || (n += "."),
        n.padEnd(n.length + o, "0")) : o < 0 ? t ? LC(n, e) : n.slice(0, o) : n
    }
    toString() {
        let e = this.number.toString();
        if (this.decimal) {
            let t = !1;
            return "-" === e.charAt(0) && (e = e.substring(1),
            t = !0),
            e = e.padStart(e.length + this.decimal, "0"),
            e = `${e.slice(0, -this.decimal)}.${e.slice(-this.decimal)}`,
            e = MC(e),
            (t ? "-" : "") + e
        }
        return e
    }
    lessThan(e) {
        const [t,n] = this.adjustComparisonNumbers(e);
        return t < n
    }
    biggerThan(e) {
        const [t,n] = this.adjustComparisonNumbers(e);
        return t > n
    }
    isEqual(e) {
        const [t,n] = this.adjustComparisonNumbers(e);
        return t === n
    }
    setupString(e) {
        if (PC(e = MC(e)))
            this.number = BigInt(e);
        else {
            if (!BC(e))
                throw new Error(`BigNumber has received and invalid format for the constructor: ${e}`);
            this.decimal = OC(e),
            this.number = BigInt(e.replace(".", ""))
        }
    }
    adjustComparisonNumbers(e) {
        let t;
        t = "BigNumber" !== e.constructor.name ? new NC(e) : e;
        const n = this.getDecimalPrecision() - t.getDecimalPrecision();
        let o = this.getNumber()
          , a = t.getNumber();
        return n > 0 ? a = t.getNumber() * 10n ** BigInt(n) : n < 0 && (o = this.getNumber() * 10n ** BigInt(-1 * n)),
        [o, a]
    }
}
function DC(e, t=_C, n="") {
    if (null == e)
        e = "";
    else if ("number" == typeof e)
        e = t.shouldRound ? e.toFixed(SC(t.precision)) : e.toFixed(SC(t.precision) + 1).slice(0, -1);
    else if (t.modelModifiers && t.modelModifiers.number && PC(e))
        e = Number(e).toFixed(SC(t.precision));
    else if (!t.disableNegative && "-" === e)
        return e;
    const o = t.disableNegative ? "" : e.indexOf("-") >= 0 ? "-" : "";
    let a = e.replace(t.prefix, "").replace(t.suffix, "");
    !t.precision && "." !== t.thousands && BC(a) && (a = LC(a, 0));
    const r = EC(a);
    CC(r, t.precision);
    const s = new NC(o + CC(r, t.precision));
    s.toString(),
    t.max && s.biggerThan(t.max) && s.setNumber(t.max),
    t.min && s.lessThan(t.min) && s.setNumber(t.min);
    const i = s.toFixed(SC(t.precision), t.shouldRound);
    if (s.toFixed(SC(t.precision)),
    /^0(\.0+)?$/g.test(i) && t.allowBlank)
        return "";
    let[l,u] = i.split(".");
    const c = void 0 !== u ? u.length : 0;
    l = l.padStart(t.minimumNumberOfCharacters - c, "0"),
    l = function(e, t) {
        return e.replace(/(\d)(?=(?:\d{3})+\b)/gm, `$1${t}`)
    }(l, t.thousands);
    const d = t.prefix + function(e, t, n) {
        return t ? e + n + t : e
    }(l, u, t.decimal) + t.suffix;
    return d
}
function jC(e, t=_C, n="") {
    if (!t.disableNegative && "-" === e)
        return e;
    const o = t.disableNegative ? "" : e.indexOf("-") >= 0 ? "-" : ""
      , a = e.replace(t.prefix, "").replace(t.suffix, "")
      , r = EC(a)
      , s = new NC(o + CC(r, t.precision));
    r.toString(),
    t.max && s.biggerThan(t.max) && s.setNumber(t.max),
    t.min && s.lessThan(t.min) && s.setNumber(t.min);
    let i = s.toFixed(SC(t.precision), t.shouldRound);
    return t.modelModifiers && t.modelModifiers.number && (i = parseFloat(i)),
    i
}
const FC = (e, t, n) => {
    if (!function(e) {
        for (const t of kC)
            if (!TC(e[t]))
                return !1;
        return !0
    }(t))
        return void e.value;
    let o = e.value.length - (e.selectionEnd || 0);
    e.value = DC(e.value, t, n),
    o = Math.max(o, t.suffix.length),
    o = e.value.length - o,
    o = Math.max(o, t.prefix.length),
    RC(e, o),
    e.dispatchEvent(zC("change"))
}
  , $C = (e, t) => {
    const n = e.currentTarget
      , o = "Backspace" === e.code || "Delete" === e.code
      , a = n.value.length - (n.selectionEnd || 0) === 0;
    if (n.value,
    t.allowBlank && o && a && 0 === jC(n.value, t, "directive onkeydown allowBlank") && (n.value,
    n.value = "",
    n.dispatchEvent(zC("change"))),
    e.key,
    "+" === e.key) {
        n.value;
        let e = jC(n.value, t, "directive onkeydown +");
        "string" == typeof e && (e = parseFloat(e)),
        e < 0 && (n.value = String(-1 * e))
    }
}
  , VC = (e, t) => {
    const n = e.currentTarget;
    n.value,
    /^[1-9]$/.test(n.value) && (n.value = CC(n.value, SC(t.precision)),
    n.value),
    FC(n, t, "directive oninput")
}
  , HC = (e, t) => {
    const n = e.currentTarget;
    n.value,
    t.focusOnRight && RC(n, n.value.length - t.suffix.length)
}
  , UC = {
    mounted(e, t) {
        if (!t.value)
            return;
        const n = AC({
            ..._C,
            ...t.value
        });
        if ("INPUT" !== e.tagName.toLocaleUpperCase()) {
            const t = e.getElementsByTagName("input");
            1 !== t.length || (e = t[0])
        }
        e.onkeydown = e => {
            $C(e, n)
        }
        ,
        e.oninput = e => {
            VC(e, n)
        }
        ,
        e.onfocus = e => {
            HC(e, n)
        }
        ,
        e.value,
        FC(e, n, "directive mounted")
    },
    updated(e, t) {
        if (!t.value)
            return;
        const n = AC({
            ..._C,
            ...t.value
        });
        e.onkeydown = e => {
            $C(e, n)
        }
        ,
        e.oninput = e => {
            VC(e, n)
        }
        ,
        e.onfocus = e => {
            HC(e, n)
        }
        ,
        e.value,
        FC(e, n, "directive updated")
    },
    beforeUnmount(e) {
        e.onkeydown = null,
        e.oninput = null,
        e.onfocus = null
    }
}
  , ZC = ["id", "value", "disabled"]
  , qC = to({
    ...{
        inheritAttrs: !1,
        name: "Money3",
        directives: {
            money3: UC
        }
    },
    props: {
        debug: {
            required: !1,
            type: Boolean,
            default: !1
        },
        id: {
            required: !1,
            type: [Number, String],
            default: () => {
                const e = es();
                return e ? e.uid : null
            }
        },
        modelValue: {
            required: !0,
            type: [Number, String]
        },
        modelModifiers: {
            required: !1,
            type: Object,
            default: () => ({
                number: !1
            })
        },
        masked: {
            type: Boolean,
            default: !1
        },
        precision: {
            type: Number,
            default: () => _C.precision
        },
        decimal: {
            type: String,
            default: () => _C.decimal,
            validator: e => TC(e)
        },
        thousands: {
            type: String,
            default: () => _C.thousands,
            validator: e => TC(e)
        },
        prefix: {
            type: String,
            default: () => _C.prefix,
            validator: e => TC(e)
        },
        suffix: {
            type: String,
            default: () => _C.suffix,
            validator: e => TC(e)
        },
        disableNegative: {
            type: Boolean,
            default: !1
        },
        disabled: {
            type: Boolean,
            default: !1
        },
        max: {
            type: [Number, String],
            default: () => _C.max
        },
        min: {
            type: [Number, String],
            default: () => _C.min
        },
        allowBlank: {
            type: Boolean,
            default: () => _C.allowBlank
        },
        minimumNumberOfCharacters: {
            type: Number,
            default: () => _C.minimumNumberOfCharacters
        },
        shouldRound: {
            type: Boolean,
            default: () => _C.shouldRound
        },
        focusOnRight: {
            type: Boolean,
            default: () => _C.focusOnRight
        }
    },
    emits: ["update:model-value"],
    setup(e, {emit: t}) {
        const n = e
          , {modelValue: o, modelModifiers: a, masked: r, precision: s, shouldRound: i, focusOnRight: l} = Ht(n);
        let u = o.value;
        (n.disableNegative || "-" !== u) && a.value && a.value.number && (u = i.value ? Number(o.value).toFixed(SC(s.value)) : Number(o.value).toFixed(SC(s.value) + 1).slice(0, -1));
        const c = It(DC(u, n, "component setup"));
        c.value,
        Qa(o, function(e) {
            const t = DC(e, AC({
                ...n
            }), "component watch");
            t !== c.value && (c.value = t)
        });
        let d = null;
        function p(e) {
            let o = e.target.value;
            r.value && !a.value.number || (o = jC(o, AC({
                ...n
            }), "component change")),
            o !== d && (d = o,
            t("update:model-value", o))
        }
        const f = ta()
          , h = ms( () => {
            const e = {
                ...f
            };
            return delete e["onUpdate:modelValue"],
            e
        }
        );
        return (t, o) => {
            const r = Ho("money3");
            return Tn((Tr(),
            Br("input", Gr({
                id: `${e.id}`
            }, Nt(h), {
                type: "tel",
                class: "v-money3",
                value: c.value,
                disabled: n.disabled,
                onChange: p
            }), null, 16, ZC)), [[r, {
                precision: Nt(s),
                decimal: n.decimal,
                thousands: n.thousands,
                prefix: n.prefix,
                suffix: n.suffix,
                disableNegative: n.disableNegative,
                min: n.min,
                max: n.max,
                allowBlank: n.allowBlank,
                minimumNumberOfCharacters: n.minimumNumberOfCharacters,
                debug: n.debug,
                modelModifiers: Nt(a),
                shouldRound: Nt(i),
                focusOnRight: Nt(l)
            }]])
        }
    }
})
  , WC = {
    class: "relative"
}
  , GC = {
    key: 0,
    class: "font-semibold opacity-80 absolute left-3 top-2/4 -translate-y-2/4"
}
  , KC = to({
    inheritAttrs: !1,
    __name: "PriceInput",
    props: {
        defaultValue: {},
        modelValue: {},
        class: {},
        withoutPrefix: {
            type: Boolean
        }
    },
    emits: ["update:modelValue"],
    setup(e, {emit: t}) {
        const n = e
          , o = t;
        qf(n, "modelValue", o, {
            passive: !0,
            defaultValue: n.defaultValue
        });
        const a = ms({
            get: () => null == n.modelValue ? 0 : Number(n.modelValue) / 100,
            set(e) {
                o("update:modelValue", Math.round(100 * Number(e)))
            }
        });
        return (e, t) => (Tr(),
        Br("div", WC, [e.withoutPrefix ? Ur("", !0) : (Tr(),
        Br("span", GC, " R$ ")), jr(Nt(qC), Gr({
            modelValue: a.value,
            "onUpdate:modelValue": t[0] || (t[0] = e => a.value = e),
            modelModifiers: {
                number: !0
            },
            "data-slot": "input",
            class: Nt(hv)("!pl-10.5 file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex w-full min-w-0 rounded-md border bg-transparent px-3.5 py-2.5 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", n.class)
        }, {
            ...Nt(mv)(e.$attrs, "class"),
            thousands: ".",
            decimal: ",",
            precision: 2,
            disableNegative: !0
        }, {
            inputmode: "numeric"
        }), null, 16, ["modelValue", "class"])]))
    }
})
  , YC = to({
    __name: "Label",
    props: {
        for: {},
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Lf(t, "class");
        return (e, o) => (Tr(),
        Ir(Nt(Tp), Gr({
            "data-slot": "label"
        }, Nt(n), {
            class: Nt(hv)("flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50", t.class)
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["class"]))
    }
})
  , XC = Ol("global", {
    state: () => ({
        seo: null,
        theme: null,
        banners: [],
        financial: null,
        isMobile: !1
    }),
    getters: {},
    actions: {
        init() {
            this.fetchSettings()
        },
        applySeo() {
            if (!this.seo)
                return;
            const {website_name: e, description: t, keywords: n, website_url: o} = this.seo;
            document.title = e,
            this.updateMeta("description", t),
            this.updateMeta("keywords", n),
            this.updateLink("canonical", o)
        },
        updateMeta(e, t) {
            let n = document.head.querySelector(`meta[name="${e}"]`);
            n || (n = document.createElement("meta"),
            n.setAttribute("name", e),
            document.head.appendChild(n)),
            n.setAttribute("content", t)
        },
        updateLink(e, t) {
            let n = document.head.querySelector(`link[rel="${e}"]`);
            n || (n = document.createElement("link"),
            n.setAttribute("rel", e),
            document.head.appendChild(n)),
            n.setAttribute("href", t)
        },
        async fetchSettings() {
            try {
                const {data: e} = await b_.get("/core");
                this.seo = null == e ? void 0 : e.seo,
                this.theme = null == e ? void 0 : e.theme,
                this.financial = null == e ? void 0 : e.financial;
                const t = e.banners ?? [];
                this.banners = t.map(e => ({
                    action: e.action ?? void 0,
                    image: e.image,
                    order_value: e.order_value ?? void 0
                })).sort( (e, t) => (e.order_value ?? 0) - (t.order_value ?? 0)),
                this.applyPrimaryColor()
            } catch (e) {
                throw e
            }
        },
        applyPrimaryColor() {
            var e;
            const t = null == (e = this.theme) ? void 0 : e.primary_color;
            t && document.documentElement.style.setProperty("--primary", t)
        }
    }
})
  , JC = Ol("favicon", {
    actions: {
        applyFavicon(e) {
            if (!e)
                return;
            const t = document.querySelector("link[rel~='icon']");
            if (t)
                t.href = e;
            else {
                const t = document.createElement("link");
                t.rel = "icon",
                t.href = e,
                document.head.appendChild(t)
            }
        }
    }
});
window.matchMedia("(max-width: 780px)"),
window.matchMedia("(min-width: 780px) and (max-width: 1440px)");
const QC = Ol("auth", {
    state: () => ({
        user: null,
        wallet: null,
        loading: !1,
        error: !1
    }),
    getters: {
        authenticated: e => !e.loading && !e.error && null !== e.user && void 0 !== e.user
    },
    actions: {
        init() {
            localStorage.getItem(y_) && (this.fetchUser(),
            this.fetchWallet(),
            setInterval( () => {
                this.fetchWallet()
            }
            , 15e3))
        },
        async fetchUser() {
            var e;
            this.loading = !0,
            this.error = !1;
            try {
                const {data: e} = await b_.get("/user");
                this.user = null == e ? void 0 : e.data
            } catch (t) {
                if (this.error = !0,
                t instanceof o_) {
                    const n = null == (e = t.response) ? void 0 : e.data.msg.toLowerCase();
                    if (n.includes("token invlido") || n.includes("token expirado"))
                        return this.logout()
                }
            } finally {
                this.loading = !1
            }
        },
        async fetchWallet() {
            try {
                const {data: e} = await b_.get("/user/balance");
                this.wallet = null == e ? void 0 : e.data
            } catch (e) {
                throw e
            }
        },
        async logout() {
            try {
                await b_.post("/auth/logout")
            } catch (e) {} finally {
                localStorage.removeItem(y_),
                setTimeout( () => {
                    location.href = "/"
                }
                , 300)
            }
        }
    }
});
function eE(e) {
    if (10 !== (e = e.replace(/[^\d]+/g, "")).length && 11 !== e.length)
        return !1;
    const t = parseInt(e.substring(0, 2));
    return !(t < 0 || t > 99)
}
function tE(e) {
    const t = e.replace(/[^\d]+/g, "");
    if (14 !== t.length)
        return !1;
    const n = (e, t) => {
        let n = 0;
        for (let a = 0; a < t.length; a++)
            n += parseInt(e.charAt(a), 10) * t[a];
        const o = n % 11;
        return o < 2 ? 0 : 11 - o
    }
      , o = t.substring(0, 12)
      , a = n(o, [5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2])
      , r = n(o + a, [6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2]);
    return t.substring(12) === `${a}${r}`
}
function nE(e) {
    if (11 !== (e = e.replace(/[^\d]+/g, "")).length)
        return !1;
    if (/^(\d)\1+$/.test(e))
        return !1;
    let t = 0;
    for (let o = 0; o < 9; o++)
        t += parseInt(e.charAt(o)) * (10 - o);
    let n = 11 - t % 11;
    if ((n < 10 ? n : 0) !== parseInt(e.charAt(9)))
        return !1;
    t = 0;
    for (let o = 0; o < 10; o++)
        t += parseInt(e.charAt(o)) * (11 - o);
    return n = 11 - t % 11,
    (n < 10 ? n : 0) === parseInt(e.charAt(10))
}
const oE = {
    class: "flex items-center gap-2"
}
  , aE = {
    class: ""
}
  , rE = {
    class: "overflow-hidden"
}
  , sE = {
    class: ""
}
  , iE = {
    class: "flex items-center w-full gap-1.5"
}
  , lE = {
    class: "relative w-full"
}
  , uE = {
    class: ""
}
  , cE = {
    class: "relative"
}
  , dE = "Campo obrigatrio"
  , pE = to({
    __name: "WithdrawModal",
    setup(e) {
        const t = XC()
          , n = QC()
          , o = ms( () => {
            var e;
            return (null == (e = t.financial) ? void 0 : e.min_withdraw) ?? 2e3
        }
        )
          , a = ms( () => {
            var e;
            return (null == (e = t.financial) ? void 0 : e.max_withdraw) ?? 1e5
        }
        )
          , r = Wg({
            amount: qg().min(o.value, `O valor mnimo  R$ ${vC(o.value)}`).max(a.value, `O valor mximo  R$ ${vC(a.value)}`),
            document: Zg().min(1, dE).refine(e => tE(e) || nE(e), {
                message: "Documento invlido"
            }),
            address: Zg({
                required_error: dE
            }).min(1, dE)
        })
          , {isSubmitting: s, errors: i, defineField: l, handleSubmit: u, submitCount: c} = Fy({
            initialValues: {
                amount: 0,
                address: "",
                document: ""
            },
            validationSchema: Zy(r)
        })
          , [d,p] = l("document")
          , [f,h] = l("amount")
          , [v,m] = l("address")
          , g = It("cpf");
        Qa(v, e => {
            const t = nE(n = e) ? "cpf" : tE(n) ? "cnpj" : /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/.test(n) ? "email" : eE(n) ? "phone" : "random";
            var n;
            t && (g.value = t)
        }
        , {
            immediate: !0
        });
        const y = It(!1)
          , b = u(async e => {
            var t;
            try {
                const {data: t} = await b_.post("/wallet/withdraw", {
                    ...e,
                    address_type: g.value
                });
                y.value = !0,
                await new Promise(e => setTimeout(e, 1500)),
                w.value = !1,
                n.fetchWallet(),
                S_.success("Saque solicitado com sucesso!")
            } catch (o) {
                await new Promise(e => setTimeout(e, 1e3));
                let e = "Ocorreu um erro ao realizar o saque";
                if (t_.isAxiosError(o) && o.response) {
                    const n = o.response.data;
                    e = (n.errors ? null == (t = Object.values(n.errors)[0]) ? void 0 : t[0] : void 0) ?? n.message ?? e,
                    window.scrollTo({
                        top: 0,
                        behavior: "smooth"
                    })
                }
                S_.error(e)
            }
        }
        )
          , w = pm("withdraw")
          , _ = [500, 1e3, 3e3, 5e3, 1e4, 2e4, 5e4].filter(e => e >= o.value);
        function x(e) {
            f.value = e
        }
        return (e, t) => {
            const n = YC
              , o = KC
              , a = um
              , r = yC
              , l = qk
              , u = cm
              , k = im
              , S = Gv
              , C = Ho("mask");
            return Tr(),
            Ir(S, {
                open: Nt(w),
                "onUpdate:open": t[5] || (t[5] = e => Bt(w) ? w.value = e : null)
            }, {
                heading: En( () => t[6] || (t[6] = [Dr("div", {
                    class: "-m-10 mb-0 select-none relative"
                }, [Dr("img", {
                    src: "https://ik.imagekit.io/azx3nlpdu/SAQUE.jpg?updatedAt=1751798026776",
                    class: "size-full object-contain sm:rounded-t-lg"
                }), Dr("div", {
                    class: "absolute bg-gradient-to-b from-black/10 via-black/10 from-0% via-85% to-100% to-background size-full z-10 top-0"
                })], -1)])),
                content: En( () => [Dr("div", oE, [jr(Nt(sm).Withdraw, {
                    class: "size-7"
                }), t[7] || (t[7] = Dr("h1", {
                    class: "text-2xl font-medium"
                }, "Sacar", -1))]), Dr("form", {
                    onSubmit: t[4] || (t[4] = Yi( (...e) => Nt(b) && Nt(b)(...e), ["prevent"])),
                    class: "space-y-3 overflow-hidden"
                }, [Dr("div", aE, [jr(n, {
                    for: "amount",
                    class: "mb-2 text-base required gap-0.5"
                }, {
                    default: En( () => t[8] || (t[8] = [Vr("Valor:")])),
                    _: 1,
                    __: [8]
                }), jr(o, Gr({
                    id: "amount",
                    modelValue: Nt(f),
                    "onUpdate:modelValue": t[0] || (t[0] = e => Bt(f) ? f.value = e : null)
                }, Nt(h), {
                    autocomplete: "off"
                }), null, 16, ["modelValue"]), jr(a, {
                    message: Nt(i).amount
                }, null, 8, ["message"])]), Dr("div", rE, [jr(r, {
                    values: Nt(_),
                    selected: Nt(f),
                    onSelect: x
                }, null, 8, ["values", "selected"])]), Dr("div", sE, [jr(n, {
                    for: "email",
                    class: "mb-1"
                }, {
                    default: En( () => t[9] || (t[9] = [Vr("Chave PIX")])),
                    _: 1,
                    __: [9]
                }), Dr("div", iE, [jr(l, {
                    modelValue: g.value,
                    "onUpdate:modelValue": t[1] || (t[1] = e => g.value = e)
                }, null, 8, ["modelValue"]), Dr("div", lE, [jr(u, Gr({
                    id: "key",
                    type: "text",
                    modelValue: Nt(v),
                    "onUpdate:modelValue": t[2] || (t[2] = e => Bt(v) ? v.value = e : null)
                }, Nt(m), {
                    placeholder: "Digite sua chave PIX...",
                    "aria-invalid": Nt(i).address && Nt(c) > 0
                }), null, 16, ["modelValue", "aria-invalid"])])]), jr(a, {
                    message: Nt(i).address
                }, null, 8, ["message"])]), Dr("div", uE, [jr(n, {
                    for: "document",
                    class: "mb-1"
                }, {
                    default: En( () => t[10] || (t[10] = [Vr("CPF")])),
                    _: 1,
                    __: [10]
                }), Dr("div", cE, [Tn(jr(u, Gr({
                    id: "document",
                    modelValue: Nt(d),
                    "onUpdate:modelValue": t[3] || (t[3] = e => Bt(d) ? d.value = e : null)
                }, Nt(p), {
                    class: "pl-9",
                    placeholder: "000.000.000-00",
                    inputmode: "numeric",
                    "aria-invalid": Nt(i).document && Nt(c) > 0
                }), null, 16, ["modelValue", "aria-invalid"]), [[C, 11 === Nt(vv)(Nt(d)).length ? "###.###.###-##" : "##.###.###/####-##"]]), jr(Nt(sm).Document, {
                    class: "size-4 opacity-35 absolute left-3 top-2/4 -translate-y-2/4"
                })]), jr(a, {
                    message: Nt(i).document
                }, null, 8, ["message"])]), jr(k, {
                    type: "submit",
                    loading: Nt(s),
                    success: y.value
                }, {
                    default: En( () => [Nt(s) || y.value ? Ur("", !0) : (Tr(),
                    Ir(Nt(sm).Withdraw, {
                        key: 0,
                        class: "size-5"
                    })), Vr(" " + ne(Nt(s) ? "Solicitando..." : "Solicitar Saque"), 1)]),
                    _: 1
                }, 8, ["loading", "success"])], 32)]),
                _: 1
            }, 8, ["open"])
        }
    }
})
  , fE = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 48 48",
    class: "text-primary/100"
}
  , hE = {
    transform: "translate(24,24)"
}
  , vE = ["stroke-width"]
  , mE = ["stroke-width"]
  , gE = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [o,a] of t)
        n[o] = a;
    return n
}
  , yE = gE(to({
    __name: "SuccessAnimated",
    props: {
        withCircle: {
            type: Boolean,
            default: !0
        },
        strokeWidth: {
            type: Number,
            default: 2
        }
    },
    setup: e => (t, n) => (Tr(),
    Br("svg", fE, [Dr("g", hE, [Dr("path", {
        class: "CheckSuccess-check",
        stroke: "currentColor",
        fill: "none",
        d: "M-10 1.5c0 0 6.5 6 6.5 6c0 0 13.5-13 13.5-13",
        "stroke-width": e.strokeWidth,
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-dasharray": "28 28",
        "stroke-dashoffset": "28"
    }, null, 8, vE)]), e.withCircle ? (Tr(),
    Br("path", {
        key: 0,
        class: "CheckSuccess-circle",
        stroke: "currentColor",
        fill: "none",
        "stroke-width": e.strokeWidth,
        d: "M23 0c0 12.7-10.3 23-23 23c-12.7 0-23-10.3-23-23c0-12.7 10.3-23 23-23c12.7 0 23 10.3 23 23",
        "stroke-linecap": "round",
        "stroke-dashoffset": "145",
        "stroke-dasharray": "145 145",
        "stroke-linejoin": "round",
        "stroke-miterlimit": "1",
        transform: "translate(24,24) rotate(-35)"
    }, null, 8, mE)) : Ur("", !0)]))
}), [["__scopeId", "data-v-1a214137"]])
  , bE = {
    id: "qr-code-screen"
}
  , wE = {
    class: "text-center pt-5"
}
  , _E = {
    class: "text-2xl font-semibold text-primary mb-4"
}
  , xE = {
    class: "mt-11 mb-3 mx-auto w-fit"
}
  , kE = to({
    __name: "DepositSuccessScreen",
    props: {
        data: {}
    },
    setup: e => (e, t) => {
        const n = yE
          , o = Qv;
        return Tr(),
        Br("div", bE, [Dr("div", wE, [jr(n, {
            class: "size-[6.5rem] mx-auto my-6 text-emerald-500"
        }), Dr("h2", _E, " Depsito de " + ne(Nt(hC)(e.data.amount, !1)) + " efetuado com sucesso! ", 1), t[1] || (t[1] = Dr("p", {
            class: "text-lg text-gray-400"
        }, " Recebemos a confirmao do seu pagamento. ", -1)), Dr("div", xE, [jr(o, {
            class: "mx-auto cursor-pointer"
        }, {
            default: En( () => t[0] || (t[0] = [Vr("Fechar")])),
            _: 1,
            __: [0]
        })])])])
    }
});
function SE(e) {
    if (navigator.clipboard && window.isSecureContext)
        return navigator.clipboard.writeText(e);
    {
        const t = document.activeElement;
        let n = document.createElement("textarea");
        n.value = e,
        n.setAttribute("readonly", ""),
        n.style.contain = "strict",
        n.style.position = "absolute",
        n.style.left = "-9999px",
        n.style.fontSize = "12pt";
        const o = document.getSelection()
          , a = o.rangeCount > 0 && o.getRangeAt(0);
        return document.body.appendChild(n),
        n.focus(),
        n.select(),
        n.selectionStart = 0,
        n.selectionEnd = e.length,
        new Promise(function(e, r) {
            try {
                document.execCommand("copy") ? e() : r()
            } catch (s) {
                r(s)
            } finally {
                n.remove(),
                a && o && (o.removeAllRanges(),
                o.addRange(a)),
                t && t.focus()
            }
        }
        )
    }
}
var CE, EE, TE = {};
var AE, OE = {}, ME = {};
function PE() {
    if (AE)
        return ME;
    let e;
    AE = 1;
    const t = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
    return ME.getSymbolSize = function(e) {
        if (!e)
            throw new Error('"version" cannot be null or undefined');
        if (e < 1 || e > 40)
            throw new Error('"version" should be in range from 1 to 40');
        return 4 * e + 17
    }
    ,
    ME.getSymbolTotalCodewords = function(e) {
        return t[e]
    }
    ,
    ME.getBCHDigit = function(e) {
        let t = 0;
        for (; 0 !== e; )
            t++,
            e >>>= 1;
        return t
    }
    ,
    ME.setToSJISFunction = function(t) {
        if ("function" != typeof t)
            throw new Error('"toSJISFunc" is not a valid function.');
        e = t
    }
    ,
    ME.isKanjiModeEnabled = function() {
        return void 0 !== e
    }
    ,
    ME.toSJIS = function(t) {
        return e(t)
    }
    ,
    ME
}
var BE, IE, LE, RE, zE, NE = {};
function DE() {
    return BE || (BE = 1,
    (e = NE).L = {
        bit: 1
    },
    e.M = {
        bit: 0
    },
    e.Q = {
        bit: 3
    },
    e.H = {
        bit: 2
    },
    e.isValid = function(e) {
        return e && void 0 !== e.bit && e.bit >= 0 && e.bit < 4
    }
    ,
    e.from = function(t, n) {
        if (e.isValid(t))
            return t;
        try {
            return function(t) {
                if ("string" != typeof t)
                    throw new Error("Param is not a string");
                switch (t.toLowerCase()) {
                case "l":
                case "low":
                    return e.L;
                case "m":
                case "medium":
                    return e.M;
                case "q":
                case "quartile":
                    return e.Q;
                case "h":
                case "high":
                    return e.H;
                default:
                    throw new Error("Unknown EC Level: " + t)
                }
            }(t)
        } catch (pC) {
            return n
        }
    }
    ),
    NE;
    var e
}
var jE, FE = {};
var $E, VE = {};
var HE, UE = {};
var ZE, qE = {};
function WE() {
    if (ZE)
        return qE;
    ZE = 1;
    const e = DE()
      , t = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81]
      , n = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
    return qE.getBlocksCount = function(n, o) {
        switch (o) {
        case e.L:
            return t[4 * (n - 1) + 0];
        case e.M:
            return t[4 * (n - 1) + 1];
        case e.Q:
            return t[4 * (n - 1) + 2];
        case e.H:
            return t[4 * (n - 1) + 3];
        default:
            return
        }
    }
    ,
    qE.getTotalCodewordsCount = function(t, o) {
        switch (o) {
        case e.L:
            return n[4 * (t - 1) + 0];
        case e.M:
            return n[4 * (t - 1) + 1];
        case e.Q:
            return n[4 * (t - 1) + 2];
        case e.H:
            return n[4 * (t - 1) + 3];
        default:
            return
        }
    }
    ,
    qE
}
var GE, KE, YE, XE, JE = {}, QE = {};
function eT() {
    return KE || (KE = 1,
    function(e) {
        const t = function() {
            if (GE)
                return QE;
            GE = 1;
            const e = new Uint8Array(512)
              , t = new Uint8Array(256);
            return function() {
                let n = 1;
                for (let o = 0; o < 255; o++)
                    e[o] = n,
                    t[n] = o,
                    n <<= 1,
                    256 & n && (n ^= 285);
                for (let t = 255; t < 512; t++)
                    e[t] = e[t - 255]
            }(),
            QE.log = function(e) {
                if (e < 1)
                    throw new Error("log(" + e + ")");
                return t[e]
            }
            ,
            QE.exp = function(t) {
                return e[t]
            }
            ,
            QE.mul = function(n, o) {
                return 0 === n || 0 === o ? 0 : e[t[n] + t[o]]
            }
            ,
            QE
        }();
        e.mul = function(e, n) {
            const o = new Uint8Array(e.length + n.length - 1);
            for (let a = 0; a < e.length; a++)
                for (let r = 0; r < n.length; r++)
                    o[a + r] ^= t.mul(e[a], n[r]);
            return o
        }
        ,
        e.mod = function(e, n) {
            let o = new Uint8Array(e);
            for (; o.length - n.length >= 0; ) {
                const e = o[0];
                for (let r = 0; r < n.length; r++)
                    o[r] ^= t.mul(n[r], e);
                let a = 0;
                for (; a < o.length && 0 === o[a]; )
                    a++;
                o = o.slice(a)
            }
            return o
        }
        ,
        e.generateECPolynomial = function(n) {
            let o = new Uint8Array([1]);
            for (let a = 0; a < n; a++)
                o = e.mul(o, new Uint8Array([1, t.exp(a)]));
            return o
        }
    }(JE)),
    JE
}
var tT, nT = {}, oT = {}, aT = {};
function rT() {
    return tT || (tT = 1,
    aT.isValid = function(e) {
        return !isNaN(e) && e >= 1 && e <= 40
    }
    ),
    aT
}
var sT, iT, lT, uT = {};
function cT() {
    if (sT)
        return uT;
    sT = 1;
    const e = "[0-9]+";
    let t = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    t = t.replace(/u/g, "\\u");
    const n = "(?:(?![A-Z0-9 $%*+\\-./:]|" + t + ")(?:.|[\r\n]))+";
    uT.KANJI = new RegExp(t,"g"),
    uT.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+","g"),
    uT.BYTE = new RegExp(n,"g"),
    uT.NUMERIC = new RegExp(e,"g"),
    uT.ALPHANUMERIC = new RegExp("[A-Z $%*+\\-./:]+","g");
    const o = new RegExp("^" + t + "$")
      , a = new RegExp("^" + e + "$")
      , r = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    return uT.testKanji = function(e) {
        return o.test(e)
    }
    ,
    uT.testNumeric = function(e) {
        return a.test(e)
    }
    ,
    uT.testAlphanumeric = function(e) {
        return r.test(e)
    }
    ,
    uT
}
function dT() {
    return iT || (iT = 1,
    function(e) {
        const t = rT()
          , n = cT();
        e.NUMERIC = {
            id: "Numeric",
            bit: 1,
            ccBits: [10, 12, 14]
        },
        e.ALPHANUMERIC = {
            id: "Alphanumeric",
            bit: 2,
            ccBits: [9, 11, 13]
        },
        e.BYTE = {
            id: "Byte",
            bit: 4,
            ccBits: [8, 16, 16]
        },
        e.KANJI = {
            id: "Kanji",
            bit: 8,
            ccBits: [8, 10, 12]
        },
        e.MIXED = {
            bit: -1
        },
        e.getCharCountIndicator = function(e, n) {
            if (!e.ccBits)
                throw new Error("Invalid mode: " + e);
            if (!t.isValid(n))
                throw new Error("Invalid version: " + n);
            return n >= 1 && n < 10 ? e.ccBits[0] : n < 27 ? e.ccBits[1] : e.ccBits[2]
        }
        ,
        e.getBestModeForData = function(t) {
            return n.testNumeric(t) ? e.NUMERIC : n.testAlphanumeric(t) ? e.ALPHANUMERIC : n.testKanji(t) ? e.KANJI : e.BYTE
        }
        ,
        e.toString = function(e) {
            if (e && e.id)
                return e.id;
            throw new Error("Invalid mode")
        }
        ,
        e.isValid = function(e) {
            return e && e.bit && e.ccBits
        }
        ,
        e.from = function(t, n) {
            if (e.isValid(t))
                return t;
            try {
                return function(t) {
                    if ("string" != typeof t)
                        throw new Error("Param is not a string");
                    switch (t.toLowerCase()) {
                    case "numeric":
                        return e.NUMERIC;
                    case "alphanumeric":
                        return e.ALPHANUMERIC;
                    case "kanji":
                        return e.KANJI;
                    case "byte":
                        return e.BYTE;
                    default:
                        throw new Error("Unknown mode: " + t)
                    }
                }(t)
            } catch (pC) {
                return n
            }
        }
    }(oT)),
    oT
}
function pT() {
    return lT || (lT = 1,
    function(e) {
        const t = PE()
          , n = WE()
          , o = DE()
          , a = dT()
          , r = rT()
          , s = t.getBCHDigit(7973);
        function i(e, t) {
            return a.getCharCountIndicator(e, t) + 4
        }
        function l(e, t) {
            let n = 0;
            return e.forEach(function(e) {
                const o = i(e.mode, t);
                n += o + e.getBitsLength()
            }),
            n
        }
        e.from = function(e, t) {
            return r.isValid(e) ? parseInt(e, 10) : t
        }
        ,
        e.getCapacity = function(e, o, s) {
            if (!r.isValid(e))
                throw new Error("Invalid QR Code version");
            void 0 === s && (s = a.BYTE);
            const l = 8 * (t.getSymbolTotalCodewords(e) - n.getTotalCodewordsCount(e, o));
            if (s === a.MIXED)
                return l;
            const u = l - i(s, e);
            switch (s) {
            case a.NUMERIC:
                return Math.floor(u / 10 * 3);
            case a.ALPHANUMERIC:
                return Math.floor(u / 11 * 2);
            case a.KANJI:
                return Math.floor(u / 13);
            case a.BYTE:
            default:
                return Math.floor(u / 8)
            }
        }
        ,
        e.getBestVersionForData = function(t, n) {
            let r;
            const s = o.from(n, o.M);
            if (Array.isArray(t)) {
                if (t.length > 1)
                    return function(t, n) {
                        for (let o = 1; o <= 40; o++)
                            if (l(t, o) <= e.getCapacity(o, n, a.MIXED))
                                return o
                    }(t, s);
                if (0 === t.length)
                    return 1;
                r = t[0]
            } else
                r = t;
            return function(t, n, o) {
                for (let a = 1; a <= 40; a++)
                    if (n <= e.getCapacity(a, o, t))
                        return a
            }(r.mode, r.getLength(), s)
        }
        ,
        e.getEncodedBits = function(e) {
            if (!r.isValid(e) || e < 7)
                throw new Error("Invalid QR Code version");
            let n = e << 12;
            for (; t.getBCHDigit(n) - s >= 0; )
                n ^= 7973 << t.getBCHDigit(n) - s;
            return e << 12 | n
        }
    }(nT)),
    nT
}
var fT, hT = {};
var vT, mT, gT, yT, bT, wT, _T, xT, kT = {};
var ST, CT, ET, TT = {
    exports: {}
};
function AT() {
    return CT || (CT = 1,
    function(e) {
        const t = dT()
          , n = function() {
            if (mT)
                return vT;
            mT = 1;
            const e = dT();
            function t(t) {
                this.mode = e.NUMERIC,
                this.data = t.toString()
            }
            return t.getBitsLength = function(e) {
                return 10 * Math.floor(e / 3) + (e % 3 ? e % 3 * 3 + 1 : 0)
            }
            ,
            t.prototype.getLength = function() {
                return this.data.length
            }
            ,
            t.prototype.getBitsLength = function() {
                return t.getBitsLength(this.data.length)
            }
            ,
            t.prototype.write = function(e) {
                let t, n, o;
                for (t = 0; t + 3 <= this.data.length; t += 3)
                    n = this.data.substr(t, 3),
                    o = parseInt(n, 10),
                    e.put(o, 10);
                const a = this.data.length - t;
                a > 0 && (n = this.data.substr(t),
                o = parseInt(n, 10),
                e.put(o, 3 * a + 1))
            }
            ,
            vT = t
        }()
          , o = function() {
            if (yT)
                return gT;
            yT = 1;
            const e = dT()
              , t = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
            function n(t) {
                this.mode = e.ALPHANUMERIC,
                this.data = t
            }
            return n.getBitsLength = function(e) {
                return 11 * Math.floor(e / 2) + e % 2 * 6
            }
            ,
            n.prototype.getLength = function() {
                return this.data.length
            }
            ,
            n.prototype.getBitsLength = function() {
                return n.getBitsLength(this.data.length)
            }
            ,
            n.prototype.write = function(e) {
                let n;
                for (n = 0; n + 2 <= this.data.length; n += 2) {
                    let o = 45 * t.indexOf(this.data[n]);
                    o += t.indexOf(this.data[n + 1]),
                    e.put(o, 11)
                }
                this.data.length % 2 && e.put(t.indexOf(this.data[n]), 6)
            }
            ,
            gT = n
        }()
          , a = function() {
            if (wT)
                return bT;
            wT = 1;
            const e = dT();
            function t(t) {
                this.mode = e.BYTE,
                this.data = "string" == typeof t ? (new TextEncoder).encode(t) : new Uint8Array(t)
            }
            return t.getBitsLength = function(e) {
                return 8 * e
            }
            ,
            t.prototype.getLength = function() {
                return this.data.length
            }
            ,
            t.prototype.getBitsLength = function() {
                return t.getBitsLength(this.data.length)
            }
            ,
            t.prototype.write = function(e) {
                for (let t = 0, n = this.data.length; t < n; t++)
                    e.put(this.data[t], 8)
            }
            ,
            bT = t
        }()
          , r = function() {
            if (xT)
                return _T;
            xT = 1;
            const e = dT()
              , t = PE();
            function n(t) {
                this.mode = e.KANJI,
                this.data = t
            }
            return n.getBitsLength = function(e) {
                return 13 * e
            }
            ,
            n.prototype.getLength = function() {
                return this.data.length
            }
            ,
            n.prototype.getBitsLength = function() {
                return n.getBitsLength(this.data.length)
            }
            ,
            n.prototype.write = function(e) {
                let n;
                for (n = 0; n < this.data.length; n++) {
                    let o = t.toSJIS(this.data[n]);
                    if (o >= 33088 && o <= 40956)
                        o -= 33088;
                    else {
                        if (!(o >= 57408 && o <= 60351))
                            throw new Error("Invalid SJIS character: " + this.data[n] + "\nMake sure your charset is UTF-8");
                        o -= 49472
                    }
                    o = 192 * (o >>> 8 & 255) + (255 & o),
                    e.put(o, 13)
                }
            }
            ,
            _T = n
        }()
          , s = cT()
          , i = PE()
          , l = function() {
            return ST ? TT.exports : (ST = 1,
            TT.exports = e = {
                single_source_shortest_paths: function(t, n, o) {
                    var a = {}
                      , r = {};
                    r[n] = 0;
                    var s, i, l, u, c, d, p, f = e.PriorityQueue.make();
                    for (f.push(n, 0); !f.empty(); )
                        for (l in i = (s = f.pop()).value,
                        u = s.cost,
                        c = t[i] || {})
                            c.hasOwnProperty(l) && (d = u + c[l],
                            p = r[l],
                            (void 0 === r[l] || p > d) && (r[l] = d,
                            f.push(l, d),
                            a[l] = i));
                    if (void 0 !== o && void 0 === r[o]) {
                        var h = ["Could not find a path from ", n, " to ", o, "."].join("");
                        throw new Error(h)
                    }
                    return a
                },
                extract_shortest_path_from_predecessor_list: function(e, t) {
                    for (var n = [], o = t; o; )
                        n.push(o),
                        e[o],
                        o = e[o];
                    return n.reverse(),
                    n
                },
                find_path: function(t, n, o) {
                    var a = e.single_source_shortest_paths(t, n, o);
                    return e.extract_shortest_path_from_predecessor_list(a, o)
                },
                PriorityQueue: {
                    make: function(t) {
                        var n, o = e.PriorityQueue, a = {};
                        for (n in t = t || {},
                        o)
                            o.hasOwnProperty(n) && (a[n] = o[n]);
                        return a.queue = [],
                        a.sorter = t.sorter || o.default_sorter,
                        a
                    },
                    default_sorter: function(e, t) {
                        return e.cost - t.cost
                    },
                    push: function(e, t) {
                        var n = {
                            value: e,
                            cost: t
                        };
                        this.queue.push(n),
                        this.queue.sort(this.sorter)
                    },
                    pop: function() {
                        return this.queue.shift()
                    },
                    empty: function() {
                        return 0 === this.queue.length
                    }
                }
            });
            var e
        }();
        function u(e) {
            return unescape(encodeURIComponent(e)).length
        }
        function c(e, t, n) {
            const o = [];
            let a;
            for (; null !== (a = e.exec(n)); )
                o.push({
                    data: a[0],
                    index: a.index,
                    mode: t,
                    length: a[0].length
                });
            return o
        }
        function d(e) {
            const n = c(s.NUMERIC, t.NUMERIC, e)
              , o = c(s.ALPHANUMERIC, t.ALPHANUMERIC, e);
            let a, r;
            i.isKanjiModeEnabled() ? (a = c(s.BYTE, t.BYTE, e),
            r = c(s.KANJI, t.KANJI, e)) : (a = c(s.BYTE_KANJI, t.BYTE, e),
            r = []);
            return n.concat(o, a, r).sort(function(e, t) {
                return e.index - t.index
            }).map(function(e) {
                return {
                    data: e.data,
                    mode: e.mode,
                    length: e.length
                }
            })
        }
        function p(e, s) {
            switch (s) {
            case t.NUMERIC:
                return n.getBitsLength(e);
            case t.ALPHANUMERIC:
                return o.getBitsLength(e);
            case t.KANJI:
                return r.getBitsLength(e);
            case t.BYTE:
                return a.getBitsLength(e)
            }
        }
        function f(e, s) {
            let l;
            const u = t.getBestModeForData(e);
            if (l = t.from(s, u),
            l !== t.BYTE && l.bit < u.bit)
                throw new Error('"' + e + '" cannot be encoded with mode ' + t.toString(l) + ".\n Suggested mode is: " + t.toString(u));
            switch (l !== t.KANJI || i.isKanjiModeEnabled() || (l = t.BYTE),
            l) {
            case t.NUMERIC:
                return new n(e);
            case t.ALPHANUMERIC:
                return new o(e);
            case t.KANJI:
                return new r(e);
            case t.BYTE:
                return new a(e)
            }
        }
        e.fromArray = function(e) {
            return e.reduce(function(e, t) {
                return "string" == typeof t ? e.push(f(t, null)) : t.data && e.push(f(t.data, t.mode)),
                e
            }, [])
        }
        ,
        e.fromString = function(n, o) {
            const a = function(e) {
                const n = [];
                for (let o = 0; o < e.length; o++) {
                    const a = e[o];
                    switch (a.mode) {
                    case t.NUMERIC:
                        n.push([a, {
                            data: a.data,
                            mode: t.ALPHANUMERIC,
                            length: a.length
                        }, {
                            data: a.data,
                            mode: t.BYTE,
                            length: a.length
                        }]);
                        break;
                    case t.ALPHANUMERIC:
                        n.push([a, {
                            data: a.data,
                            mode: t.BYTE,
                            length: a.length
                        }]);
                        break;
                    case t.KANJI:
                        n.push([a, {
                            data: a.data,
                            mode: t.BYTE,
                            length: u(a.data)
                        }]);
                        break;
                    case t.BYTE:
                        n.push([{
                            data: a.data,
                            mode: t.BYTE,
                            length: u(a.data)
                        }])
                    }
                }
                return n
            }(d(n, i.isKanjiModeEnabled()))
              , r = function(e, n) {
                const o = {}
                  , a = {
                    start: {}
                };
                let r = ["start"];
                for (let s = 0; s < e.length; s++) {
                    const i = e[s]
                      , l = [];
                    for (let e = 0; e < i.length; e++) {
                        const u = i[e]
                          , c = "" + s + e;
                        l.push(c),
                        o[c] = {
                            node: u,
                            lastCount: 0
                        },
                        a[c] = {};
                        for (let e = 0; e < r.length; e++) {
                            const s = r[e];
                            o[s] && o[s].node.mode === u.mode ? (a[s][c] = p(o[s].lastCount + u.length, u.mode) - p(o[s].lastCount, u.mode),
                            o[s].lastCount += u.length) : (o[s] && (o[s].lastCount = u.length),
                            a[s][c] = p(u.length, u.mode) + 4 + t.getCharCountIndicator(u.mode, n))
                        }
                    }
                    r = l
                }
                for (let t = 0; t < r.length; t++)
                    a[r[t]].end = 0;
                return {
                    map: a,
                    table: o
                }
            }(a, o)
              , s = l.find_path(r.map, "start", "end")
              , c = [];
            for (let e = 1; e < s.length - 1; e++)
                c.push(r.table[s[e]].node);
            return e.fromArray(function(e) {
                return e.reduce(function(e, t) {
                    const n = e.length - 1 >= 0 ? e[e.length - 1] : null;
                    return n && n.mode === t.mode ? (e[e.length - 1].data += t.data,
                    e) : (e.push(t),
                    e)
                }, [])
            }(c))
        }
        ,
        e.rawSplit = function(t) {
            return e.fromArray(d(t, i.isKanjiModeEnabled()))
        }
    }(kT)),
    kT
}
function OT() {
    if (ET)
        return OE;
    ET = 1;
    const e = PE()
      , t = DE()
      , n = function() {
        if (LE)
            return IE;
        function e() {
            this.buffer = [],
            this.length = 0
        }
        return LE = 1,
        e.prototype = {
            get: function(e) {
                const t = Math.floor(e / 8);
                return 1 == (this.buffer[t] >>> 7 - e % 8 & 1)
            },
            put: function(e, t) {
                for (let n = 0; n < t; n++)
                    this.putBit(1 == (e >>> t - n - 1 & 1))
            },
            getLengthInBits: function() {
                return this.length
            },
            putBit: function(e) {
                const t = Math.floor(this.length / 8);
                this.buffer.length <= t && this.buffer.push(0),
                e && (this.buffer[t] |= 128 >>> this.length % 8),
                this.length++
            }
        },
        IE = e
    }()
      , o = function() {
        if (zE)
            return RE;
        function e(e) {
            if (!e || e < 1)
                throw new Error("BitMatrix size must be defined and greater than 0");
            this.size = e,
            this.data = new Uint8Array(e * e),
            this.reservedBit = new Uint8Array(e * e)
        }
        return zE = 1,
        e.prototype.set = function(e, t, n, o) {
            const a = e * this.size + t;
            this.data[a] = n,
            o && (this.reservedBit[a] = !0)
        }
        ,
        e.prototype.get = function(e, t) {
            return this.data[e * this.size + t]
        }
        ,
        e.prototype.xor = function(e, t, n) {
            this.data[e * this.size + t] ^= n
        }
        ,
        e.prototype.isReserved = function(e, t) {
            return this.reservedBit[e * this.size + t]
        }
        ,
        RE = e
    }()
      , a = (jE || (jE = 1,
    function(e) {
        const t = PE().getSymbolSize;
        e.getRowColCoords = function(e) {
            if (1 === e)
                return [];
            const n = Math.floor(e / 7) + 2
              , o = t(e)
              , a = 145 === o ? 26 : 2 * Math.ceil((o - 13) / (2 * n - 2))
              , r = [o - 7];
            for (let t = 1; t < n - 1; t++)
                r[t] = r[t - 1] - a;
            return r.push(6),
            r.reverse()
        }
        ,
        e.getPositions = function(t) {
            const n = []
              , o = e.getRowColCoords(t)
              , a = o.length;
            for (let e = 0; e < a; e++)
                for (let t = 0; t < a; t++)
                    0 === e && 0 === t || 0 === e && t === a - 1 || e === a - 1 && 0 === t || n.push([o[e], o[t]]);
            return n
        }
    }(FE)),
    FE)
      , r = function() {
        if ($E)
            return VE;
        $E = 1;
        const e = PE().getSymbolSize;
        return VE.getPositions = function(t) {
            const n = e(t);
            return [[0, 0], [n - 7, 0], [0, n - 7]]
        }
        ,
        VE
    }()
      , s = (HE || (HE = 1,
    function(e) {
        e.Patterns = {
            PATTERN000: 0,
            PATTERN001: 1,
            PATTERN010: 2,
            PATTERN011: 3,
            PATTERN100: 4,
            PATTERN101: 5,
            PATTERN110: 6,
            PATTERN111: 7
        };
        const t = 3
          , n = 3
          , o = 40
          , a = 10;
        function r(t, n, o) {
            switch (t) {
            case e.Patterns.PATTERN000:
                return (n + o) % 2 == 0;
            case e.Patterns.PATTERN001:
                return n % 2 == 0;
            case e.Patterns.PATTERN010:
                return o % 3 == 0;
            case e.Patterns.PATTERN011:
                return (n + o) % 3 == 0;
            case e.Patterns.PATTERN100:
                return (Math.floor(n / 2) + Math.floor(o / 3)) % 2 == 0;
            case e.Patterns.PATTERN101:
                return n * o % 2 + n * o % 3 == 0;
            case e.Patterns.PATTERN110:
                return (n * o % 2 + n * o % 3) % 2 == 0;
            case e.Patterns.PATTERN111:
                return (n * o % 3 + (n + o) % 2) % 2 == 0;
            default:
                throw new Error("bad maskPattern:" + t)
            }
        }
        e.isValid = function(e) {
            return null != e && "" !== e && !isNaN(e) && e >= 0 && e <= 7
        }
        ,
        e.from = function(t) {
            return e.isValid(t) ? parseInt(t, 10) : void 0
        }
        ,
        e.getPenaltyN1 = function(e) {
            const n = e.size;
            let o = 0
              , a = 0
              , r = 0
              , s = null
              , i = null;
            for (let l = 0; l < n; l++) {
                a = r = 0,
                s = i = null;
                for (let u = 0; u < n; u++) {
                    let n = e.get(l, u);
                    n === s ? a++ : (a >= 5 && (o += t + (a - 5)),
                    s = n,
                    a = 1),
                    n = e.get(u, l),
                    n === i ? r++ : (r >= 5 && (o += t + (r - 5)),
                    i = n,
                    r = 1)
                }
                a >= 5 && (o += t + (a - 5)),
                r >= 5 && (o += t + (r - 5))
            }
            return o
        }
        ,
        e.getPenaltyN2 = function(e) {
            const t = e.size;
            let o = 0;
            for (let n = 0; n < t - 1; n++)
                for (let a = 0; a < t - 1; a++) {
                    const t = e.get(n, a) + e.get(n, a + 1) + e.get(n + 1, a) + e.get(n + 1, a + 1);
                    4 !== t && 0 !== t || o++
                }
            return o * n
        }
        ,
        e.getPenaltyN3 = function(e) {
            const t = e.size;
            let n = 0
              , a = 0
              , r = 0;
            for (let o = 0; o < t; o++) {
                a = r = 0;
                for (let s = 0; s < t; s++)
                    a = a << 1 & 2047 | e.get(o, s),
                    s >= 10 && (1488 === a || 93 === a) && n++,
                    r = r << 1 & 2047 | e.get(s, o),
                    s >= 10 && (1488 === r || 93 === r) && n++
            }
            return n * o
        }
        ,
        e.getPenaltyN4 = function(e) {
            let t = 0;
            const n = e.data.length;
            for (let o = 0; o < n; o++)
                t += e.data[o];
            return Math.abs(Math.ceil(100 * t / n / 5) - 10) * a
        }
        ,
        e.applyMask = function(e, t) {
            const n = t.size;
            for (let o = 0; o < n; o++)
                for (let a = 0; a < n; a++)
                    t.isReserved(a, o) || t.xor(a, o, r(e, a, o))
        }
        ,
        e.getBestMask = function(t, n) {
            const o = Object.keys(e.Patterns).length;
            let a = 0
              , r = 1 / 0;
            for (let s = 0; s < o; s++) {
                n(s),
                e.applyMask(s, t);
                const o = e.getPenaltyN1(t) + e.getPenaltyN2(t) + e.getPenaltyN3(t) + e.getPenaltyN4(t);
                e.applyMask(s, t),
                o < r && (r = o,
                a = s)
            }
            return a
        }
    }(UE)),
    UE)
      , i = WE()
      , l = function() {
        if (XE)
            return YE;
        XE = 1;
        const e = eT();
        function t(e) {
            this.genPoly = void 0,
            this.degree = e,
            this.degree && this.initialize(this.degree)
        }
        return t.prototype.initialize = function(t) {
            this.degree = t,
            this.genPoly = e.generateECPolynomial(this.degree)
        }
        ,
        t.prototype.encode = function(t) {
            if (!this.genPoly)
                throw new Error("Encoder not initialized");
            const n = new Uint8Array(t.length + this.degree);
            n.set(t);
            const o = e.mod(n, this.genPoly)
              , a = this.degree - o.length;
            if (a > 0) {
                const e = new Uint8Array(this.degree);
                return e.set(o, a),
                e
            }
            return o
        }
        ,
        YE = t
    }()
      , u = pT()
      , c = function() {
        if (fT)
            return hT;
        fT = 1;
        const e = PE()
          , t = e.getBCHDigit(1335);
        return hT.getEncodedBits = function(n, o) {
            const a = n.bit << 3 | o;
            let r = a << 10;
            for (; e.getBCHDigit(r) - t >= 0; )
                r ^= 1335 << e.getBCHDigit(r) - t;
            return 21522 ^ (a << 10 | r)
        }
        ,
        hT
    }()
      , d = dT()
      , p = AT();
    function f(e, t, n) {
        const o = e.size
          , a = c.getEncodedBits(t, n);
        let r, s;
        for (r = 0; r < 15; r++)
            s = 1 == (a >> r & 1),
            r < 6 ? e.set(r, 8, s, !0) : r < 8 ? e.set(r + 1, 8, s, !0) : e.set(o - 15 + r, 8, s, !0),
            r < 8 ? e.set(8, o - r - 1, s, !0) : r < 9 ? e.set(8, 15 - r - 1 + 1, s, !0) : e.set(8, 15 - r - 1, s, !0);
        e.set(o - 8, 8, 1, !0)
    }
    function h(t, o, a) {
        const r = new n;
        a.forEach(function(e) {
            r.put(e.mode.bit, 4),
            r.put(e.getLength(), d.getCharCountIndicator(e.mode, t)),
            e.write(r)
        });
        const s = 8 * (e.getSymbolTotalCodewords(t) - i.getTotalCodewordsCount(t, o));
        for (r.getLengthInBits() + 4 <= s && r.put(0, 4); r.getLengthInBits() % 8 != 0; )
            r.putBit(0);
        const u = (s - r.getLengthInBits()) / 8;
        for (let e = 0; e < u; e++)
            r.put(e % 2 ? 17 : 236, 8);
        return function(t, n, o) {
            const a = e.getSymbolTotalCodewords(n)
              , r = i.getTotalCodewordsCount(n, o)
              , s = a - r
              , u = i.getBlocksCount(n, o)
              , c = a % u
              , d = u - c
              , p = Math.floor(a / u)
              , f = Math.floor(s / u)
              , h = f + 1
              , v = p - f
              , m = new l(v);
            let g = 0;
            const y = new Array(u)
              , b = new Array(u);
            let w = 0;
            const _ = new Uint8Array(t.buffer);
            for (let e = 0; e < u; e++) {
                const t = e < d ? f : h;
                y[e] = _.slice(g, g + t),
                b[e] = m.encode(y[e]),
                g += t,
                w = Math.max(w, t)
            }
            const x = new Uint8Array(a);
            let k, S, C = 0;
            for (k = 0; k < w; k++)
                for (S = 0; S < u; S++)
                    k < y[S].length && (x[C++] = y[S][k]);
            for (k = 0; k < v; k++)
                for (S = 0; S < u; S++)
                    x[C++] = b[S][k];
            return x
        }(r, t, o)
    }
    function v(t, n, i, l) {
        let c;
        if (Array.isArray(t))
            c = p.fromArray(t);
        else {
            if ("string" != typeof t)
                throw new Error("Invalid data");
            {
                let e = n;
                if (!e) {
                    const n = p.rawSplit(t);
                    e = u.getBestVersionForData(n, i)
                }
                c = p.fromString(t, e || 40)
            }
        }
        const d = u.getBestVersionForData(c, i);
        if (!d)
            throw new Error("The amount of data is too big to be stored in a QR Code");
        if (n) {
            if (n < d)
                throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + d + ".\n")
        } else
            n = d;
        const v = h(n, i, c)
          , m = e.getSymbolSize(n)
          , g = new o(m);
        return function(e, t) {
            const n = e.size
              , o = r.getPositions(t);
            for (let a = 0; a < o.length; a++) {
                const t = o[a][0]
                  , r = o[a][1];
                for (let o = -1; o <= 7; o++)
                    if (!(t + o <= -1 || n <= t + o))
                        for (let a = -1; a <= 7; a++)
                            r + a <= -1 || n <= r + a || (o >= 0 && o <= 6 && (0 === a || 6 === a) || a >= 0 && a <= 6 && (0 === o || 6 === o) || o >= 2 && o <= 4 && a >= 2 && a <= 4 ? e.set(t + o, r + a, !0, !0) : e.set(t + o, r + a, !1, !0))
            }
        }(g, n),
        function(e) {
            const t = e.size;
            for (let n = 8; n < t - 8; n++) {
                const t = n % 2 == 0;
                e.set(n, 6, t, !0),
                e.set(6, n, t, !0)
            }
        }(g),
        function(e, t) {
            const n = a.getPositions(t);
            for (let o = 0; o < n.length; o++) {
                const t = n[o][0]
                  , a = n[o][1];
                for (let n = -2; n <= 2; n++)
                    for (let o = -2; o <= 2; o++)
                        -2 === n || 2 === n || -2 === o || 2 === o || 0 === n && 0 === o ? e.set(t + n, a + o, !0, !0) : e.set(t + n, a + o, !1, !0)
            }
        }(g, n),
        f(g, i, 0),
        n >= 7 && function(e, t) {
            const n = e.size
              , o = u.getEncodedBits(t);
            let a, r, s;
            for (let i = 0; i < 18; i++)
                a = Math.floor(i / 3),
                r = i % 3 + n - 8 - 3,
                s = 1 == (o >> i & 1),
                e.set(a, r, s, !0),
                e.set(r, a, s, !0)
        }(g, n),
        function(e, t) {
            const n = e.size;
            let o = -1
              , a = n - 1
              , r = 7
              , s = 0;
            for (let i = n - 1; i > 0; i -= 2)
                for (6 === i && i--; ; ) {
                    for (let n = 0; n < 2; n++)
                        if (!e.isReserved(a, i - n)) {
                            let o = !1;
                            s < t.length && (o = 1 == (t[s] >>> r & 1)),
                            e.set(a, i - n, o),
                            r--,
                            -1 === r && (s++,
                            r = 7)
                        }
                    if (a += o,
                    a < 0 || n <= a) {
                        a -= o,
                        o = -o;
                        break
                    }
                }
        }(g, v),
        isNaN(l) && (l = s.getBestMask(g, f.bind(null, g, i))),
        s.applyMask(l, g),
        f(g, i, l),
        {
            modules: g,
            version: n,
            errorCorrectionLevel: i,
            maskPattern: l,
            segments: c
        }
    }
    return OE.create = function(n, o) {
        if (void 0 === n || "" === n)
            throw new Error("No input text");
        let a, r, i = t.M;
        return void 0 !== o && (i = t.from(o.errorCorrectionLevel, t.M),
        a = u.from(o.version),
        r = s.from(o.maskPattern),
        o.toSJISFunc && e.setToSJISFunction(o.toSJISFunc)),
        v(n, a, i, r)
    }
    ,
    OE
}
var MT, PT, BT = {}, IT = {};
function LT() {
    return MT || (MT = 1,
    function(e) {
        function t(e) {
            if ("number" == typeof e && (e = e.toString()),
            "string" != typeof e)
                throw new Error("Color should be defined as hex string");
            let t = e.slice().replace("#", "").split("");
            if (t.length < 3 || 5 === t.length || t.length > 8)
                throw new Error("Invalid hex color: " + e);
            3 !== t.length && 4 !== t.length || (t = Array.prototype.concat.apply([], t.map(function(e) {
                return [e, e]
            }))),
            6 === t.length && t.push("F", "F");
            const n = parseInt(t.join(""), 16);
            return {
                r: n >> 24 & 255,
                g: n >> 16 & 255,
                b: n >> 8 & 255,
                a: 255 & n,
                hex: "#" + t.slice(0, 6).join("")
            }
        }
        e.getOptions = function(e) {
            e || (e = {}),
            e.color || (e.color = {});
            const n = void 0 === e.margin || null === e.margin || e.margin < 0 ? 4 : e.margin
              , o = e.width && e.width >= 21 ? e.width : void 0
              , a = e.scale || 4;
            return {
                width: o,
                scale: o ? 4 : a,
                margin: n,
                color: {
                    dark: t(e.color.dark || "#000000ff"),
                    light: t(e.color.light || "#ffffffff")
                },
                type: e.type,
                rendererOpts: e.rendererOpts || {}
            }
        }
        ,
        e.getScale = function(e, t) {
            return t.width && t.width >= e + 2 * t.margin ? t.width / (e + 2 * t.margin) : t.scale
        }
        ,
        e.getImageWidth = function(t, n) {
            const o = e.getScale(t, n);
            return Math.floor((t + 2 * n.margin) * o)
        }
        ,
        e.qrToImageData = function(t, n, o) {
            const a = n.modules.size
              , r = n.modules.data
              , s = e.getScale(a, o)
              , i = Math.floor((a + 2 * o.margin) * s)
              , l = o.margin * s
              , u = [o.color.light, o.color.dark];
            for (let e = 0; e < i; e++)
                for (let n = 0; n < i; n++) {
                    let c = 4 * (e * i + n)
                      , d = o.color.light;
                    if (e >= l && n >= l && e < i - l && n < i - l) {
                        d = u[r[Math.floor((e - l) / s) * a + Math.floor((n - l) / s)] ? 1 : 0]
                    }
                    t[c++] = d.r,
                    t[c++] = d.g,
                    t[c++] = d.b,
                    t[c] = d.a
                }
        }
    }(IT)),
    IT
}
function RT() {
    return PT || (PT = 1,
    function(e) {
        const t = LT();
        e.render = function(e, n, o) {
            let a = o
              , r = n;
            void 0 !== a || n && n.getContext || (a = n,
            n = void 0),
            n || (r = function() {
                try {
                    return document.createElement("canvas")
                } catch (pC) {
                    throw new Error("You need to specify a canvas element")
                }
            }()),
            a = t.getOptions(a);
            const s = t.getImageWidth(e.modules.size, a)
              , i = r.getContext("2d")
              , l = i.createImageData(s, s);
            return t.qrToImageData(l.data, e, a),
            function(e, t, n) {
                e.clearRect(0, 0, t.width, t.height),
                t.style || (t.style = {}),
                t.height = n,
                t.width = n,
                t.style.height = n + "px",
                t.style.width = n + "px"
            }(i, r, s),
            i.putImageData(l, 0, 0),
            r
        }
        ,
        e.renderToDataURL = function(t, n, o) {
            let a = o;
            void 0 !== a || n && n.getContext || (a = n,
            n = void 0),
            a || (a = {});
            const r = e.render(t, n, a)
              , s = a.type || "image/png"
              , i = a.rendererOpts || {};
            return r.toDataURL(s, i.quality)
        }
    }(BT)),
    BT
}
var zT, NT, DT = {};
function jT() {
    if (zT)
        return DT;
    zT = 1;
    const e = LT();
    function t(e, t) {
        const n = e.a / 255
          , o = t + '="' + e.hex + '"';
        return n < 1 ? o + " " + t + '-opacity="' + n.toFixed(2).slice(1) + '"' : o
    }
    function n(e, t, n) {
        let o = e + t;
        return void 0 !== n && (o += " " + n),
        o
    }
    return DT.render = function(o, a, r) {
        const s = e.getOptions(a)
          , i = o.modules.size
          , l = o.modules.data
          , u = i + 2 * s.margin
          , c = s.color.light.a ? "<path " + t(s.color.light, "fill") + ' d="M0 0h' + u + "v" + u + 'H0z"/>' : ""
          , d = "<path " + t(s.color.dark, "stroke") + ' d="' + function(e, t, o) {
            let a = ""
              , r = 0
              , s = !1
              , i = 0;
            for (let l = 0; l < e.length; l++) {
                const u = Math.floor(l % t)
                  , c = Math.floor(l / t);
                u || s || (s = !0),
                e[l] ? (i++,
                l > 0 && u > 0 && e[l - 1] || (a += s ? n("M", u + o, .5 + c + o) : n("m", r, 0),
                r = 0,
                s = !1),
                u + 1 < t && e[l + 1] || (a += n("h", i),
                i = 0)) : r++
            }
            return a
        }(l, i, s.margin) + '"/>'
          , p = 'viewBox="0 0 ' + u + " " + u + '"'
          , f = '<svg xmlns="http://www.w3.org/2000/svg" ' + (s.width ? 'width="' + s.width + '" height="' + s.width + '" ' : "") + p + ' shape-rendering="crispEdges">' + c + d + "</svg>\n";
        return "function" == typeof r && r(null, f),
        f
    }
    ,
    DT
}
var FT = function() {
    if (NT)
        return TE;
    NT = 1;
    const e = EE ? CE : (EE = 1,
    CE = function() {
        return "function" == typeof Promise && Promise.prototype && Promise.prototype.then
    }
    )
      , t = OT()
      , n = RT()
      , o = jT();
    function a(n, o, a, r, s) {
        const i = [].slice.call(arguments, 1)
          , l = i.length
          , u = "function" == typeof i[l - 1];
        if (!u && !e())
            throw new Error("Callback required as last argument");
        if (!u) {
            if (l < 1)
                throw new Error("Too few arguments provided");
            return 1 === l ? (a = o,
            o = r = void 0) : 2 !== l || o.getContext || (r = a,
            a = o,
            o = void 0),
            new Promise(function(e, s) {
                try {
                    const s = t.create(a, r);
                    e(n(s, o, r))
                } catch (pC) {
                    s(pC)
                }
            }
            )
        }
        if (l < 2)
            throw new Error("Too few arguments provided");
        2 === l ? (s = a,
        a = o,
        o = r = void 0) : 3 === l && (o.getContext && void 0 === s ? (s = r,
        r = void 0) : (s = r,
        r = a,
        a = o,
        o = void 0));
        try {
            const e = t.create(a, r);
            s(null, n(e, o, r))
        } catch (pC) {
            s(pC)
        }
    }
    return TE.create = t.create,
    TE.toCanvas = a.bind(null, n.render),
    TE.toDataURL = a.bind(null, n.renderToDataURL),
    TE.toString = a.bind(null, function(e, t, n) {
        return o.render(e, n)
    }),
    TE
}();
const $T = Pl(FT)
  , VT = {
    id: "qr-code-screen"
}
  , HT = {
    class: "relative"
}
  , UT = ["src"]
  , ZT = {
    key: 0,
    class: "absolute top-2/4 left-2/4 -translate-y-2/4 -translate-x-2/4"
}
  , qT = {
    class: "font-bold text-4xl text-primary mb-1"
}
  , WT = ["value"]
  , GT = {
    class: "mt-5"
}
  , KT = {
    key: 0
}
  , YT = {
    class: "text-xl mb-1 block"
}
  , XT = {
    class: "w-full bg-white/10 h-1"
}
  , JT = {
    key: 1,
    class: "text-rose-500 text-2xl text-center font-bold"
}
  , QT = {
    class: "mt-6 flex items-center"
}
  , eA = to({
    __name: "QRCodeScreen",
    props: {
        data: {}
    },
    emits: ["success"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = QC()
          , r = It(!1)
          , s = It(!1)
          , i = It(!1);
        async function l() {
            if (!s.value) {
                s.value = !0;
                try {
                    "paid" === (await b_.get(`/transactions/${n.data.paymentId}/status`)).data && (!async function() {
                        i.value = !0,
                        await new Promise(e => setTimeout(e, 1500)),
                        o("success"),
                        a.fetchWallet()
                    }(),
                    clearInterval(c))
                } catch (e) {
                    clearInterval(c)
                } finally {
                    s.value = !1
                }
            }
        }
        const u = It(300);
        let c;
        function d() {
            document.getElementById("pixKeyInput").select(),
            SE(n.data.pixKey),
            r.value = !0,
            setTimeout( () => {
                r.value = !1
            }
            , 3e3)
        }
        Mo( () => {
            n.data.pixKey && (u.value = 300,
            c = setInterval( () => {
                u.value > 0 ? u.value-- : clearInterval(c)
            }
            , 1e3),
            setInterval( () => {
                l()
            }
            , 5e3))
        }
        ),
        Lo( () => {
            clearInterval(c)
        }
        );
        const p = function(e, t, n) {
            let o;
            o = Bt(n) ? {
                evaluating: n
            } : {};
            const {lazy: a=!1, flush: r="pre", evaluating: s, shallow: i=!0, onError: l=Nf} = o
              , u = Lt(!a)
              , c = i ? Lt(t) : It(t);
            let d = 0;
            return Ya(async t => {
                if (!u.value)
                    return;
                d++;
                const n = d;
                let o = !1;
                s && Promise.resolve().then( () => {
                    s.value = !0
                }
                );
                try {
                    const a = await e(e => {
                        t( () => {
                            s && (s.value = !1),
                            o || e()
                        }
                        )
                    }
                    );
                    n === d && (c.value = a)
                } catch (pC) {
                    l(pC)
                } finally {
                    s && n === d && (s.value = !1),
                    o = !0
                }
            }
            , {
                flush: r
            }),
            a ? ms( () => (u.value = !0,
            c.value)) : c
        }(async () => n.data.pixKey ? await $T.toDataURL(n.data.pixKey, {
            errorCorrectionLevel: "Q",
            width: 500
        }) : "");
        return (e, t) => {
            const o = Qv
              , a = im;
            return Tr(),
            Br("div", VT, [t[2] || (t[2] = Dr("div", {
                class: "text-center font-medium text-sm my-3"
            }, [Vr(" Escaneie o QR Code abaixo usando o app do "), Dr("br"), Vr("seu banco para realizar o pagamento ")], -1)), Dr("div", HT, [Dr("img", {
                src: Nt(p),
                class: K(["size-60 rounded-md mx-auto mb-8", {
                    invisible: !n.data.pixKey
                }])
            }, null, 10, UT), n.data.pixKey ? Ur("", !0) : (Tr(),
            Br("span", ZT, [jr(Nt(sm).Loading, {
                class: "size-12 animate-spin [animation-duration:600ms] opacity-85"
            })]))]), Dr("div", {
                class: K(["border border-dashed border-gray-400 rounded-sm p-7 flex flex-col gap-3 items-center relative", {
                    "border-rose-400": u.value <= 0
                }]),
                onClick: d
            }, [Dr("strong", qT, ne(Nt(hC)(n.data.amount, !1)), 1), Dr("input", {
                id: "pixKeyInput",
                type: "text",
                readonly: "",
                value: n.data.pixKey,
                placeholder: "Gerando QR Code...",
                class: "bg-white/10 rounded-sm py-4 px-4 w-full text-sm !outline-none"
            }, null, 8, WT), jr(o, {
                class: "w-full bg-primary/10 text-primary text-lg cursor-pointer hover:text-primary-foreground",
                disabled: !n.data.pixKey
            }, {
                default: En( () => [Vr(ne(r.value ? "Cdigo copiado!" : "Copiar Cdigo"), 1)]),
                _: 1
            }, 8, ["disabled"]), jr(Nt(sm).ClickPointer, {
                class: "p-1 size-10 cursor-pointer absolute top-3 right-3 opacity-60"
            })], 2), n.data.pixKey ? (Tr(),
            Br(_r, {
                key: 0
            }, [Dr("div", GT, [u.value > 0 ? (Tr(),
            Br("div", KT, [t[0] || (t[0] = Dr("strong", {
                class: "text-amber-500"
            }, "O QR Code expira em:", -1)), t[1] || (t[1] = Dr("br", null, null, -1)), Dr("strong", YT, ne(`${Math.floor(u.value / 60).toString().padStart(2, "0")}:${(u.value % 60).toString().padStart(2, "0")}`), 1), Dr("div", XT, [Dr("div", {
                class: "bg-primary h-1",
                style: U({
                    width: u.value / 300 * 100 + "%"
                })
            }, null, 4)])])) : (Tr(),
            Br("div", JT, " Cdigo PIX expirado "))]), Dr("div", QT, [jr(a, {
                type: "button",
                loading: s.value,
                success: i.value,
                disabled: s.value,
                class: "mt-4 !w-1/4",
                onClick: l
            }, {
                default: En( () => [Vr(ne(s.value ? "Consultando..." : "J paguei"), 1)]),
                _: 1
            }, 8, ["loading", "success", "disabled"])])], 64)) : Ur("", !0)])
        }
    }
})
  , tA = {
    class: "flex items-center gap-2"
}
  , nA = {
    class: ""
}
  , oA = {
    class: "overflow-hidden"
}
  , aA = to({
    __name: "DepositForm",
    props: {
        data: {}
    },
    emits: ["success"],
    setup(e, {emit: t}) {
        const n = XC()
          , o = ms( () => {
            var e;
            return (null == (e = n.financial) ? void 0 : e.min_deposit) ?? 100
        }
        )
          , a = ms( () => {
            var e;
            return (null == (e = n.financial) ? void 0 : e.max_deposit) ?? 1e6
        }
        )
          , r = t
          , s = e
          , i = Wg({
            amount: qg({
                required_error: "Campo obrigatrio"
            }).min(o.value, `O valor mnimo  R$ ${vC(o.value)}`).max(a.value, `O valor mximo  R$ ${vC(a.value)}`)
        })
          , {isSubmitting: l, errors: u, defineField: c, handleSubmit: d, submitCount: p} = Fy({
            initialValues: {
                amount: 0
            },
            validationSchema: Zy(i)
        })
          , [f,h] = c("amount")
          , v = It(!1)
          , m = d(async e => {
            var t, n;
            v.value = !1,
            s.data.generated = !1;
            try {
                const {data: t} = await b_.post("/wallet/add-funds", {
                    ...e
                });
                s.data.paymentId = null == t ? void 0 : t.payment_id,
                s.data.pixKey = null == t ? void 0 : t.qr_code,
                s.data.amount = null == t ? void 0 : t.amount,
                s.data.generated = !0,
                v.value = !0,
                await new Promise(e => setTimeout(e, 1500)),
                r("success")
            } catch (o) {
                let e = "Ocorreu um erro ao gerar o PIX.";
                o instanceof o_ && (e = (null == (n = null == (t = o.response) ? void 0 : t.data) ? void 0 : n.message) ?? e),
                S_.error(e)
            }
        }
        )
          , g = [500, 1e3, 3e3, 5e3, 1e4, 2e4, 5e4].filter(e => e >= o.value);
        function y(e) {
            f.value = e
        }
        return (e, t) => {
            const n = YC
              , o = KC
              , a = um
              , r = yC
              , i = im;
            return Tr(),
            Br(_r, null, [Dr("div", tA, [jr(Nt(sm).MoneyPlus, {
                class: "size-7"
            }), t[3] || (t[3] = Dr("h1", {
                class: "text-2xl font-medium"
            }, "Depositar", -1))]), Dr("form", {
                onSubmit: t[2] || (t[2] = Yi( (...e) => Nt(m) && Nt(m)(...e), ["prevent"])),
                class: "space-y-3 overflow-hidden"
            }, [Dr("div", nA, [jr(n, {
                for: "amount",
                class: "mb-2 text-base required gap-0.5"
            }, {
                default: En( () => t[4] || (t[4] = [Vr("Valor:")])),
                _: 1,
                __: [4]
            }), jr(o, Gr({
                id: "amount",
                modelValue: Nt(f),
                "onUpdate:modelValue": t[0] || (t[0] = e => Bt(f) ? f.value = e : null)
            }, Nt(h), {
                autocomplete: "off",
                "onUpdate:modelValue": t[1] || (t[1] = (e="0,00") => s.data.amount = Number(e.replace(/[\.\,]/gi, "")))
            }), null, 16, ["modelValue"]), jr(a, {
                message: Nt(u).amount
            }, null, 8, ["message"])]), Dr("div", oA, [jr(r, {
                values: Nt(g),
                selected: Nt(f),
                onSelect: y,
                hot: ""
            }, null, 8, ["values", "selected"])]), jr(i, {
                type: "submit",
                loading: Nt(l),
                success: v.value
            }, {
                default: En( () => [Nt(l) || v.value ? Ur("", !0) : (Tr(),
                Ir(Nt(sm).QrCode, {
                    key: 0,
                    class: "size-5"
                })), Vr(" " + ne(Nt(l) ? "Gerando..." : "Gerar QR Code"), 1)]),
                _: 1
            }, 8, ["loading", "success"])], 32)], 64)
        }
    }
})
  , rA = {
    key: 0,
    class: "-m-10 mb-0 select-none relative"
}
  , sA = {
    key: 1,
    class: "-mt-4"
}
  , iA = to({
    __name: "DepositModal",
    setup(e) {
        const t = pm("deposit")
          , n = It("form")
          , o = bt({
            paymentId: "",
            generated: !1,
            amount: 0,
            pixKey: "",
            paid: !1
        });
        return (e, a) => {
            const r = aA
              , s = eA
              , i = kE
              , l = Gv;
            return Tr(),
            Ir(l, {
                open: Nt(t),
                "onUpdate:open": a[2] || (a[2] = e => Bt(t) ? t.value = e : null)
            }, {
                heading: En( () => ["form" === n.value ? (Tr(),
                Br("div", rA, a[3] || (a[3] = [Dr("img", {
                    src: "/deposit_bg.jpg",
                    class: "w-full sm:rounded-t-lg"
                }, null, -1), Dr("div", {
                    class: "absolute bg-gradient-to-b from-black/10 via-black/10 from-0% via-85% to-100% to-background size-full z-10 top-0"
                }, null, -1)]))) : (Tr(),
                Br("h1", sA, "Depositar"))]),
                content: En( () => ["form" === n.value ? (Tr(),
                Ir(r, {
                    key: 0,
                    data: o,
                    onSuccess: a[0] || (a[0] = e => n.value = "qrcode")
                }, null, 8, ["data"])) : Ur("", !0), "qrcode" === n.value ? (Tr(),
                Ir(s, {
                    key: 1,
                    data: o,
                    onSuccess: a[1] || (a[1] = e => n.value = "success")
                }, null, 8, ["data"])) : Ur("", !0), "success" === n.value ? (Tr(),
                Ir(i, {
                    key: 2,
                    data: o
                }, null, 8, ["data"])) : Ur("", !0)]),
                _: 1
            }, 8, ["open"])
        }
    }
})
  , lA = to({
    __name: "Separator",
    props: {
        orientation: {
            default: "horizontal"
        },
        decorative: {
            type: Boolean,
            default: !0
        },
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Lf(t, "class");
        return (e, o) => (Tr(),
        Ir(Nt(bf), Gr({
            "data-slot": "separator-root"
        }, Nt(n), {
            class: Nt(hv)("bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px", t.class)
        }), null, 16, ["class"]))
    }
})
  , uA = {
    viewBox: "0 0 21 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
};
const cA = gE({}, [["render", function(e, t) {
    return Tr(),
    Br("svg", uA, t[0] || (t[0] = [Dr("g", {
        id: "Stars",
        "clip-path": "url(#clip0_3328_26016)"
    }, [Dr("path", {
        id: "Vector",
        d: "M10.0713 7.80874C10.2088 7.39624 10.7913 7.39624 10.9288 7.80874L11.735 10.23C11.9125 10.7622 12.2115 11.2458 12.6083 11.6425C13.0051 12.0391 13.4889 12.3378 14.0213 12.515L16.4413 13.3212C16.8538 13.4587 16.8538 14.0412 16.4413 14.1787L14.02 14.985C13.4878 15.1625 13.0042 15.4615 12.6075 15.8583C12.2109 16.2551 11.9122 16.7389 11.735 17.2712L10.9288 19.6912C10.8991 19.7816 10.8417 19.8602 10.7647 19.916C10.6877 19.9718 10.5951 20.0018 10.5 20.0018C10.4049 20.0018 10.3123 19.9718 10.2353 19.916C10.1583 19.8602 10.1009 19.7816 10.0713 19.6912L9.26501 17.27C9.08767 16.7379 8.78886 16.2544 8.39225 15.8577C7.99564 15.4611 7.51213 15.1623 6.98001 14.985L4.55876 14.1787C4.46843 14.1491 4.38977 14.0917 4.33401 14.0147C4.27824 13.9377 4.24822 13.8451 4.24822 13.75C4.24822 13.6549 4.27824 13.5623 4.33401 13.4853C4.38977 13.4083 4.46843 13.3509 4.55876 13.3212L6.98001 12.515C7.51213 12.3377 7.99564 12.0388 8.39225 11.6422C8.78886 11.2456 9.08767 10.7621 9.26501 10.23L10.0713 7.80874ZM5.24251 1.43499C5.26043 1.38086 5.29496 1.33375 5.34119 1.30036C5.38741 1.26698 5.44298 1.24901 5.50001 1.24901C5.55703 1.24901 5.6126 1.26698 5.65883 1.30036C5.70505 1.33375 5.73958 1.38086 5.75751 1.43499L6.24126 2.88749C6.45751 3.53499 6.96501 4.04249 7.61251 4.25874L9.06501 4.74249C9.11914 4.76041 9.16625 4.79494 9.19963 4.84117C9.23302 4.8874 9.25099 4.94297 9.25099 4.99999C9.25099 5.05701 9.23302 5.11258 9.19963 5.15881C9.16625 5.20504 9.11914 5.23956 9.06501 5.25749L7.61251 5.74124C7.29316 5.84764 7.00299 6.02694 6.76498 6.26496C6.52696 6.50297 6.34765 6.79315 6.24126 7.11249L5.75751 8.56499C5.73958 8.61912 5.70505 8.66623 5.65883 8.69962C5.6126 8.733 5.55703 8.75097 5.50001 8.75097C5.44298 8.75097 5.38741 8.733 5.34119 8.69962C5.29496 8.66623 5.26043 8.61912 5.24251 8.56499L4.75876 7.11249C4.65236 6.79315 4.47305 6.50297 4.23504 6.26496C3.99703 6.02694 3.70685 5.84764 3.38751 5.74124L1.93501 5.25749C1.88088 5.23956 1.83377 5.20504 1.80038 5.15881C1.76699 5.11258 1.74902 5.05701 1.74902 4.99999C1.74902 4.94297 1.76699 4.8874 1.80038 4.84117C1.83377 4.79494 1.88088 4.76041 1.93501 4.74249L3.38751 4.25874C3.70685 4.15234 3.99703 3.97304 4.23504 3.73502C4.47305 3.49701 4.65236 3.20683 4.75876 2.88749L5.24251 1.43499ZM14.0788 0.12374C14.0911 0.0881477 14.1142 0.0572848 14.1449 0.0354419C14.1756 0.013599 14.2123 0.00186157 14.25 0.00186157C14.2877 0.00186157 14.3244 0.013599 14.3551 0.0354419C14.3858 0.0572848 14.4089 0.0881477 14.4213 0.12374L14.7438 1.09124C14.8875 1.52374 15.2263 1.86249 15.6588 2.00624L16.6263 2.32874C16.6618 2.34108 16.6927 2.3642 16.7146 2.39489C16.7364 2.42558 16.7481 2.46232 16.7481 2.49999C16.7481 2.53766 16.7364 2.57439 16.7146 2.60509C16.6927 2.63578 16.6618 2.6589 16.6263 2.67124L15.6588 2.99374C15.4456 3.06464 15.2519 3.18426 15.0931 3.34309C14.9343 3.50193 14.8147 3.6956 14.7438 3.90874L14.4213 4.87624C14.4089 4.91183 14.3858 4.9427 14.3551 4.96454C14.3244 4.98638 14.2877 4.99812 14.25 4.99812C14.2123 4.99812 14.1756 4.98638 14.1449 4.96454C14.1142 4.9427 14.0911 4.91183 14.0788 4.87624L13.7563 3.90874C13.6854 3.6956 13.5657 3.50193 13.4069 3.34309C13.2481 3.18426 13.0544 3.06464 12.8413 2.99374L11.875 2.67124C11.8394 2.6589 11.8086 2.63578 11.7867 2.60509C11.7649 2.57439 11.7531 2.53766 11.7531 2.49999C11.7531 2.46232 11.7649 2.42558 11.7867 2.39489C11.8086 2.3642 11.8394 2.34108 11.875 2.32874L12.8425 2.00624C13.275 1.86249 13.6138 1.52374 13.7575 1.09124L14.0788 0.12499V0.12374Z",
        fill: "currentColor"
    })], -1), Dr("defs", null, [Dr("clipPath", {
        id: "clip0_3328_26016"
    }, [Dr("rect", {
        width: "20",
        height: "20",
        fill: "white",
        transform: "translate(0.5)"
    })])], -1)]))
}
]])
  , dA = {
    class: "flex gap-1 font-bold items-center justify-center"
}
  , pA = {
    class: ""
}
  , fA = {
    class: "relative"
}
  , hA = {
    class: ""
}
  , vA = {
    class: "relative"
}
  , mA = {
    class: ""
}
  , gA = {
    class: "relative"
}
  , yA = {
    class: ""
}
  , bA = {
    class: "relative"
}
  , wA = {
    class: "relative"
}
  , _A = {
    class: "relative"
}
  , xA = {
    class: "flex items-center justify-center my-4 relative"
}
  , kA = {
    class: "text-center"
}
  , SA = "Campo obrigatrio"
  , CA = to({
    __name: "RegisterModal",
    setup(e) {
        const t = dm()
          , n = pm("register")
          , o = Wg({
            name: Zg().min(3, SA).max(80, "Nome deve ter no mximo 80 caracteres"),
            email: Zg().min(1, SA).email("Digite um email vlido").max(100, "Email deve ter no mximo 100 caracteres"),
            phone: Zg().min(1, SA).refine(eE, {
                message: "Telefone invlido"
            }),
            password: Zg().min(8, "Deve ter pelo menos 8 caracteres").max(80, "Senha muito grande").regex(/[A-Z]/, "Deve conter pelo menos uma letra maiscula").regex(/\d/, "Deve conter pelo menos um nmero")
        })
          , {isSubmitting: a, errors: r, defineField: s, handleSubmit: i, submitCount: l} = Fy({
            initialValues: {
                name: "",
                email: "",
                phone: "",
                password: ""
            },
            validationSchema: Zy(o)
        })
          , [u,c] = s("name")
          , [d,p] = s("email")
          , [f,h] = s("phone")
          , [v,m] = s("password")
          , g = It(!1)
          , y = It(!1)
          , b = ms( () => {
            let e = 0;
            return /\d/.test(v.value) && (e += 1),
            v.value && v.value.length >= 8 && (e += 1),
            /[a-z]/.test(v.value) && /[A-Z]/.test(v.value) && (e += 1),
            Math.max(1, Math.min(e, 3))
        }
        )
          , w = i(async e => {
            var t, n;
            y.value = !1;
            try {
                const t = localStorage.getItem("referralCode") || void 0
                  , n = await b_.post("/register", {
                    ...e,
                    phone: e.phone.replace("-", ""),
                    code: t
                })
                  , {data: o} = n.data;
                y.value = !0,
                localStorage.setItem(y_, o),
                S_.success("Conta criada com sucesso!"),
                setTimeout( () => {
                    location.href = "/"
                }
                , 300)
            } catch (o) {
                let e = "No foi possvel fazer login.";
                o instanceof o_ && (e = (null == (n = null == (t = o.response) ? void 0 : t.data) ? void 0 : n.message) ?? e),
                S_.error(e)
            }
        }
        );
        return (e, o) => {
            const s = cA
              , i = um
              , _ = Qv
              , x = lA
              , k = Gv
              , S = Ho("mask");
            return Tr(),
            Ir(k, {
                open: Nt(n),
                "onUpdate:open": o[7] || (o[7] = e => Bt(n) ? n.value = e : null)
            }, {
                heading: En( () => [Dr("div", dA, [jr(s, {
                    class: "size-5 text-muted-foreground"
                }), o[8] || (o[8] = Dr("h1", {
                    class: "text-center"
                }, "Crie sua conta!", -1)), jr(s, {
                    class: "size-5 text-muted-foreground -scale-100"
                })])]),
                description: En( () => o[9] || (o[9] = [Dr("h2", {
                    class: "font-medium text-center opacity-40"
                }, " Comee a concorrer a prmios hoje! ", -1)])),
                content: En( () => [Dr("form", {
                    onSubmit: o[5] || (o[5] = Yi( (...e) => Nt(w) && Nt(w)(...e), ["prevent"])),
                    class: "space-y-6"
                }, [Dr("div", pA, [jr(Nt(YC), {
                    for: "name",
                    class: "mb-1"
                }, {
                    default: En( () => o[10] || (o[10] = [Vr("Nome Completo")])),
                    _: 1,
                    __: [10]
                }), Dr("div", fA, [jr(Nt(cm), Gr({
                    id: "name",
                    type: "text",
                    modelValue: Nt(u),
                    "onUpdate:modelValue": o[0] || (o[0] = e => Bt(u) ? u.value = e : null)
                }, Nt(c), {
                    class: "pl-9",
                    placeholder: "Digite o seu nome completo",
                    "aria-invalid": Nt(r).name && Nt(l) > 0
                }), null, 16, ["modelValue", "aria-invalid"]), jr(Nt(sm).Business, {
                    class: "size-4 opacity-35 absolute left-3 top-2/4 -translate-y-2/4"
                })]), jr(i, {
                    message: Nt(r).name
                }, null, 8, ["message"])]), Dr("div", hA, [jr(Nt(YC), {
                    for: "email",
                    class: "mb-1"
                }, {
                    default: En( () => o[11] || (o[11] = [Vr("Email")])),
                    _: 1,
                    __: [11]
                }), Dr("div", vA, [jr(Nt(cm), Gr({
                    id: "email",
                    type: "email",
                    modelValue: Nt(d),
                    "onUpdate:modelValue": o[1] || (o[1] = e => Bt(d) ? d.value = e : null)
                }, Nt(p), {
                    class: "pl-9",
                    placeholder: "example@site.com",
                    "aria-invalid": Nt(r).email && Nt(l) > 0
                }), null, 16, ["modelValue", "aria-invalid"]), jr(Nt(sm).Mail, {
                    class: "size-4 opacity-35 absolute left-3 top-2/4 -translate-y-2/4"
                })]), jr(i, {
                    message: Nt(r).email
                }, null, 8, ["message"])]), Dr("div", mA, [jr(Nt(YC), {
                    for: "phone",
                    class: "mb-1"
                }, {
                    default: En( () => o[12] || (o[12] = [Vr("Telefone")])),
                    _: 1,
                    __: [12]
                }), Dr("div", gA, [Tn(jr(Nt(cm), Gr({
                    id: "phone",
                    type: "tel",
                    "model-value": Nt(f),
                    "onUpdate:modelValue": o[2] || (o[2] = e => f.value = String(e).replace("-", ""))
                }, Nt(h), {
                    class: "pl-9",
                    placeholder: "(00) 0000-0000",
                    inputmode: "tel",
                    "aria-invalid": Nt(r).phone && Nt(l) > 0
                }), null, 16, ["model-value", "aria-invalid"]), [[S, ["(##) ####-####", "(##) #####-####"]]]), jr(Nt(sm).Phone, {
                    class: "size-4 opacity-35 absolute left-3 top-2/4 -translate-y-2/4"
                })]), jr(i, {
                    message: Nt(r).phone
                }, null, 8, ["message"])]), Dr("div", yA, [jr(Nt(YC), {
                    for: "password",
                    class: "mb-1"
                }, {
                    default: En( () => o[13] || (o[13] = [Vr("Escolha uma senha")])),
                    _: 1,
                    __: [13]
                }), Dr("div", bA, [Dr("div", wA, [Dr("div", _A, [jr(Nt(cm), Gr({
                    id: "password",
                    type: g.value ? "text" : "password",
                    modelValue: Nt(v),
                    "onUpdate:modelValue": o[3] || (o[3] = e => Bt(v) ? v.value = e : null)
                }, Nt(m), {
                    class: "pl-9",
                    placeholder: "Digite uma senha forte...",
                    "aria-invalid": Nt(r).password && Nt(l) > 0
                }), null, 16, ["type", "modelValue", "aria-invalid"]), jr(Nt(sm).Lock, {
                    class: "size-4 opacity-35 absolute left-3 top-2/4 -translate-y-2/4"
                })]), Dr("span", {
                    onClick: o[4] || (o[4] = e => g.value = !g.value),
                    class: "cursor-pointer text-xs text-primary md:absolute right-3 top-2/4 md:-translate-y-2/4 w-fit block ml-auto p-0.5 select-none transition-transform active:scale-90"
                }, ne(g.value ? "Esconder" : "Mostrar"), 1)]), Nt(v).length > 0 ? (Tr(),
                Br("span", {
                    key: 0,
                    class: K(["block mt-1 text-sm font-medium whitespace-nowrap", ["text-rose-600", "text-amber-400", "text-emerald-500"][b.value - 1]])
                }, ne(["Muito fraca", "Mdia", "Segura"][b.value - 1]), 3)) : Ur("", !0)]), jr(i, {
                    message: Nt(r).password
                }, null, 8, ["message"])]), jr(_, {
                    type: "submit",
                    size: "lg",
                    class: K(["h-[48px] text-md font-semibold uppercase mt-2.5! overflow-hidden !block w-full", {
                        "pointer-events-none": y.value
                    }]),
                    disabled: Nt(a)
                }, {
                    default: En( () => [Dr("div", {
                        class: K(Nt(hv)("flex flex-col items-center gap-3 py-3 transition-transform duration-[400ms] ease-out-quint", {
                            "translate-y-0": !Nt(a) && !y.value,
                            "translate-y-[calc(-36px*1)]": Nt(a),
                            "translate-y-[calc(-36px*2)]": y.value
                        }))
                    }, [o[14] || (o[14] = Dr("div", null, "Criar", -1)), jr(Nt(sm).Loading, {
                        class: "size-6 animate-spin"
                    }), jr(Nt(sm).Check, {
                        class: "size-6 scale-110"
                    })], 2)]),
                    _: 1
                }, 8, ["class", "disabled"])], 32), Dr("div", xA, [jr(x), o[15] || (o[15] = Dr("span", {
                    class: "absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 font-semibold bg-background px-2 text-sm"
                }, " OU ", -1))]), Dr("p", kA, [o[16] || (o[16] = Vr(" J tem uma conta? ")), Dr("span", {
                    onClick: o[6] || (o[6] = e => Nt(t).open("login")),
                    class: "text-primary font-semibold block md:inline-block cursor-pointer"
                }, "Entrar")])]),
                _: 1
            }, 8, ["open"])
        }
    }
})
  , EA = {
    class: "flex gap-1 font-bold items-center justify-center"
}
  , TA = {
    class: ""
}
  , AA = {
    class: "relative"
}
  , OA = {
    class: ""
}
  , MA = {
    class: "relative"
}
  , PA = {
    class: "relative"
}
  , BA = {
    class: "relative"
}
  , IA = {
    class: "flex items-center justify-center my-4 relative"
}
  , LA = {
    class: "text-center"
}
  , RA = to({
    __name: "LoginModal",
    setup(e) {
        const t = dm()
          , n = pm("login")
          , o = Wg({
            email: Zg().min(1, "Campo obrigatrio").email("Digite um email vlido").max(100, "Email deve ter no mximo 100 caracteres"),
            password: Zg().min(8, "Deve ter pelo menos 8 caracteres").max(80, "Senha muito grande").regex(/[A-Z]/, "Deve conter pelo menos uma letra maiscula").regex(/\d/, "Deve conter pelo menos um nmero")
        })
          , {isSubmitting: a, errors: r, defineField: s, handleSubmit: i, submitCount: l} = Fy({
            initialValues: {
                email: "",
                password: ""
            },
            validationSchema: Zy(o)
        })
          , [u,c] = s("email")
          , [d,p] = s("password")
          , f = It(!1)
          , h = It(!1)
          , v = i(async e => {
            var t, n;
            try {
                const t = await b_.post("/login", {
                    ...e
                })
                  , {data: n} = t.data;
                localStorage.setItem(y_, n),
                S_.success("Login realizado com sucesso!"),
                setTimeout( () => {
                    location.href = "/"
                }
                , 300)
            } catch (o) {
                let e = "No foi possvel fazer login.";
                o instanceof o_ && (e = (null == (n = null == (t = o.response) ? void 0 : t.data) ? void 0 : n.message) ?? e),
                S_.error(e)
            }
        }
        );
        return (e, o) => {
            const s = cA
              , i = um
              , m = lA
              , g = Gv;
            return Tr(),
            Ir(g, {
                open: Nt(n),
                "onUpdate:open": o[5] || (o[5] = e => Bt(n) ? n.value = e : null)
            }, {
                heading: En( () => [Dr("div", EA, [jr(s, {
                    class: "size-5 text-primary"
                }), o[6] || (o[6] = Dr("h1", null, "Bem vindo de volta!", -1)), jr(s, {
                    class: "size-5 text-primary -scale-100"
                })])]),
                description: En( () => o[7] || (o[7] = [Dr("h2", {
                    class: "font-medium text-center opacity-40"
                }, [Vr(" Conecte-se para acompanhar seus prmios,"), Dr("br"), Vr(" depsitos e muito mais. ")], -1)])),
                content: En( () => [Dr("form", {
                    onSubmit: o[3] || (o[3] = Yi( (...e) => Nt(v) && Nt(v)(...e), ["prevent"])),
                    class: "space-y-6"
                }, [Dr("div", TA, [jr(Nt(YC), {
                    for: "email",
                    class: "mb-1"
                }, {
                    default: En( () => o[8] || (o[8] = [Vr("Email")])),
                    _: 1,
                    __: [8]
                }), Dr("div", AA, [jr(Nt(cm), Gr({
                    id: "email",
                    type: "email",
                    modelValue: Nt(u),
                    "onUpdate:modelValue": o[0] || (o[0] = e => Bt(u) ? u.value = e : null)
                }, Nt(c), {
                    class: "pl-9",
                    placeholder: "example@site.com",
                    "aria-invalid": Nt(r).email && Nt(l) > 0
                }), null, 16, ["modelValue", "aria-invalid"]), jr(Nt(sm).Mail, {
                    class: "size-4 opacity-35 absolute left-3 top-2/4 -translate-y-2/4"
                })]), jr(i, {
                    message: Nt(r).email
                }, null, 8, ["message"])]), Dr("div", OA, [jr(Nt(YC), {
                    for: "password",
                    class: "mb-1"
                }, {
                    default: En( () => o[9] || (o[9] = [Vr("Digite sua senha")])),
                    _: 1,
                    __: [9]
                }), Dr("div", MA, [Dr("div", PA, [Dr("div", BA, [jr(Nt(cm), Gr({
                    id: "password",
                    type: h.value ? "text" : "password",
                    modelValue: Nt(d),
                    "onUpdate:modelValue": o[1] || (o[1] = e => Bt(d) ? d.value = e : null)
                }, Nt(p), {
                    class: "pl-9",
                    placeholder: "Insira sua senha...",
                    "aria-invalid": Nt(r).password && Nt(l) > 0
                }), null, 16, ["type", "modelValue", "aria-invalid"]), jr(Nt(sm).Lock, {
                    class: "size-4 opacity-35 absolute left-3 top-2/4 -translate-y-2/4"
                })]), Dr("span", {
                    onClick: o[2] || (o[2] = e => h.value = !h.value),
                    class: "cursor-pointer text-xs text-primary md:absolute right-3 top-2/4 md:-translate-y-2/4 w-fit block ml-auto p-0.5 select-none transition-transform active:scale-90"
                }, ne(h.value ? "Esconder" : "Mostrar"), 1)])]), jr(i, {
                    message: Nt(r).password
                }, null, 8, ["message"])]), jr(Nt(Qv), {
                    type: "submit",
                    size: "lg",
                    class: K(["h-[48px] text-md font-semibold uppercase mt-2.5! overflow-hidden !block w-full", {
                        "pointer-events-none": f.value
                    }]),
                    disabled: Nt(a)
                }, {
                    default: En( () => [Dr("div", {
                        class: K(Nt(hv)("flex flex-col items-center gap-3 py-3 transition-transform duration-[400ms] ease-out-quint", {
                            "translate-y-0": !Nt(a) && !f.value,
                            "translate-y-[calc(-36px*1)]": Nt(a),
                            "translate-y-[calc(-36px*2)]": f.value
                        }))
                    }, [o[10] || (o[10] = Dr("div", null, "Entrar", -1)), jr(Nt(sm).Loading, {
                        class: "size-6 animate-spin"
                    }), jr(Nt(sm).Check, {
                        class: "size-6 scale-110"
                    })], 2)]),
                    _: 1
                }, 8, ["class", "disabled"])], 32), Dr("div", IA, [jr(m), o[11] || (o[11] = Dr("span", {
                    class: "absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 font-semibold bg-background px-2 text-sm"
                }, " OU ", -1))]), Dr("p", LA, [o[12] || (o[12] = Vr(" Ainda no tem uma conta? ")), Dr("span", {
                    onClick: o[4] || (o[4] = e => Nt(t).open("register")),
                    class: "text-primary font-semibold block md:inline-block cursor-pointer"
                }, "Registrar")])]),
                _: 1
            }, 8, ["open"])
        }
    }
})
  , zA = to({
    __name: "Modals",
    setup(e) {
        const t = pm("login")
          , n = pm("register")
          , o = pm("deposit")
          , a = pm("withdraw")
          , r = pm("code");
        return (e, s) => {
            const i = RA
              , l = CA
              , u = iA
              , c = pE
              , d = Nk;
            return Tr(),
            Br(_r, null, [(Tr(),
            Ir(i, {
                modelValue: Nt(t),
                "onUpdate:modelValue": s[0] || (s[0] = e => Bt(t) ? t.value = e : null),
                key: Nt(t)
            }, null, 8, ["modelValue"])), (Tr(),
            Ir(l, {
                modelValue: Nt(n),
                "onUpdate:modelValue": s[1] || (s[1] = e => Bt(n) ? n.value = e : null),
                key: Nt(n)
            }, null, 8, ["modelValue"])), (Tr(),
            Ir(u, {
                modelValue: Nt(o),
                "onUpdate:modelValue": s[2] || (s[2] = e => Bt(o) ? o.value = e : null),
                key: Nt(o)
            }, null, 8, ["modelValue"])), (Tr(),
            Ir(c, {
                modelValue: Nt(a),
                "onUpdate:modelValue": s[3] || (s[3] = e => Bt(a) ? a.value = e : null),
                key: Nt(a)
            }, null, 8, ["modelValue"])), (Tr(),
            Ir(d, {
                modelValue: Nt(r),
                "onUpdate:modelValue": s[4] || (s[4] = e => Bt(r) ? r.value = e : null),
                key: Nt(r)
            }, null, 8, ["modelValue"]))], 64)
        }
    }
})
  , NA = {
    class: "size-12 animate-spin [animation-duration:600ms] opacity-85",
    preserveAspectRatio: "xMidYMid",
    viewBox: "0 0 100 100",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
const DA = gE({}, [["render", function(e, t) {
    return Tr(),
    Br("svg", NA, t[0] || (t[0] = [Dr("circle", {
        cx: "50",
        cy: "50",
        fill: "none",
        r: "35",
        stroke: "currentColor",
        "stroke-dasharray": "164.93361431346415 56.97787143782138",
        "stroke-width": "10",
        transform: "matrix(1,0,0,1,0,0)",
        style: {
            transform: "matrix(1, 0, 0, 1, 0, 0)",
            "animation-play-state": "paused"
        }
    }, null, -1)]))
}
]])
  , jA = {
    key: 0,
    class: "fixed inset-0 z-100 flex justify-center items-center"
}
  , FA = to({
    __name: "LoadingScreen",
    setup(e) {
        const t = XC()
          , n = ms( () => {
            var e;
            return !(null == (e = t.theme) ? void 0 : e.logo)
        }
        );
        return (e, t) => {
            const o = DA;
            return n.value ? (Tr(),
            Br("div", jA, [jr(o)])) : Wo(e.$slots, "default", {
                key: 1
            })
        }
    }
})
  , $A = {
    class: "bg-surface rounded-xl border-t shadow-lg z-10 fixed bottom-2 left-2 right-2 px-2 h-[72px] flex items-center gap-x-2.5 md:hidden"
}
  , VA = ["onClick"]
  , HA = {
    class: "text-[0.7rem] font-medium"
}
  , UA = to({
    __name: "BottomNavigation",
    setup(e) {
        const t = Pk()
          , n = QC()
          , o = dm()
          , a = [{
            text: "Incio",
            link: "/",
            icon: sm.Home
        }, {
            text: "Raspadinhas",
            link: "/raspadinha",
            icon: sm.TicketPerforated
        }, {
            text: "Depsitar",
            icon: sm.MoneyPlus,
            roundedButton: !0,
            action: () => o.open("deposit")
        }, {
            text: "Indique",
            link: "/indique",
            icon: sm.UserPlus
        }, {
            text: "Perfil",
            link: "/perfil",
            icon: sm.User
        }]
          , r = [{
            text: "Incio",
            link: "/",
            icon: sm.Home
        }, {
            text: "Raspadinhas",
            link: "/raspadinha",
            icon: sm.TicketPerforated
        }, {
            text: "Registrar",
            icon: sm.UserPlus,
            action: () => o.open("register"),
            roundedButton: !0
        }, {
            text: "Prmios",
            icon: sm.Gift,
            action: () => t.push("/register")
        }, {
            text: "Entrar",
            icon: sm.User,
            action: () => o.open("login")
        }]
          , s = ms( () => n.authenticated ? a : r);
        return (e, n) => (Tr(),
        Ir(Dn, {
            to: "body"
        }, [Dr("div", $A, [(Tr(!0),
        Br(_r, null, qo(s.value, (n, o) => (Tr(),
        Br("button", {
            key: o,
            class: K(["group flex flex-col items-center justify-center gap-1 text-center text-inherit select-none", {
                "text-primary font-semibold": e.$route.path === n.link,
                "-translate-y-[1.25rem]": n.roundedButton,
                "flex-1 transition-transform active:scale-90": !n.roundedButton
            }]),
            onClick: e => n.action ? n.action() : Nt(t).push(n.link)
        }, [Dr("div", {
            class: K({
                "bg-primary rounded-full border-4 border-surface text-primary-contrast p-3 transition-transform group-active:scale-90": n.roundedButton
            })
        }, [(Tr(),
        Ir(Vo(n.icon), {
            class: K(n.roundedButton ? "size-[1.6rem]" : "size-5")
        }, null, 8, ["class"]))], 2), Dr("span", HA, ne(n.text), 1)], 10, VA))), 128))])]))
    }
})
  , ZA = to({
    __name: "Popover",
    props: {
        defaultOpen: {
            type: Boolean
        },
        open: {
            type: Boolean
        },
        modal: {
            type: Boolean
        }
    },
    emits: ["update:open"],
    setup(e, {emit: t}) {
        const n = Zd(e, t);
        return (e, t) => (Tr(),
        Ir(Nt(bp), Gr({
            "data-slot": "popover"
        }, Nt(n)), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , qA = to({
    inheritAttrs: !1,
    __name: "PopoverContent",
    props: {
        forceMount: {
            type: Boolean
        },
        side: {},
        sideOffset: {
            default: 4
        },
        align: {
            default: "center"
        },
        alignOffset: {},
        avoidCollisions: {
            type: Boolean
        },
        collisionBoundary: {},
        collisionPadding: {},
        arrowPadding: {},
        sticky: {},
        hideWhenDetached: {
            type: Boolean
        },
        positionStrategy: {},
        updatePositionStrategy: {},
        disableUpdateOnLayoutShift: {
            type: Boolean
        },
        prioritizePosition: {
            type: Boolean
        },
        reference: {},
        asChild: {
            type: Boolean
        },
        as: {},
        disableOutsidePointerEvents: {
            type: Boolean
        },
        class: {}
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = Zd(Lf(n, "class"), o);
        return (e, t) => (Tr(),
        Ir(Nt(wp), null, {
            default: En( () => [jr(Nt(Sp), Gr({
                "data-slot": "popover-content"
            }, {
                ...Nt(a),
                ...e.$attrs
            }, {
                class: Nt(hv)("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 rounded-md border p-4 shadow-md origin-(--reka-popover-content-transform-origin) outline-hidden", n.class)
            }), {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            }, 16, ["class"])]),
            _: 3
        }))
    }
})
  , WA = to({
    __name: "PopoverTrigger",
    props: {
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Ir(Nt(Cp), Gr({
            "data-slot": "popover-trigger"
        }, t), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , GA = to({
    __name: "Avatar",
    props: {
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Ir(Nt(Yd), {
            "data-slot": "avatar",
            class: K(Nt(hv)("relative flex size-8 shrink-0 overflow-hidden rounded-full", t.class))
        }, {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 8, ["class"]))
    }
})
  , KA = to({
    __name: "AvatarFallback",
    props: {
        delayMs: {},
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Lf(t, "class");
        return (e, o) => (Tr(),
        Ir(Nt(Xd), Gr({
            "data-slot": "avatar-fallback"
        }, Nt(n), {
            class: Nt(hv)("bg-muted flex size-full items-center justify-center rounded-full", t.class)
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["class"]))
    }
})
  , YA = to({
    __name: "AvatarImage",
    props: {
        src: {},
        referrerPolicy: {},
        crossOrigin: {},
        asChild: {
            type: Boolean
        },
        as: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Ir(Nt(Qd), Gr({
            "data-slot": "avatar-image"
        }, t, {
            class: "aspect-square size-full"
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , XA = {
    class: "flex items-center px-1.5 py-1 gap-1.5 rounded-sm cursor-pointer select-none group *:transition-all duration-200 ease-in-out"
}
  , JA = {
    class: "text-sm ml-0.5 font-medium overflow-hidden opacity-80 group-hover:opacity-100 text-nowrap text-ellipsis hidden sm:block w-17"
}
  , QA = to({
    __name: "AccountDropdown",
    setup(e) {
        const t = Bk()
          , n = QC()
          , o = dm()
          , a = [{
            name: "Conta",
            icon: sm.Person,
            route: "/perfil/conta"
        }, {
            name: "Sacar",
            icon: sm.Withdraw,
            onClick: () => o.open("withdraw")
        }, {
            name: "Histrico de Jogos",
            icon: sm.Joystick,
            route: "/perfil/historico"
        }, {
            name: "Transaes",
            icon: sm.SolidReceipt,
            route: "/perfil/transacoes"
        }, {
            name: "Entregas",
            icon: sm.Truck,
            route: "/perfil/entregas"
        }, {
            name: "Segurana",
            icon: sm.LockShield,
            route: "/perfil/seguranca"
        }];
        return (e, o) => {
            const r = YA
              , s = KA
              , i = GA
              , l = WA
              , u = Qv
              , c = Fo("RouterLink")
              , d = qA
              , p = ZA;
            return Tr(),
            Ir(p, null, {
                default: En( () => [jr(l, {
                    "as-child": ""
                }, {
                    default: En( () => {
                        var e;
                        return [Dr("div", XA, [jr(i, null, {
                            default: En( () => {
                                var e;
                                return [jr(r, {
                                    src: null == (e = Nt(n).user) ? void 0 : e.avatar,
                                    alt: "@"
                                }, null, 8, ["src"]), jr(s, null, {
                                    default: En( () => [jr(Nt(sm).Account, {
                                        class: "size-full"
                                    })]),
                                    _: 1
                                })]
                            }
                            ),
                            _: 1
                        }), Dr("div", JA, ne(null == (e = Nt(n).user) ? void 0 : e.name), 1), jr(Nt(sm).Down, {
                            class: "size-4 mr-1 opacity-80 group-hover:opacity-100"
                        })])]
                    }
                    ),
                    _: 1
                }), jr(d, {
                    class: "w-fit min-w-[260px] max-w-[360px] px-3 pb-3 text-wrap wrap-break-word",
                    sideOffset: 9,
                    collisionPadding: 20
                }, {
                    default: En( () => [(Tr(),
                    Br(_r, null, qo(a, e => (Tr(),
                    Br(_r, {
                        key: e.name
                    }, [e.route ? (Tr(),
                    Ir(c, {
                        key: 0,
                        to: e.route,
                        class: "flex items-center py-0.5 gap-2 w-full"
                    }, {
                        default: En( () => [jr(u, {
                            variant: Nt(t).path === e.route ? "default" : "ghost",
                            class: "w-full justify-start !px-1 !py-5 gap-2 cursor-pointer"
                        }, {
                            default: En( () => [(Tr(),
                            Ir(Vo(e.icon), {
                                class: "size-8 p-1.5 rounded-full select-none hover:bg-sidebar-foreground"
                            })), Vr(" " + ne(e.name), 1)]),
                            _: 2
                        }, 1032, ["variant"])]),
                        _: 2
                    }, 1032, ["to"])) : e.onClick ? (Tr(),
                    Ir(u, {
                        key: 1,
                        onClick: e.onClick,
                        variant: "ghost",
                        class: "w-full justify-start !px-1 !py-5 gap-2 cursor-pointer"
                    }, {
                        default: En( () => [(Tr(),
                        Ir(Vo(e.icon), {
                            class: "size-8 p-1.5 rounded-full select-none hover:bg-sidebar-foreground"
                        })), Vr(" " + ne(e.name), 1)]),
                        _: 2
                    }, 1032, ["onClick"])) : Ur("", !0)], 64))), 64)), jr(u, {
                        onClick: Nt(n).logout,
                        variant: "ghost",
                        class: "w-full justify-start !px-1 !text-rose-500 cursor-pointer"
                    }, {
                        default: En( () => [jr(Nt(sm).Logout, {
                            class: "size-8 p-1.5 rounded-full select-none hover:bg-white/10"
                        }), o[0] || (o[0] = Vr(" Sair "))]),
                        _: 1,
                        __: [0]
                    }, 8, ["onClick"])]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
})
  , eO = {
    class: "flex items-center bg-accent h-9 rounded-md gap-3 px-3.5 has-[>svg]:px-3 cursor-pointer"
}
  , tO = {
    class: "font-semibold text-sm"
}
  , nO = {
    class: "flex flex-col gap-2"
}
  , oO = {
    class: "flex justify-between"
}
  , aO = {
    class: "flex justify-between"
}
  , rO = {
    class: "flex flex-col mb-2"
}
  , sO = {
    class: "flex justify-between"
}
  , iO = {
    class: "font-semibold text-lg"
}
  , lO = {
    class: "flex items-center gap-2 ml-1"
}
  , uO = to({
    __name: "ManageWallet",
    setup(e) {
        const t = dm()
          , n = QC()
          , o = ms( () => {
            var e, t;
            return ((null == (e = n.wallet) ? void 0 : e.balance) ?? 0) + ((null == (t = n.wallet) ? void 0 : t.bonus) ?? 0)
        }
        );
        return (e, a) => {
            const r = WA
              , s = lA
              , i = Qv
              , l = qA
              , u = ZA;
            return Tr(),
            Br(_r, null, [jr(u, null, {
                default: En( () => [jr(r, {
                    "as-child": ""
                }, {
                    default: En( () => [Dr("section", eO, [Dr("span", tO, ne(Nt(hC)(o.value ?? 0)), 1), jr(Nt(sm).Down, {
                        class: "size-3.5 text-muted-foreground -ml-1"
                    })])]),
                    _: 1
                }), jr(l, {
                    class: "w-fit min-w-[220px] max-w-[270px] px-3 pb-3 text-wrap wrap-break-word",
                    sideOffset: 4,
                    collisionPadding: 20
                }, {
                    default: En( () => {
                        var e, r;
                        return [Dr("div", nO, [Dr("div", oO, [Dr("span", null, [a[3] || (a[3] = Dr("span", {
                            class: "text-primary"
                        }, "R$", -1)), Vr(" " + ne(Nt(vC)((null == (e = Nt(n).wallet) ? void 0 : e.balance) ?? 0)), 1)]), a[4] || (a[4] = Dr("span", null, "Saldo", -1))]), Dr("div", aO, [Dr("span", null, [a[5] || (a[5] = Dr("span", {
                            class: "text-primary"
                        }, "R$", -1)), Vr(" " + ne(Nt(vC)((null == (r = Nt(n).wallet) ? void 0 : r.bonus) ?? 0)), 1)]), a[6] || (a[6] = Dr("span", null, "Bnus", -1))])]), jr(s, {
                            class: "my-2"
                        }), Dr("div", rO, [Dr("div", sO, [a[8] || (a[8] = Dr("span", {
                            class: "text-muted-foreground font-medium"
                        }, "Total", -1)), Dr("span", iO, [a[7] || (a[7] = Dr("span", {
                            class: "text-primary"
                        }, "R$", -1)), Vr(" " + ne(Nt(vC)(o.value ?? 0)), 1)])]), a[9] || (a[9] = Dr("p", {
                            class: "text-xs text-muted-foreground mt-1"
                        }, " O saldo total  a soma do seu saldo e bnus. ", -1))]), jr(i, {
                            class: "w-full cursor-pointer",
                            size: "sm",
                            onClick: a[0] || (a[0] = e => Nt(t).open("withdraw"))
                        }, {
                            default: En( () => [jr(Nt(sm).Withdraw), a[10] || (a[10] = Vr("Sacar"))]),
                            _: 1,
                            __: [10]
                        })]
                    }
                    ),
                    _: 1
                })]),
                _: 1
            }), Dr("div", lO, [jr(i, {
                class: "font-semibold cursor-pointer",
                size: "sm",
                onClick: a[1] || (a[1] = e => Nt(t).open("deposit"))
            }, {
                default: En( () => [jr(Nt(sm).MoneyPlus, {
                    class: "size-5"
                }), a[11] || (a[11] = Dr("span", {
                    class: "sm:block hidden"
                }, "Depositar", -1))]),
                _: 1,
                __: [11]
            }), jr(i, {
                class: "sm:flex hidden font-semibold cursor-pointer",
                size: "sm",
                onClick: a[2] || (a[2] = e => Nt(t).open("withdraw"))
            }, {
                default: En( () => [jr(Nt(sm).Withdraw, {
                    class: "size-4"
                }), a[12] || (a[12] = Vr(" Sacar "))]),
                _: 1,
                __: [12]
            })])], 64)
        }
    }
})
  , cO = {
    class: "topbar bg-sidebar h-[72px] fixed z-50 right-0 left-0! text-[0.92rem]"
}
  , dO = {
    class: "mx-auto max-w-(--max-layout-width) px-4 w-full h-full"
}
  , pO = {
    class: "flex justify-between items-center h-full gap-6"
}
  , fO = {
    class: "flex items-center gap-4"
}
  , hO = ["src"]
  , vO = {
    class: "md:flex items-center gap-6 font-medium hidden *:hover:bg-accent *:px-2 *:py-1 *:rounded-sm *:active:scale-90 *:transition-transform"
}
  , mO = {
    key: 0,
    class: "ml-auto flex items-center gap-1.5"
}
  , gO = {
    key: 1,
    class: "ml-auto flex items-center gap-1.5"
}
  , yO = to({
    __name: "NavigationMenu",
    setup(e) {
        const t = dm()
          , n = QC()
          , o = XC();
        return (e, a) => {
            const r = zA
              , s = Fo("RouterLink")
              , i = uO
              , l = QA
              , u = Qv;
            return Tr(),
            Br(_r, null, [jr(r), Dr("header", cO, [Dr("div", dO, [Dr("nav", pO, [Dr("div", fO, [jr(s, {
                to: "/",
                class: "text-2xl font-semibold"
            }, {
                default: En( () => {
                    var e;
                    return [Dr("img", {
                        src: null == (e = Nt(o).theme) ? void 0 : e.logo,
                        class: "h-[42px]"
                    }, null, 8, hO)]
                }
                ),
                _: 1
            })]), Dr("div", vO, [jr(s, {
                to: "/"
            }, {
                default: En( () => a[2] || (a[2] = [Vr(" Inicio ")])),
                _: 1,
                __: [2]
            }), jr(s, {
                to: "/raspadinha"
            }, {
                default: En( () => a[3] || (a[3] = [Vr(" Raspadinhas ")])),
                _: 1,
                __: [3]
            }), jr(s, {
                to: "/indique"
            }, {
                default: En( () => a[4] || (a[4] = [Vr(" Indique e Ganhe ")])),
                _: 1,
                __: [4]
            })]), Nt(n).authenticated ? (Tr(),
            Br("div", mO, [jr(i), jr(l)])) : (Tr(),
            Br("div", gO, [jr(u, {
                class: "cursor-pointer",
                variant: "outline",
                size: "lg",
                onClick: a[0] || (a[0] = e => Nt(t).open("login"))
            }, {
                default: En( () => a[5] || (a[5] = [Vr(" Entrar ")])),
                _: 1,
                __: [5]
            }), jr(u, {
                class: "cursor-pointer",
                size: "lg",
                onClick: a[1] || (a[1] = e => Nt(t).open("register"))
            }, {
                default: En( () => [jr(Nt(sm).UserPlus, {
                    class: "size-5"
                }), a[6] || (a[6] = Vr(" Registrar "))]),
                _: 1,
                __: [6]
            })]))])])])], 64)
        }
    }
})
  , bO = to({
    __name: "Sonner",
    props: {
        invert: {
            type: Boolean
        },
        theme: {},
        position: {},
        hotkey: {},
        richColors: {
            type: Boolean
        },
        expand: {
            type: Boolean
        },
        duration: {},
        gap: {},
        visibleToasts: {},
        closeButton: {
            type: Boolean
        },
        toastOptions: {},
        class: {},
        style: {},
        offset: {},
        mobileOffset: {},
        dir: {},
        swipeDirections: {},
        icons: {},
        containerAriaLabel: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Ir(Nt(X_), Gr({
            class: "toaster group"
        }, t, {
            style: {
                "--normal-bg": "var(--popover)",
                "--normal-text": "var(--popover-foreground)",
                "--normal-border": "var(--border)"
            }
        }), null, 16))
    }
});
const wO = {
    class: "px-4 pt-[72px]"
}
  , _O = {
    class: "bg-surface rounded-b-xl w-full mb-4"
}
  , xO = {
    class: "mx-auto max-w-(--max-layout-width) w-full px-5 pt-6 md:pt-7 pb-[calc(68px+2.4rem)] md:pb-12"
}
  , kO = to({
    __name: "App",
    setup(e) {
        const t = XC();
        return QC().init(),
        function() {
            const e = XC()
              , t = JC();
            e.init(),
            Qa( () => {
                var t;
                return null == (t = e.theme) ? void 0 : t.favicon
            }
            , e => t.applyFavicon(e), {
                immediate: !0
            }),
            Qa( () => e.seo, t => {
                t && e.applySeo()
            }
            , {
                immediate: !0
            })
        }(),
        (e, n) => {
            const o = yO
              , a = Fo("RouterView")
              , r = UA
              , s = FA
              , i = zA;
            return Tr(),
            Br(_r, null, [jr(s, null, {
                default: En( () => [jr(o), Dr("div", wO, [Dr("main", _O, [Dr("div", xO, [jr(a, null, {
                    default: En( ({Component: e}) => [jr(zs, {
                        name: "fade",
                        mode: "out-in"
                    }, {
                        default: En( () => [Dr("div", null, [(Tr(),
                        Ir(Vo(e)))])]),
                        _: 2
                    }, 1024)]),
                    _: 1
                })]), n[0] || (n[0] = Dr("div", {
                    class: "flex justify-between"
                }, [Dr("div", {
                    class: "bg-sidebar fixed z-1 top-[72px]"
                }, [Dr("div", {
                    class: "bg-surface rounded-tl-xl size-4"
                })]), Dr("div", {
                    class: "bg-sidebar fixed z-1 top-[72px] right-4"
                }, [Dr("div", {
                    class: "bg-surface rounded-tr-xl size-4"
                })])], -1))])]), jr(r)]),
                _: 1
            }), jr(Nt(bO), {
                "rich-colors": !0,
                theme: "dark",
                position: Nt(t).isMobile ? "top-center" : "top-right",
                style: U({
                    top: Nt(t).isMobile ? void 0 : "90px"
                })
            }, null, 8, ["position", "style"]), jr(i)], 64)
        }
    }
})
  , SO = {}
  , CO = function(e, t, n) {
    let o = Promise.resolve();
    if (t && t.length > 0) {
        let e = function(e) {
            return Promise.all(e.map(e => Promise.resolve(e).then(e => ({
                status: "fulfilled",
                value: e
            }), e => ({
                status: "rejected",
                reason: e
            }))))
        };
        document.getElementsByTagName("link");
        const n = document.querySelector("meta[property=csp-nonce]")
          , a = (null == n ? void 0 : n.nonce) || (null == n ? void 0 : n.getAttribute("nonce"));
        o = e(t.map(e => {
            if ((e = function(e) {
                return "/" + e
            }(e))in SO)
                return;
            SO[e] = !0;
            const t = e.endsWith(".css")
              , n = t ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${e}"]${n}`))
                return;
            const o = document.createElement("link");
            return o.rel = t ? "stylesheet" : "modulepreload",
            t || (o.as = "script"),
            o.crossOrigin = "",
            o.href = e,
            a && o.setAttribute("nonce", a),
            document.head.appendChild(o),
            t ? new Promise( (t, n) => {
                o.addEventListener("load", t),
                o.addEventListener("error", () => n(new Error(`Unable to preload CSS for ${e}`)))
            }
            ) : void 0
        }
        ))
    }
    function a(e) {
        const t = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (t.payload = e,
        window.dispatchEvent(t),
        !t.defaultPrevented)
            throw e
    }
    return o.then(t => {
        for (const e of t || [])
            "rejected" === e.status && a(e.reason);
        return e().catch(a)
    }
    )
}
  , EO = to({
    __name: "Skeleton",
    props: {
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("div", {
            "data-slot": "skeleton",
            class: K(Nt(hv)("animate-pulse rounded-md bg-primary/10", t.class))
        }, null, 2))
    }
})
  , TO = {
    viewBox: "0 0 59 60",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
};
const AO = gE({}, [["render", function(e, t) {
    return Tr(),
    Br("svg", TO, t[0] || (t[0] = [Hr('<path d="M2.381 31.8854L0.250732 32.1093L5.76436 16.3468L8.04082 16.1075L13.5753 30.7088L11.4242 30.9349L10.0667 27.2976L3.71764 27.9649L2.381 31.8854ZM6.64153 19.5306L4.34418 26.114L9.461 25.5762L7.14277 19.4779C7.101 19.3283 7.05227 19.1794 6.99657 19.0313C6.94088 18.8691 6.90607 18.7328 6.89215 18.6222C6.8643 18.7372 6.82949 18.8808 6.78772 19.0532C6.74595 19.2116 6.69722 19.3707 6.64153 19.5306Z" fill="#7B869D"></path><path d="M28.5469 21.5332C28.5469 23.0732 28.2336 24.4711 27.6071 25.727C26.9945 26.9674 26.1382 27.9814 25.0382 28.769C23.9522 29.5411 22.6922 30.0026 21.2581 30.1533C19.8518 30.3011 18.5987 30.1038 17.4988 29.5614C16.4128 29.0036 15.5634 28.1688 14.9508 27.0572C14.3382 25.9456 14.0319 24.6128 14.0319 23.0588C14.0319 21.5188 14.3382 20.1286 14.9508 18.8882C15.5774 17.6464 16.4336 16.6324 17.5197 15.8462C18.6057 15.0601 19.8588 14.5924 21.2789 14.4431C22.7131 14.2924 23.9731 14.4959 25.0591 15.0538C26.1451 15.6117 26.9945 16.4464 27.6071 17.558C28.2336 18.6681 28.5469 19.9932 28.5469 21.5332ZM26.3958 21.7593C26.3958 20.5833 26.18 19.577 25.7483 18.7404C25.3306 17.9023 24.7389 17.2855 23.9731 16.8899C23.2073 16.4804 22.3093 16.3298 21.2789 16.4381C20.2625 16.5449 19.3715 16.8836 18.6057 17.4541C17.8399 18.0106 17.2412 18.7525 16.8096 19.6799C16.3919 20.6058 16.183 21.6567 16.183 22.8327C16.183 24.0087 16.3919 25.0158 16.8096 25.8539C17.2412 26.6905 17.8399 27.3136 18.6057 27.7231C19.3715 28.1326 20.2625 28.2839 21.2789 28.1771C22.3093 28.0688 23.2073 27.7294 23.9731 27.1589C24.7389 26.5745 25.3306 25.8193 25.7483 24.8934C26.18 23.966 26.3958 22.9213 26.3958 21.7593Z" fill="#7B869D"></path><path d="M5.74539 52.1851L0.200195 37.8724L3.66344 37.5084L6.46607 44.7421C6.63956 45.1801 6.79971 45.6397 6.94652 46.1208C7.09332 46.6018 7.2468 47.156 7.40695 47.7833C7.59379 47.0525 7.76061 46.4445 7.90742 45.9594C8.06757 45.4729 8.22772 44.9998 8.38787 44.5401L11.1505 36.7215L14.5336 36.3659L9.08853 51.8337L5.74539 52.1851Z" fill="#00E880"></path><path d="M19.3247 35.8623V50.7578L16.0816 51.0987V36.2032L19.3247 35.8623Z" fill="#00E880"></path><path d="M26.4195 50.0121L20.8743 35.6995L24.3375 35.3355L27.1401 42.5692C27.3136 43.0072 27.4738 43.4667 27.6206 43.9478C27.7674 44.4289 27.9209 44.9831 28.081 45.6104C28.2679 44.8795 28.4347 44.2716 28.5815 43.7864C28.7416 43.2999 28.9018 42.8268 29.0619 42.3672L31.8245 34.5486L35.2077 34.193L29.7626 49.6608L26.4195 50.0121Z" fill="#00E880"></path><path d="M49.647 40.1029C49.647 41.6193 49.3401 42.9935 48.7261 44.2255C48.1122 45.4441 47.2581 46.4397 46.1637 47.2123C45.0694 47.9714 43.8015 48.4268 42.3602 48.5782C40.9322 48.7283 39.671 48.5388 38.5766 48.0097C37.4956 47.4658 36.6482 46.6491 36.0343 45.5595C35.4337 44.4686 35.1334 43.1649 35.1334 41.6485C35.1334 40.1321 35.4404 38.7646 36.0543 37.5461C36.6682 36.314 37.5156 35.3192 38.5967 34.5614C39.691 33.7889 40.9522 33.3275 42.3802 33.1774C43.8216 33.0259 45.0827 33.2222 46.1637 33.7661C47.2581 34.2952 48.1122 35.1045 48.7261 36.1941C49.3401 37.2836 49.647 38.5866 49.647 40.1029ZM46.2238 40.4627C46.2238 39.51 46.0703 38.7142 45.7634 38.0755C45.4564 37.4234 45.016 36.9463 44.4421 36.6443C43.8816 36.3409 43.201 36.2313 42.4002 36.3155C41.5995 36.3996 40.9122 36.653 40.3383 37.0757C39.7644 37.4983 39.324 38.0679 39.017 38.7846C38.7101 39.4878 38.5566 40.3158 38.5566 41.2686C38.5566 42.2214 38.7101 43.0238 39.017 43.6759C39.324 44.3281 39.7644 44.8051 40.3383 45.1071C40.9122 45.4091 41.5995 45.5181 42.4002 45.4339C43.201 45.3497 43.8816 45.097 44.4421 44.6758C45.016 44.2398 45.4564 43.6634 45.7634 42.9467C46.0703 42.2301 46.2238 41.4021 46.2238 40.4627Z" fill="#00E880"></path><circle cx="39" cy="20" r="6" fill="#222733"></circle><g filter="url(#filter0_d_726_17235)"><circle cx="39" cy="20" r="3.75" fill="#00E880"></circle></g>', 8)]))
}
]])
  , OO = {
    class: "hidden sm:flex"
}
  , MO = {
    class: "flex overflow-hidden gap-2 ml-2 list-shadow"
}
  , PO = ["src", "alt"]
  , BO = {
    class: "flex flex-col text-xs sm:text-sm"
}
  , IO = {
    class: "font-medium text-muted-foreground overflow-hidden text-nowrap text-ellipsis w-26"
}
  , LO = {
    class: "font-semibold"
}
  , RO = {
    class: "flex overflow-hidden gap-2 ml-3 list-shadow"
}
  , zO = to({
    __name: "ScratchWinners",
    setup(e) {
        const t = It(!1)
          , n = It(!1)
          , o = It([]);
        return Mo(async () => {
            await async function() {
                try {
                    t.value = !0,
                    n.value = !1;
                    const {data: e} = await b_.get("/scratch/live");
                    o.value = e.data
                } catch (e) {
                    n.value = !0
                } finally {
                    t.value = !1
                }
            }()
        }
        ),
        (e, a) => {
            const r = AO
              , s = EO;
            return Tr(),
            Br("div", OO, [t.value || n.value ? (Tr(),
            Br(_r, {
                key: 1
            }, [jr(s, {
                class: "w-24 h-14.5 bg-muted-foreground/15"
            }), Dr("div", RO, [(Tr(),
            Br(_r, null, qo(8, e => jr(s, {
                key: e,
                class: "w-55.5 h-14.5 bg-muted-foreground/15"
            })), 64))])], 64)) : (Tr(),
            Br(_r, {
                key: 0
            }, [jr(r, {
                class: "w-37"
            }), Dr("section", MO, [(Tr(!0),
            Br(_r, null, qo(o.value, e => (Tr(),
            Br("div", {
                key: e.name,
                class: "flex items-center justify-center gap-3 py-3 px-7 select-none group rounded-lg border w-56 cursor-pointer hover:bg-secondary"
            }, [Dr("img", {
                src: e.image,
                class: "size-8 object-contain",
                alt: e.name
            }, null, 8, PO), Dr("div", BO, [Dr("h1", IO, ne(e.name), 1), Dr("span", LO, ne(Nt(hC)(e.amount)), 1)])]))), 128))])], 64))])
        }
    }
})
  , NO = {
    viewBox: "0 0 512 512",
    xmlns: "http://www.w3.org/2000/svg"
};
const DO = gE({}, [["render", function(e, t) {
    return Tr(),
    Br("svg", NO, t[0] || (t[0] = [Hr('<g class="fill-muted-foreground"><path d="m504.485 217.165c4.151 0 7.515-3.364 7.515-7.515v-78.47c0-12.431-10.113-22.544-22.544-22.544h-7.808l-14.033-46.49c-3.591-11.899-16.19-18.663-28.096-15.068l-56.555 17.07c-3.974 1.199-6.222 5.392-5.023 9.365s5.389 6.224 9.365 5.022l56.555-17.069c3.967-1.2 8.169 1.056 9.366 5.022l12.722 42.148h-178.363l70.962-21.419c3.974-1.199 6.222-5.392 5.023-9.365-1.2-3.974-5.393-6.227-9.365-5.023l-118.629 35.806h-129.772c-4.15 0-7.515 3.364-7.515 7.515s3.365 7.515 7.515 7.515h383.651c4.144 0 7.515 3.371 7.515 7.515v71.479c-26.154 3.668-46.346 26.19-46.346 53.339s20.193 49.67 46.346 53.339v71.486c0 4.144-3.371 7.515-7.515 7.515h-66.975c-4.151 0-7.515 3.364-7.515 7.515s3.364 7.515 7.515 7.515h66.975c12.431 0 22.544-10.114 22.544-22.544v-78.479c0-4.151-3.364-7.515-7.515-7.515-21.412 0-38.832-17.42-38.832-38.832.001-21.413 17.42-38.833 38.832-38.833z"></path><path class="fill-primary" d="m392.423 388.336h-369.879c-4.144 0-7.515-3.371-7.515-7.515v-249.641c0-4.144 3.371-7.515 7.515-7.515h53.202c4.15 0 7.515-3.364 7.515-7.515s-3.365-7.515-7.515-7.515h-53.202c-12.431.001-22.544 10.114-22.544 22.545v249.642c0 12.43 10.113 22.544 22.544 22.544h7.807l14.032 46.49c2.939 9.738 11.91 16.031 21.594 16.031 2.151 0 210.445-62.522 210.445-62.522h116c4.151 0 7.515-3.364 7.515-7.515s-3.364-7.514-7.514-7.514zm-324.286 62.2c-3.965 1.197-8.168-1.058-9.365-5.022l-12.722-42.148h178.364z"></path><path d="m312.478 195.759c0 4.151 3.364 7.515 7.515 7.515s7.515-3.364 7.515-7.515v-15.029c0-4.151-3.364-7.515-7.515-7.515s-7.515 3.364-7.515 7.515z"></path><path d="m312.478 285.935c0 4.151 3.364 7.515 7.515 7.515s7.515-3.364 7.515-7.515v-15.029c0-4.151-3.364-7.515-7.515-7.515s-7.515 3.364-7.515 7.515z"></path><path d="m312.478 376.111c0 4.151 3.364 7.515 7.515 7.515s7.515-3.364 7.515-7.515v-15.029c0-4.151-3.364-7.515-7.515-7.515s-7.515 3.364-7.515 7.515z"></path><path class="fill-primary" d="m312.478 331.023c0 4.151 3.364 7.515 7.515 7.515s7.515-3.364 7.515-7.515v-15.029c0-4.151-3.364-7.515-7.515-7.515s-7.515 3.364-7.515 7.515z"></path><path class="fill-primary" d="m319.992 158.186c4.151 0 7.515-3.364 7.515-7.515v-15.029c0-4.151-3.364-7.515-7.515-7.515s-7.515 3.364-7.515 7.515v15.029c.001 4.151 3.364 7.515 7.515 7.515z"></path><path class="fill-primary" d="m312.478 240.847c0 4.151 3.364 7.515 7.515 7.515s7.515-3.364 7.515-7.515v-15.029c0-4.151-3.364-7.515-7.515-7.515s-7.515 3.364-7.515 7.515z"></path><path class="fill-primary" d="m382.031 311.367v-107.73c0-4.151-3.364-7.515-7.515-7.515s-7.515 3.364-7.515 7.515v107.73c0 4.151 3.364 7.515 7.515 7.515s7.515-3.365 7.515-7.515z"></path><path class="fill-primary" d="m418.102 286.253v-57.503c0-4.151-3.364-7.515-7.515-7.515s-7.515 3.364-7.515 7.515v57.503c0 4.151 3.364 7.515 7.515 7.515s7.515-3.364 7.515-7.515z"></path><path class="fill-primary" d="m83.261 221.618v20.179c0 8.871 6.628 16.205 15.188 17.358v64.799c0 12.431 10.113 22.544 22.544 22.544h98.847c12.431 0 22.544-10.113 22.544-22.544v-64.799c8.56-1.153 15.187-8.488 15.187-17.358v-20.179c0-9.668-7.865-17.534-17.534-17.534h-2.291c.157-3.58.164-7.962-.273-12.587-1.93-20.46-10.877-28.938-18.043-32.448-16.525-8.093-30.087 4.428-36.743 14.765h-24.543c-6.655-10.339-20.217-22.863-36.743-14.765-7.166 3.51-16.113 11.988-18.043 32.448-.436 4.625-.43 9.007-.273 12.587h-2.291c-9.667 0-17.533 7.866-17.533 17.534zm15.029 0c0-1.382 1.124-2.505 2.505-2.505h61.407v25.189h-61.407c-1.381 0-2.505-1.123-2.505-2.505zm15.188 102.337v-64.623h48.724v72.138h-41.209c-4.144-.001-7.515-3.371-7.515-7.515zm113.877 0c0 4.144-3.371 7.515-7.515 7.515h-42.609v-72.138h50.124zm15.188-102.337v20.179c0 1.382-1.124 2.505-2.505 2.505h-62.807v-25.189h62.807c1.381 0 2.505 1.124 2.505 2.505zm-29.723-49.072c9.203 4.508 10.414 21.04 9.898 31.538h-28.176v-20.819c2.373-4.022 9.763-14.888 18.278-10.719zm-33.306 31.538h-18.194v-15.241h18.194zm-51.502-31.538c5.228-4.41 15.74 5.079 18.278 10.743v20.795h-28.176c-.515-10.503.697-27.031 9.898-31.538z"></path></g>', 1)]))
}
]])
  , jO = to({
    __name: "Card",
    props: {
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("div", {
            "data-slot": "card",
            class: K(Nt(hv)("bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm", t.class))
        }, [Wo(e.$slots, "default")], 2))
    }
})
  , FO = {
    viewBox: "0 0 55 60",
    xmlns: "http://www.w3.org/2000/svg"
};
const $O = gE({}, [["render", function(e, t) {
    return Tr(),
    Br("svg", FO, t[0] || (t[0] = [Hr('<g id="Page-1" fill="none" fill-rule="evenodd"><g id="018---More-Money" class="fill-muted-foreground" fill="rgb(0,0,0)" fill-rule="nonzero"><path d="m22.6 52.477c2.4381532.0664719 4.8007747-.8494628 6.557-2.542 4.094-4.095 3.143-11.707-2.121-16.971s-12.878-6.215-16.971-2.121-3.142 11.706 2.122 16.97c2.7283294 2.855432 6.465952 4.5295194 10.413 4.664zm-11.121-20.22c1.3829803-1.3247437 3.2408554-2.0372596 5.155-1.977 3.4148006.1474118 6.6382337 1.6178252 8.988 4.1 4.483 4.484 5.436 10.828 2.121 14.143s-9.658 2.36-14.143-2.123-5.434-10.829-2.121-14.143z"></path><path d="m5.823 54.177c3.48190299 3.6033036 8.242691 5.6905492 13.252 5.81 3.492765.0766788 6.8701877-1.251594 9.375-3.687l3.535-3.535c2.8161273-2.9151419 4.1492397-6.955345 3.621-10.974-.5172225-4.4290001-2.545087-8.5444137-5.742-11.653-3.1087326-3.1967117-7.2240703-5.2245388-11.653-5.742-4.0184975-.5285015-8.0586776.8042352-10.974 3.62l-3.537 3.534c-5.652 5.65-4.7 15.804 2.123 22.627zm10.777-27.864c.4705585.0000871.9408163.0237835 1.409.071 3.9707.4705892 7.6579836 2.2949841 10.441 5.166 2.8698668 2.7826328 4.6941118 6.4685539 5.166 10.438.4634396 3.4212193-.6574755 6.8671587-3.045 9.361-2.4933781 2.3876185-5.9390709 3.508573-9.36 3.045-3.9695418-.4725396-7.6555728-2.2966641-10.439-5.166-2.86933586-2.7834272-4.6934604-6.4694582-5.166-10.439-.46358955-3.4212328.65734622-6.867236 3.045-9.361 2.1236622-2.0639495 4.9884759-3.1865931 7.949-3.115zm-12.8 8.295c-.27365893 1.4432929-.33664725 2.9186344-.187 4.38.51827308 4.4289795 2.54595505 8.5443758 5.742 11.654 3.1096242 3.196045 7.2250205 5.2237269 11.654 5.742.546.054 1.0846667.081 1.616.081.9213631.000544 1.8407385-.085501 2.746-.257-5.048 3.279-12.725 1.966-18.137-3.445s-6.725-13.108-3.434-18.155z"></path><path class="fill-primary" d="m8.987 4.265c-2.539-.614-4.724-.165-6.153 1.265s-1.878 3.614-1.265 6.153c.71245592 2.6051432 2.11597072 4.9692121 4.062 6.842 2.815 2.816 6.148 4.338 8.938 4.337 1.5050467.0552293 2.9685297-.5001585 4.058-1.54 2.858-2.86 1.63-8.568-2.8-12.995-1.871642-1.94646872-4.2352023-3.3500918-6.84-4.062zm8.226 15.643c-2 1.995-6.653.717-10.168-2.8-1.68663526-1.6129655-2.90655204-3.6513424-3.531-5.9-.445-1.836-.183-3.352.734-4.269.71287655-.65234574 1.65807854-.9907158 2.623-.939.55539423.00521941 1.10822658.07604371 1.647.211 2.2487864.62468481 4.2871859 1.84496061 5.9 3.532 3.511 3.511 4.792 8.168 2.795 10.165z"></path><path d="m53.116 8.888-3-3c-3.569-3.572-10.74-1.988-16.325 3.598-2.4686135 2.3733777-4.2494711 5.3701525-5.154 8.673-.765 3.168-.214 5.884 1.552 7.651h.005l3 3c1.3504087 1.2860795 3.1635325 1.971366 5.027 1.9 3.51 0 7.727-1.934 11.3-5.5 5.579-5.585 7.163-12.755 3.595-16.322zm-22.535 9.74c.8185827-2.9448435 2.4159692-5.614524 4.624-7.728 3.122-3.122 6.946-4.889 9.93-4.889 1.313143-.06602741 2.5977304.39844193 3.565 1.289 1.252 1.255 1.615 3.3 1.02 5.764-.8167105 2.9453027-2.4127723 5.6157697-4.62 7.73-4.635 4.634-10.814 6.282-13.5 3.6-1.251-1.253-1.615-3.301-1.019-5.766zm4.393 9.072c.08 0 .159.009.241.009 3.511 0 7.728-1.934 11.3-5.505 2.467663-2.3735634 4.2480819-5.369836 5.153-8.672.2326302-.9468555.3395495-1.9202243.318-2.895 2.254 2.832.569 8.7-3.882 13.157-4.438 4.44-10.285 6.131-13.13 3.906z"></path><path class="fill-primary" d="m24.305 0c-.5522847 0-1 .44771525-1 1v3c0 .55228475.4477153 1 1 1s1-.44771525 1-1v-3c0-.55228475-.4477153-1-1-1z"></path><path class="fill-primary" d="m23.305 11c0 .5522847.4477153 1 1 1s1-.4477153 1-1v-3c0-.55228475-.4477153-1-1-1s-1 .44771525-1 1z"></path><path class="fill-primary" d="m26.305 7h3c.5522847 0 1-.44771525 1-1s-.4477153-1-1-1h-3c-.5522847 0-1 .44771525-1 1s.4477153 1 1 1z"></path><path class="fill-primary" d="m22.305 5h-3c-.5522847 0-1 .44771525-1 1s.4477153 1 1 1h3c.5522847 0 1-.44771525 1-1s-.4477153-1-1-1z"></path><path class="fill-primary" d="m47.707 36.293c-.3904999-.3903819-1.0235001-.3903819-1.414 0l-2 2c-.2599566.2510745-.3642126.6228779-.2726972.9725073.0915155.3496295.3645604.6226744.7141899.7141899.3496294.0915154.7214328-.0127406.9725073-.2726972l2-2c.3903819-.3904999.3903819-1.0235001 0-1.414z"></path><path class="fill-primary" d="m41.293 41.293-2 2c-.2599566.2510745-.3642126.6228779-.2726972.9725073.0915155.3496295.3645604.6226744.7141899.7141899.3496294.0915154.7214328-.0127406.9725073-.2726972l2-2c.3789722-.3923789.3735524-1.0160848-.0121814-1.4018186s-1.0094397-.3911536-1.4018186-.0121814z"></path><path class="fill-primary" d="m45.707 41.293c-.3923789-.3789722-1.0160848-.3735524-1.4018186.0121814s-.3911536 1.0094397-.0121814 1.4018186l2 2c.3923789.3789722 1.0160848.3735524 1.4018186-.0121814s.3911536-1.0094397.0121814-1.4018186z"></path><path class="fill-primary" d="m42.707 38.293-2-2c-.3923789-.3789722-1.0160848-.3735524-1.4018186.0121814s-.3911536 1.0094397-.0121814 1.4018186l2 2c.3923789.3789722 1.0160848.3735524 1.4018186-.0121814s.3911536-1.0094397.0121814-1.4018186z"></path><path d="m15.553 42.9c.2373497.1186659.5121326.1381283.7638386.0541012.251706-.084027.4596935-.2646527.5781614-.5021012l4-8c.2468713-.4942948.0462948-1.0951287-.448-1.342-.4942949-.2468712-1.0951287-.0462948-1.342.448l-4 8c-.1186659.2373497-.1381283.5121326-.0541012.7638386.084027.251706.2646527.4596935.5021012.5781614z"></path><path d="m19.553 45.9c.2373497.1186659.5121326.1381283.7638386.0541012.251706-.084027.4596935-.2646527.5781614-.5021012l2-4c.2468713-.4942948.0462948-1.0951287-.448-1.342-.4942949-.2468712-1.0951287-.0462948-1.342.448l-2 4c-.1186659.2373497-.1381283.5121326-.0541012.7638386.084027.251706.2646527.4596935.5021012.5781614z"></path><path d="m36.11 15.829c.107809.0002392.2149173-.0173306.317-.052l8.485-2.828c.5246705-.1747981.8082981-.7418295.6335-1.2665s-.7418295-.8082981-1.2665-.6335l-8.485 2.831c-.465753.1547317-.7503816.6245882-.6718345 1.1090447.0785471.4844566.4970518.840311.9878345.8399553z"></path><path d="m40.743 17.415-4.243 1.415c-.3394023.1130746-.5926984.3986287-.6644741.749097s.0488734.7126063.3165.95c.2676266.2373938.6415718.3139776.9809741.200903l4.242-1.414c.5246705-.1747981.8082981-.7418295.6335-1.2665-.1747982-.5246705-.7418295-.8082981-1.2665-.6335z"></path></g></g>', 1)]))
}
]])
  , VO = {
    class: "grid grid-cols-1 md:grid-cols-2 gap-4.5"
}
  , HO = to({
    __name: "Features",
    setup: e => (e, t) => {
        const n = $O
          , o = Qv
          , a = Fo("RouterLink")
          , r = jO
          , s = DO;
        return Tr(),
        Br("div", VO, [jr(r, {
            class: "col-span-1 px-7 py-5 bg-white/1 gap-3 sm:gap-4 sm:border-r-2 sm:border-r-primary/65 relative overflow-hidden"
        }, {
            default: En( () => [jr(n, {
                class: "size-14 sm:size-24 mb-1 sm:-my-2"
            }), t[1] || (t[1] = Dr("h1", {
                class: "font-bold text-xl sm:text-[1.8rem] text-card-foreground/75"
            }, " RASPADINHAS ", -1)), t[2] || (t[2] = Dr("p", {
                class: "text-card-foreground/65 text-sm"
            }, " Explore diversas raspadinhas com diversos temas e prmios. ", -1)), jr(a, {
                to: "/raspadinha"
            }, {
                default: En( () => [jr(o, {
                    size: "sm",
                    class: "w-48 font-semibold !cursor-pointer"
                }, {
                    default: En( () => [t[0] || (t[0] = Vr("VER RASPADINHAS ")), jr(Nt(sm).ArrowRight)]),
                    _: 1,
                    __: [0]
                })]),
                _: 1
            }), t[3] || (t[3] = Dr("img", {
                src: "/assets/scratch.png",
                class: "absolute -right-40 sm:-right-72 top-4 sm:top-1 sm:h-90 opacity-22 object-contain",
                alt: ""
            }, null, -1))]),
            _: 1,
            __: [1, 2, 3]
        }), jr(r, {
            class: "col-span-1 px-7 py-5 bg-white/1 gap-3 sm:gap-4 sm:border-r-2 sm:border-r-primary/65 relative overflow-hidden"
        }, {
            default: En( () => [jr(s, {
                class: "size-14 sm:size-24 mb-1 sm:-my-2"
            }), t[5] || (t[5] = Dr("h1", {
                class: "font-bold text-xl sm:text-[1.8rem] text-card-foreground/75"
            }, " SORTEIOS ", -1)), t[6] || (t[6] = Dr("p", {
                class: "text-card-foreground/65 text-sm"
            }, " Explore diversas raspadinhas com diversos temas e prmios. ", -1)), jr(o, {
                size: "sm",
                class: "w-48 font-semibold"
            }, {
                default: En( () => [t[4] || (t[4] = Vr("VER SORTEIOS ")), jr(Nt(sm).ArrowRight)]),
                _: 1,
                __: [4]
            }), t[7] || (t[7] = Dr("img", {
                src: "/assets/raffle.png",
                class: "absolute -right-40 sm:-right-63 top-4 sm:top-3 sm:h-80 opacity-19 object-contain",
                alt: ""
            }, null, -1))]),
            _: 1,
            __: [5, 6, 7]
        })])
    }
})
  , UO = to({
    __name: "CardContent",
    props: {
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("div", {
            "data-slot": "card-content",
            class: K(Nt(hv)("px-6", t.class))
        }, [Wo(e.$slots, "default")], 2))
    }
})
  , ZO = to({
    __name: "Stepper",
    props: {
        defaultValue: {},
        orientation: {},
        dir: {},
        modelValue: {},
        linear: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    emits: ["update:modelValue"],
    setup(e, {emit: t}) {
        const n = e
          , o = t
          , a = Zd(Lf(n, "class"), o);
        return (e, t) => (Tr(),
        Ir(Nt(kf), Gr({
            class: Nt(hv)("flex gap-2", n.class)
        }, Nt(a)), {
            default: En(t => [Wo(e.$slots, "default", Y(Fr(t)))]),
            _: 3
        }, 16, ["class"]))
    }
})
  , qO = to({
    __name: "StepperItem",
    props: {
        step: {},
        disabled: {
            type: Boolean
        },
        completed: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Ud(Lf(t, "class"));
        return (e, o) => (Tr(),
        Ir(Nt(Ef), Gr(Nt(n), {
            class: Nt(hv)("flex items-center gap-2 group data-[disabled]:pointer-events-none", t.class)
        }), {
            default: En(t => [Wo(e.$slots, "default", Y(Fr(t)))]),
            _: 3
        }, 16, ["class"]))
    }
})
  , WO = to({
    __name: "StepperDescription",
    props: {
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Ud(Lf(t, "class"));
        return (e, o) => (Tr(),
        Ir(Nt(Tf), Gr(Nt(n), {
            class: Nt(hv)("text-xs text-muted-foreground", t.class)
        }), {
            default: En(t => [Wo(e.$slots, "default", Y(Fr(t)))]),
            _: 3
        }, 16, ["class"]))
    }
})
  , GO = to({
    __name: "StepperTitle",
    props: {
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Ud(Lf(t, "class"));
        return (e, o) => (Tr(),
        Ir(Nt(Of), Gr(Nt(n), {
            class: Nt(hv)("text-md font-semibold whitespace-nowrap", t.class)
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["class"]))
    }
})
  , KO = to({
    __name: "StepperTrigger",
    props: {
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Ud(Lf(t, "class"));
        return (e, o) => (Tr(),
        Ir(Nt(Mf), Gr(Nt(n), {
            class: Nt(hv)("p-1 flex flex-col items-center text-center gap-1 rounded-md", t.class)
        }), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["class"]))
    }
})
  , YO = to({
    __name: "StepperSeparator",
    props: {
        orientation: {},
        decorative: {
            type: Boolean
        },
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Ud(Lf(t, "class"));
        return (e, o) => (Tr(),
        Ir(Nt(Af), Gr(Nt(n), {
            class: Nt(hv)("bg-muted", "group-data-[disabled]:bg-muted group-data-[disabled]:opacity-50", "group-data-[state=completed]:bg-accent-foreground", t.class)
        }), null, 16, ["class"]))
    }
})
  , XO = {
    class: "mt-0.5 flex flex-col items-start sm:items-center text-start sm:text-center"
}
  , JO = to({
    __name: "BillingStepper",
    setup(e) {
        const t = [{
            step: 1,
            title: "Cadastre-se",
            description: "Realize seu cadastro para participar",
            icon: Qf,
            reached: !0
        }, {
            step: 2,
            title: "Deposite",
            description: "Realize um depsito",
            icon: sm.Pix,
            reached: !1
        }, {
            step: 3,
            title: "Hora de Raspar",
            description: "Raspe o carto para ganhar prmios",
            icon: sm.Ticket,
            reached: !1
        }, {
            step: 4,
            title: "Ganhe Prmios",
            description: "Receba nmeros para concorrer",
            icon: sm.Gift,
            reached: !1
        }]
          , n = ms( () => t.find(e => !e.reached));
        return (e, o) => {
            const a = YO
              , r = Qv
              , s = KO
              , i = GO
              , l = WO
              , u = qO
              , c = ZO
              , d = UO
              , p = jO;
            return Tr(),
            Ir(p, null, {
                default: En( () => [jr(d, null, {
                    default: En( () => [jr(c, {
                        class: "relative flex-col sm:flex-row items-start w-full gap-5 lg:gap-2",
                        "default-value": t[1].step
                    }, {
                        default: En( () => [(Tr(),
                        Br(_r, null, qo(t, e => jr(u, {
                            key: e.step,
                            class: "relative flex w-full sm:flex-col lg:items-center lg:justify-center gap-4 sm:gap-3",
                            step: e.step
                        }, {
                            default: En( () => {
                                var o;
                                return [e.step !== t.length ? (Tr(),
                                Ir(a, {
                                    key: 0,
                                    class: K(["absolute left-[calc(50%+20px)] right-[calc(-50%+10px)] top-5 h-0.5 shrink-0 rounded-full bg-muted hidden lg:block", e.reached && "!bg-primary"])
                                }, null, 8, ["class"])) : Ur("", !0), jr(s, {
                                    "as-child": ""
                                }, {
                                    default: En( () => {
                                        var t, o;
                                        return [jr(r, {
                                            variant: e.reached || (null == (t = n.value) ? void 0 : t.step) === e.step && !e.reached ? "default" : "outline",
                                            size: "icon",
                                            class: K(["z-10 rounded-full shrink-0 pointer-events-none", [(null == (o = n.value) ? void 0 : o.step) !== e.step || e.reached ? "" : "sm:ring-2 ring-ring ring-offset-2 ring-offset-background"]])
                                        }, {
                                            default: En( () => [e.reached ? (Tr(),
                                            Ir(Nt(eh), {
                                                key: 0,
                                                class: "size-5"
                                            })) : (Tr(),
                                            Ir(Vo(e.icon), {
                                                key: 1,
                                                class: "size-5"
                                            }))]),
                                            _: 2
                                        }, 1032, ["variant", "class"])]
                                    }
                                    ),
                                    _: 2
                                }, 1024), Dr("div", XO, [jr(i, {
                                    class: K([(null == (o = n.value) ? void 0 : o.step) === e.step && !e.reached && "text-primary", "text-md font-bold transition lg:text-base"])
                                }, {
                                    default: En( () => [Vr(ne(e.title), 1)]),
                                    _: 2
                                }, 1032, ["class"]), jr(l, {
                                    class: "text-sm text-muted-foreground transition lg:text-sm"
                                }, {
                                    default: En( () => [Vr(ne(e.description), 1)]),
                                    _: 2
                                }, 1024)])]
                            }
                            ),
                            _: 2
                        }, 1032, ["step"])), 64))]),
                        _: 1
                    }, 8, ["default-value"])]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
})
  , QO = {
    class: "group/hero relative"
}
  , eM = ["href"]
  , tM = ["src"]
  , nM = to({
    __name: "Hero",
    setup(e) {
        const t = XC()
          , n = [iC, rC, lC]
          , o = ms( () => t.banners);
        return (e, t) => (Tr(),
        Br("section", QO, [jr(Nt(tC), {
            modules: n,
            loop: "",
            autoplay: {
                delay: 5e3,
                disableOnInteraction: !1
            },
            pagination: {
                clickable: !0,
                renderBullet: (e, t) => `<div class='${t} !bg-white w-[15px] h-[3px] rounded-lg'></div>`
            },
            navigation: {
                nextEl: ".hero-next-button",
                prevEl: ".hero-prev-button"
            },
            class: "md:rounded-lg overflow-hidden"
        }, {
            default: En( () => [(Tr(!0),
            Br(_r, null, qo(o.value, e => (Tr(),
            Ir(Nt(nC), {
                key: e.order_value
            }, {
                default: En( () => [Dr("a", {
                    href: e.action
                }, [Dr("img", {
                    src: e.image,
                    class: "aspect-[5/1] w-full object-cover transition-all rounded-lg overflow-hidden",
                    alt: "Banner {{ b.order_value }}"
                }, null, 8, tM)], 8, eM)]),
                _: 2
            }, 1024))), 128))]),
            _: 1
        }, 8, ["pagination"]), jr(Nt(sm).Left, {
            class: "hero-prev-button size-6 absolute left-2 top-1/2 -translate-y-1/2 cursor-pointer z-20 opacity-0 transition-opacity group-hover/hero:opacity-100 drop-shadow"
        }), jr(Nt(sm).Left, {
            class: "hero-next-button size-6 absolute right-2 top-1/2 -translate-y-1/2 cursor-pointer z-20 opacity-0 transition-opacity group-hover/hero:opacity-100 drop-shadow -scale-x-100"
        })]))
    }
})
  , oM = {
    class: "flex flex-col gap-6"
};
const aM = gE({}, [["render", function(e, t) {
    const n = nM
      , o = JO
      , a = HO
      , r = zO;
    return Tr(),
    Br("section", oM, [jr(n), jr(o), jr(a), jr(r)])
}
]])
  , rM = {
    key: 0,
    class: "require-auth-page w-full pt-6 py-20 sm:py-20 flex flex-col items-center"
}
  , sM = to({
    __name: "RequiresLogin",
    setup(e) {
        const t = QC()
          , n = dm();
        return (e, o) => {
            const a = Qv
              , r = Fo("RouterLink");
            return Nt(t).authenticated ? Wo(e.$slots, "default", {
                key: Nt(t).authenticated
            }) : (Tr(),
            Br("div", rM, [o[3] || (o[3] = Dr("img", {
                src: "/assets/auth-CRzabI1Q.png",
                class: "mx-auto mb-3 object-contain size-96"
            }, null, -1)), o[4] || (o[4] = Dr("div", {
                class: "text-2xl font-medium text-center mb-8"
            }, " Acesse sua conta para acessar esta pgina ", -1)), jr(a, {
                primary: "",
                class: "cursor-pointer",
                onClick: o[0] || (o[0] = e => Nt(n).open("login"))
            }, {
                default: En( () => [jr(Nt(sm).Login, {
                    class: "size-5 text-current"
                }), o[1] || (o[1] = Vr(" Entrar "))]),
                _: 1,
                __: [1]
            }), jr(r, {
                to: "/",
                class: "text-primary mt-5"
            }, {
                default: En( () => o[2] || (o[2] = [Vr("Ir para pgina inicial")])),
                _: 1,
                __: [2]
            })]))
        }
    }
})
  , iM = to({
    __name: "Breadcrumb",
    props: {
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("nav", {
            "aria-label": "breadcrumb",
            "data-slot": "breadcrumb",
            class: K(t.class)
        }, [Wo(e.$slots, "default")], 2))
    }
})
  , lM = to({
    __name: "BreadcrumbList",
    props: {
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("ol", {
            "data-slot": "breadcrumb-list",
            class: K(Nt(hv)("text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5", t.class))
        }, [Wo(e.$slots, "default")], 2))
    }
})
  , uM = to({
    __name: "BreadcrumbSeparator",
    props: {
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("li", {
            "data-slot": "breadcrumb-separator",
            role: "presentation",
            "aria-hidden": "true",
            class: K(Nt(hv)("[&>svg]:size-3.5", t.class))
        }, [Wo(e.$slots, "default", {}, () => [jr(Nt(nh))])], 2))
    }
})
  , cM = to({
    __name: "BreadcrumbItem",
    props: {
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("li", {
            "data-slot": "breadcrumb-item",
            class: K(Nt(hv)("inline-flex items-center gap-1.5", t.class))
        }, [Wo(e.$slots, "default")], 2))
    }
})
  , dM = to({
    __name: "BreadcrumbPage",
    props: {
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("span", {
            "data-slot": "breadcrumb-page",
            role: "link",
            "aria-disabled": "true",
            "aria-current": "page",
            class: K(Nt(hv)("text-foreground font-normal", t.class))
        }, [Wo(e.$slots, "default")], 2))
    }
})
  , pM = to({
    __name: "BreadcrumbLink",
    props: {
        asChild: {
            type: Boolean
        },
        as: {
            default: "a"
        },
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Ir(Nt(yc), {
            "data-slot": "breadcrumb-link",
            as: e.as,
            "as-child": e.asChild,
            class: K(Nt(hv)("hover:text-foreground transition-colors", t.class))
        }, {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 8, ["as", "as-child", "class"]))
    }
})
  , fM = {
    class: "flex gap-1.5 mb-2 items-center text-sm font-medium sm:hidden"
}
  , hM = to({
    __name: "RouteHeader",
    setup(e) {
        const t = Bk()
          , n = Pk()
          , o = ms( () => t.matched.map( (e, o, a) => ({
            text: String(e.meta.breadcrumb || e.name || ""),
            href: o === a.length - 1 ? void 0 : n.resolve({
                name: e.name,
                params: t.params
            }).href
        })));
        return (e, t) => {
            const n = pM
              , a = dM
              , r = cM
              , s = uM
              , i = lM
              , l = iM;
            return Tr(),
            Br("div", fM, [jr(l, null, {
                default: En( () => [jr(i, null, {
                    default: En( () => [(Tr(!0),
                    Br(_r, null, qo(o.value, (e, t) => (Tr(),
                    Br(_r, {
                        key: t
                    }, [jr(r, null, {
                        default: En( () => [e.href ? (Tr(),
                        Ir(n, {
                            key: 0,
                            href: e.href
                        }, {
                            default: En( () => [Vr(ne(e.text), 1)]),
                            _: 2
                        }, 1032, ["href"])) : (Tr(),
                        Ir(a, {
                            key: 1
                        }, {
                            default: En( () => [Vr(ne(e.text), 1)]),
                            _: 2
                        }, 1024))]),
                        _: 2
                    }, 1024), t < o.value.length - 1 ? (Tr(),
                    Ir(s, {
                        key: 0
                    })) : Ur("", !0)], 64))), 128))]),
                    _: 1
                })]),
                _: 1
            })])
        }
    }
})
  , vM = [{
    name: "Conta",
    icon: sm.Person,
    route: "/perfil/conta"
}, {
    name: "Histrico de Jogos",
    icon: sm.Joystick,
    route: "/perfil/historico"
}, {
    name: "Transaes",
    icon: sm.SolidReceipt,
    route: "/perfil/transacoes"
}, {
    name: "Entregas",
    icon: sm.Truck,
    route: "/perfil/entregas"
}, {
    name: "Segurana",
    icon: sm.LockShield,
    route: "/perfil/seguranca"
}]
  , mM = {
    class: "grid sm:grid-cols-4 sm:mt-10 gap-7 h-svh"
}
  , gM = {
    class: "flex items-center gap-4"
}
  , yM = {
    class: "flex flex-col"
}
  , bM = {
    class: "text-lg overflow-hidden text-nowrap text-ellipsis w-48 font-medium"
}
  , wM = {
    class: "text-sm text-muted-foreground"
}
  , _M = {
    key: 0,
    class: "col-span-3 relative"
}
  , xM = to({
    __name: "Account",
    setup(e) {
        const t = ms( () => "/perfil" === o.path)
          , n = QC()
          , o = Bk();
        return (e, a) => {
            const r = YA
              , s = KA
              , i = GA
              , l = jO
              , u = Qv
              , c = Fo("RouterLink")
              , d = hM
              , p = Fo("RouterView")
              , f = sM;
            return Tr(),
            Ir(f, null, {
                default: En( () => [Dr("section", mM, [Dr("div", {
                    class: K(["col-span-1 flex flex-col gap-7", t.value ? "" : "hidden sm:flex"])
                }, [jr(l, {
                    class: "px-4 py-4 gap-1 !w-full"
                }, {
                    default: En( () => {
                        var e, t;
                        return [Dr("div", gM, [jr(i, {
                            class: "size-12"
                        }, {
                            default: En( () => {
                                var e;
                                return [jr(r, {
                                    src: null == (e = Nt(n).user) ? void 0 : e.avatar,
                                    alt: "@"
                                }, null, 8, ["src"]), jr(s, null, {
                                    default: En( () => [jr(Nt(sm).Account, {
                                        class: "size-full"
                                    })]),
                                    _: 1
                                })]
                            }
                            ),
                            _: 1
                        }), Dr("div", yM, [Dr("span", bM, ne(null == (e = Nt(n).user) ? void 0 : e.name), 1), Dr("span", wM, "Entrou em " + ne(Nt(mC)(null == (t = Nt(n).user) ? void 0 : t.created_at)), 1)])])]
                    }
                    ),
                    _: 1
                }), jr(l, {
                    class: "gap-1 p-3"
                }, {
                    default: En( () => [(Tr(!0),
                    Br(_r, null, qo(Nt(vM), e => (Tr(),
                    Ir(c, {
                        key: e.name,
                        to: e.route,
                        class: "flex items-center w-full"
                    }, {
                        default: En( () => [jr(u, {
                            variant: Nt(o).path === e.route ? "default" : "ghost",
                            class: "w-full justify-start !px-1 !py-5 gap-2 cursor-pointer"
                        }, {
                            default: En( () => [(Tr(),
                            Ir(Vo(e.icon), {
                                class: "size-8 p-1.5 rounded-full select-none"
                            })), Vr(" " + ne(e.name), 1)]),
                            _: 2
                        }, 1032, ["variant"])]),
                        _: 2
                    }, 1032, ["to"]))), 128)), jr(u, {
                        onClick: () => {}
                        ,
                        variant: "ghost",
                        class: "w-full justify-start !px-1 !py-5 !text-rose-500 cursor-pointer"
                    }, {
                        default: En( () => [jr(Nt(sm).Logout, {
                            class: "size-8 p-1.5 rounded-full select-none hover:bg-white/10"
                        }), a[0] || (a[0] = Vr(" Sair "))]),
                        _: 1,
                        __: [0]
                    })]),
                    _: 1
                })], 2), t.value ? Ur("", !0) : (Tr(),
                Br("div", _M, [jr(d), jr(p, null, {
                    default: En( ({Component: e}) => [jr(zs, {
                        name: "fade",
                        mode: "out-in"
                    }, {
                        default: En( () => [(Tr(),
                        Ir(Vo(e)))]),
                        _: 2
                    }, 1024)]),
                    _: 1
                })]))])]),
                _: 1
            })
        }
    }
})
  , kM = {
    class: "flex gap-2 justify-between items-center"
}
  , SM = {
    class: "flex gap-1 items-center font-semibold"
}
  , CM = {
    class: "bg-surface rounded-md p-1.5 flex items-center gap-1 text-white text-xs"
}
  , EM = to({
    __name: "BuyButton",
    props: {
        value: {},
        currency: {}
    },
    setup: e => (e, t) => {
        const n = Qv;
        return Tr(),
        Ir(n, {
            class: "px-2.5 cursor-pointer",
            size: "lg"
        }, {
            default: En( () => [Dr("section", kM, [Dr("div", SM, [Wo(e.$slots, "default")]), Dr("div", CM, [t[0] || (t[0] = Dr("span", {
                class: "text-emerald-400"
            }, "R$", -1)), Vr(" " + ne(Nt(vC)(e.value)), 1)])])]),
            _: 3
        })
    }
})
  , TM = {
    class: "w-full aspect-[5/1] overflow-hidden"
}
  , AM = ["src", "alt"]
  , OM = {
    class: "flex flex-col sm:flex-row sm:justify-between sm:items-center mb-2.5"
}
  , MM = {
    class: "font-semibold"
}
  , PM = {
    class: "text-xs text-amber-400 font-medium opacity-90 uppercase"
}
  , BM = {
    class: "flex items-end sm:items-center justify-between"
}
  , IM = {
    class: "sm:pt-3 pb-0.5 sm:pb-0 flex items-center gap-1.5 text-tiny font-semibold cursor-pointer hover:text-emerald-400 active:text-emerald-400 active:scale-95 transition-all duration-200"
}
  , LM = to({
    __name: "ScratchAd",
    props: {
        name: {},
        amount: {},
        max_reward: {},
        slug: {},
        banner: {}
    },
    setup(e) {
        const t = `/raspadinha/${e.slug}`;
        return (e, n) => {
            const o = EM
              , a = Fo("RouterLink")
              , r = jO;
            return Tr(),
            Ir(r, {
                class: "p-4 shadow-sm gap-4 bg-gradient-to-t from-primary/6 from-[0%] to-[45%] to-transparent group border-b-2 hover:border-b-primary transition-all duration-400 select-none"
            }, {
                default: En( () => [Dr("div", TM, [Dr("img", {
                    src: e.banner,
                    alt: e.name,
                    class: "w-full h-full object-cover"
                }, null, 8, AM)]), Dr("div", OM, [Dr("h1", MM, ne(e.name), 1), Dr("h2", PM, " PRMIOS DE AT " + ne(Nt(hC)(e.max_reward)), 1)]), Dr("div", BM, [jr(a, {
                    to: t
                }, {
                    default: En( () => [jr(o, {
                        value: e.amount
                    }, {
                        default: En( () => [jr(Nt(sm).CoinVertical, {
                            class: "size-5"
                        }), n[0] || (n[0] = Dr("span", {
                            class: "font-semibold"
                        }, "Jogar", -1))]),
                        _: 1,
                        __: [0]
                    }, 8, ["value"])]),
                    _: 1
                }), Dr("div", IM, [jr(Nt(sm).Gift, {
                    class: "group-hover:animate-wiggle size-3 sm:size-4"
                }), n[1] || (n[1] = Dr("span", null, " VER PRMIOS ", -1)), jr(Nt(sm).Right, {
                    class: "size-3"
                })])])]),
                _: 1
            })
        }
    }
})
  , RM = {
    class: "relative my-4"
}
  , zM = {
    class: "search-box border focus-within:bg-white/2 rounded-lg flex items-center pl-5 pr-2 relative z-20"
}
  , NM = {
    key: 0,
    class: "search-box__error text-amber-300 block text-center"
}
  , DM = {
    key: 1,
    class: "search-box__skeleton grid gap-3 grid-cols-3 md:grid-cols-4 lg:grid-cols-6"
}
  , jM = {
    key: 2,
    id: "search-results",
    class: "search-box__results grid gap-3 grid-cols-3 md:grid-cols-4 lg:grid-cols-6"
}
  , FM = to({
    __name: "SearchBox",
    props: {
        modelValue: {
            default: ""
        },
        modelModifiers: {}
    },
    emits: ["update:modelValue"],
    setup(e) {
        const t = or(e, "modelValue")
          , n = It(!1)
          , o = It(!1)
          , a = It("")
          , r = It(null)
          , s = It([]);
        Qa(t, function() {
            n.value = t.value.length >= 1,
            t.value.length < 3 ? a.value = "Pesquisa mnima de 3 caracteres" : (o.value = !0,
            a.value = "",
            i())
        }),
        Qa( () => !0, () => {
            var e;
            null == (e = r.value) || e.focus()
        }
        );
        const i = function(e, t=300) {
            let n;
            return function(...o) {
                n && clearTimeout(n);
                const a = this;
                n = setTimeout( () => {
                    e.apply(a, o)
                }
                , t)
            }
        }( () => {
            o.value = !0,
            a.value = "",
            s.value = [],
            b_.get(`/casino/games?search=${t.value}`).then(e => {
                const t = e.data.data;
                s.value = t,
                0 === t.length && (a.value = "No encontramos resultados para sua busca")
            }
            ).catch(e => {
                a.value = "Ocorreu um problema ao fazer a pesquisa :("
            }
            ).finally( () => {
                o.value = !1
            }
            )
        }
        , 300);
        function l() {
            n.value = !1
        }
        return (e, i) => (Tr(),
        Br("div", RM, [Dr("div", zM, [(Tr(),
        Ir(Vo(o.value ? Nt(sm).Loading : Nt(sm).Search), {
            class: K(["icon size-5 opacity-70", {
                "animate-spin": o.value
            }])
        }, null, 8, ["class"])), Tn(Dr("input", {
            ref_key: "inputRef",
            ref: r,
            type: "text",
            "onUpdate:modelValue": i[0] || (i[0] = e => t.value = e),
            class: "search-box__input bg-transparent px-4 py-4 outline-none grow",
            placeholder: "Pesquise o sorteio...",
            autocomplete: "off",
            onFocus: i[1] || (i[1] = e => function() {
                var e;
                const o = document.querySelector("main")
                  , a = null == (e = document.querySelector("header")) ? void 0 : e.parentElement.getBoundingClientRect().height
                  , s = r.value.getBoundingClientRect().top + o.scrollTop - a - 20;
                o.scrollTo({
                    top: s,
                    behavior: "smooth"
                }),
                t.value.length > 0 && (n.value = !0)
            }())
        }, null, 544), [[Ni, t.value]]), t.value ? (Tr(),
        Ir(Vo(Nt(sm).Close), {
            key: 0,
            class: "size-6 p-1 cursor-pointer",
            onClick: i[2] || (i[2] = e => t.value = "")
        })) : Ur("", !0)]), n.value ? (Tr(),
        Br("span", {
            key: 0,
            class: "backdrop bg-black/50 fixed top-0 left-0 bottom-0 right-0 z-10",
            onClick: i[3] || (i[3] = e => n.value = !1)
        })) : Ur("", !0), n.value ? (Tr(),
        Br("div", {
            key: 1,
            class: "search-box__dropdown bg-surface rounded-md absolute top-[calc(100%+10px)] max-h-[calc(100vh-200px)] left-0 right-0 p-4 z-40 overflow-auto hide-scrollbar",
            onClick: l
        }, [a.value ? (Tr(),
        Br("span", NM, ne(a.value), 1)) : Ur("", !0), o.value ? (Tr(),
        Br("div", DM, [(Tr(),
        Br(_r, null, qo(6, e => Dr("span", {
            class: "bg-black/30 rounded-md aspect-[166/193] flex-[1_1_0px] animate-pulse",
            key: e
        })), 64))])) : Ur("", !0), !o.value && !a.value && s.value.length >= 1 ? (Tr(),
        Br("div", jM, " s ")) : Ur("", !0)])) : Ur("", !0)]))
    }
})
  , $M = {
    class: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
}
  , VM = to({
    __name: "AllScratch",
    setup(e) {
        const t = It(!1)
          , n = It(!1)
          , o = It([]);
        return Mo(async () => {
            await async function() {
                try {
                    t.value = !0,
                    n.value = !1;
                    const {data: e} = await b_.get("/scratch/list");
                    o.value = e.data
                } catch (e) {
                    n.value = !0
                } finally {
                    t.value = !1
                }
            }()
        }
        ),
        (e, t) => {
            const n = zO
              , a = FM
              , r = LM;
            return Tr(),
            Br("div", null, [jr(n, {
                class: "mb-6"
            }), jr(a), Dr("div", $M, [(Tr(!0),
            Br(_r, null, qo(o.value, e => (Tr(),
            Ir(r, Gr({
                key: e.slug
            }, {
                ref_for: !0
            }, e, {
                class: "group"
            }), null, 16))), 128))])])
        }
    }
})
  , HM = {
    class: "bg-secondary/80 rounded-full p-2"
}
  , UM = {
    class: "flex flex-col gap-1"
}
  , ZM = {
    class: "flex font-medium"
}
  , qM = {
    class: "text-sm opacity-70"
}
  , WM = to({
    __name: "ComissionWidget",
    props: {
        title: {},
        currency: {
            type: Boolean
        },
        value: {},
        icon: {}
    },
    setup: e => (e, t) => {
        const n = jO;
        return Tr(),
        Ir(n, {
            class: "!px-4 !py-4 !flex-row items-center !gap-4"
        }, {
            default: En( () => [Dr("div", HM, [(Tr(),
            Ir(Vo(e.icon), {
                class: "size-10 p-0.5"
            }))]), Dr("div", UM, [Dr("span", ZM, ne(e.currency ? Nt(hC)(e.value) : e.value), 1), Dr("span", qM, ne(e.title), 1)])]),
            _: 1
        })
    }
})
  , GM = to({
    __name: "Progress",
    props: {
        modelValue: {
            default: 0
        },
        max: {},
        getValueLabel: {},
        getValueText: {},
        asChild: {
            type: Boolean
        },
        as: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Lf(t, "class");
        return (e, o) => (Tr(),
        Ir(Nt(Bp), Gr({
            "data-slot": "progress"
        }, Nt(n), {
            class: Nt(hv)("bg-primary/20 relative h-2 w-full overflow-hidden rounded-full", t.class)
        }), {
            default: En( () => [jr(Nt(Ip), {
                "data-slot": "progress-indicator",
                class: "bg-primary h-full w-full flex-1 transition-all",
                style: U(`transform: translateX(-${100 - (t.modelValue ?? 0)}%);`)
            }, null, 8, ["style"])]),
            _: 1
        }, 16, ["class"]))
    }
})
  , KM = {
    class: "grid grid-cols-1 md:grid-cols-3 gap-6 w-full"
}
  , YM = {
    class: "flex flex-col gap-4 sm:col-span-1"
}
  , XM = {
    class: "flex gap-3 items-center mb-0"
}
  , JM = {
    class: "flex flex-col gap-2"
}
  , QM = {
    class: "flex flex-col md:col-span-2 gap-3"
}
  , eP = {
    class: "flex flex-col gap-2"
}
  , tP = {
    class: "text-2xl font-semibold"
}
  , nP = {
    key: 1,
    class: "flex flex-col"
}
  , oP = {
    class: "grid grid-cols-1 md:grid-cols-2 gap-4 mt-4"
}
  , aP = {
    class: "flex flex-col"
}
  , rP = {
    class: "flex"
}
  , sP = {
    class: "flex flex-col gap-2 w-full"
}
  , iP = {
    class: "flex justify-between items-center"
}
  , lP = {
    class: "flex flex-col gap-1"
}
  , uP = {
    class: "text-2xl font-semibold"
}
  , cP = {
    class: "flex justify-between items-center mt-2 border-t pt-3"
}
  , dP = to({
    __name: "Affiliate",
    setup(e) {
        var t;
        const n = dm()
          , o = QC()
          , a = It(!1)
          , r = window.location.host.replace("www.", "")
          , s = (null == (t = o.user) ? void 0 : t.affiliate_code) || ""
          , i = `https://${r}/r/${s}`
          , l = It(!1);
        const u = async () => {
            var e;
            l.value = !0;
            try {
                const {data: e} = await b_.post("/affiliate/withdraw");
                await new Promise(e => setTimeout(e, 1e3)),
                S_.success("Saldo convertido. Realize seu Saque!")
            } catch (t) {
                await new Promise(e => setTimeout(e, 1e3));
                let n = "Ocorreu um erro ao realizar o saque";
                if (t_.isAxiosError(t) && t.response) {
                    const o = t.response.data;
                    n = (o.errors ? null == (e = Object.values(o.errors)[0]) ? void 0 : e[0] : void 0) ?? o.message ?? n,
                    window.scrollTo({
                        top: 0,
                        behavior: "smooth"
                    })
                }
                S_.error(n)
            } finally {
                l.value = !1
            }
        }
          , c = It(!1)
          , d = It(!1)
          , p = It({
            inviteds: 0,
            withdraw_sum: 0,
            comission_sum: 0,
            lost_payments: 0
        });
        return Mo(async () => {
            await async function() {
                try {
                    c.value = !0,
                    d.value = !1;
                    const {data: e} = await b_.get("/affiliate")
                      , t = e.data ?? e;
                    p.value = {
                        inviteds: t.inviteds ?? 0,
                        withdraw_sum: t.withdraw_sum ?? 0,
                        comission_sum: t.comission_sum ?? 0,
                        lost_payments: t.lost_payments ?? 0
                    }
                } catch (e) {
                    d.value = !0
                } finally {
                    c.value = !1
                }
            }()
        }
        ),
        (e, t) => {
            const r = YA
              , c = KA
              , d = GA
              , f = GM
              , h = Qv
              , v = jO
              , m = WM
              , g = sM;
            return Tr(),
            Ir(g, null, {
                default: En( () => {
                    var e, g;
                    return [Dr("section", KM, [Dr("div", YM, [jr(v, {
                        class: "w-full !p-7 gap-3"
                    }, {
                        default: En( () => {
                            var e;
                            return [jr(d, {
                                class: "size-17 sm:size-14 self-center md:self-start"
                            }, {
                                default: En( () => {
                                    var e;
                                    return [jr(r, {
                                        src: null == (e = Nt(o).user) ? void 0 : e.avatar,
                                        alt: "@"
                                    }, null, 8, ["src"]), jr(c, null, {
                                        default: En( () => [jr(Nt(sm).Account, {
                                            class: "size-full"
                                        })]),
                                        _: 1
                                    })]
                                }
                                ),
                                _: 1
                            }), Dr("div", XM, [Dr("h1", null, ne(null == (e = Nt(o).user) ? void 0 : e.username), 1), t[2] || (t[2] = Dr("div", {
                                class: "flex items-center gap-2 py-1 px-1.5 rounded-sm border"
                            }, [Dr("img", {
                                class: "size-5 sm:size-6 object-contain",
                                src: "/assets/level_1-BnAWvPcq.png",
                                alt: "level"
                            }), Dr("span", {
                                class: "text-sm text-blue-300 font-medium"
                            }, "Nvel 1")], -1))]), t[4] || (t[4] = Dr("div", {
                                class: "py-0.5 px-1.5 bg-secondary border rounded-sm w-fit text-sm mb-1"
                            }, [Dr("span", {
                                class: "opacity-70"
                            }, "Comisso 0.5%")], -1)), Dr("div", JM, [jr(f, {
                                "model-value": 0
                            })]), t[5] || (t[5] = Dr("div", {
                                class: "flex justify-between items-center mb-3"
                            }, [Dr("span", {
                                class: "text-sm opacity-60"
                            }, "0 / 1.000 XP"), Dr("span", {
                                class: "text-sm opacity-60"
                            }, "Nvel 1")], -1)), jr(h, null, {
                                default: En( () => t[3] || (t[3] = [Vr("Ver nveis")])),
                                _: 1,
                                __: [3]
                            })]
                        }
                        ),
                        _: 1,
                        __: [4, 5]
                    })]), Dr("div", QM, [(null == (e = Nt(o).user) ? void 0 : e.affiliate_code) ? (Tr(),
                    Ir(v, {
                        key: 0,
                        class: "!flex-row w-full !justify-between !p-6 !items-center"
                    }, {
                        default: En( () => {
                            var e;
                            return [Dr("div", eP, [t[7] || (t[7] = Dr("span", {
                                class: "opacity-60"
                            }, "Fundos Disponveis", -1)), Dr("div", tP, [t[6] || (t[6] = Dr("span", {
                                class: "text-primary"
                            }, "R$", -1)), Vr(" " + ne(Nt(vC)((null == (e = Nt(o).wallet) ? void 0 : e.comission) ?? 0)), 1)])]), jr(h, {
                                class: "transition-all duration-500 ease-in-out",
                                size: "lg",
                                disabled: l.value,
                                onClick: u
                            }, {
                                default: En( () => [l.value ? (Tr(),
                                Ir(Nt(sm).Loading, {
                                    key: 0,
                                    class: "animate-spin inline-block"
                                })) : (Tr(),
                                Br(_r, {
                                    key: 1
                                }, [Vr("Reivindicar")], 64))]),
                                _: 1
                            }, 8, ["disabled"])]
                        }
                        ),
                        _: 1
                    })) : Ur("", !0), (null == (g = Nt(o).user) ? void 0 : g.affiliate_code) ? (Tr(),
                    Br("div", nP, [t[8] || (t[8] = Dr("div", {
                        class: "flex justify-between items-center font-semibold"
                    }, [Dr("h1", null, "Resumo")], -1)), Dr("div", oP, [jr(m, {
                        title: "Cadastros",
                        value: p.value.inviteds ?? 0,
                        icon: Nt(sm).UserGroup
                    }, null, 8, ["value", "icon"]), jr(m, {
                        title: "Depsitos Pendentes",
                        value: p.value.lost_payments ?? 0,
                        icon: Nt(sm).UserMoney
                    }, null, 8, ["value", "icon"]), jr(m, {
                        title: "Total retirado",
                        icon: Nt(sm).MoneyBag ?? 0,
                        value: p.value.withdraw_sum,
                        currency: ""
                    }, null, 8, ["icon", "value"]), jr(m, {
                        title: "Total Ganho",
                        currency: "",
                        value: p.value.comission_sum ?? 0,
                        icon: Nt(sm).Coin
                    }, null, 8, ["value", "icon"])])])) : Ur("", !0), Dr("div", aP, [t[11] || (t[11] = Dr("h1", {
                        class: "mb-2"
                    }, "Link de referncia", -1)), Dr("div", rP, [jr(v, {
                        class: "!flex-row w-full !justify-between !p-6 !items-center"
                    }, {
                        default: En( () => {
                            var e;
                            return [Dr("div", sP, [Dr("div", iP, [Dr("div", lP, [t[9] || (t[9] = Dr("span", {
                                class: "opacity-60"
                            }, "Seu Cdigo", -1)), Dr("div", uP, [Dr("span", {
                                class: K(Nt(s) ? "text-primary" : "opacity-60")
                            }, " r/", 2), Vr(ne(Nt(s)), 1)])]), (null == (e = Nt(o).user) ? void 0 : e.affiliate_code) ? Ur("", !0) : (Tr(),
                            Ir(h, {
                                key: 0,
                                class: "cursor-pointer",
                                onClick: t[0] || (t[0] = e => Nt(n).open("code")),
                                size: "lg"
                            }, {
                                default: En( () => t[10] || (t[10] = [Vr("Criar Cdigo")])),
                                _: 1,
                                __: [10]
                            }))]), Dr("div", cP, [Dr("span", {
                                class: "text-sm opacity-60"
                            }, ne(i)), jr(h, {
                                class: "cursor-pointer",
                                variant: "icon",
                                size: "sm",
                                onClick: t[1] || (t[1] = e => (SE(i),
                                a.value = !0,
                                void setTimeout( () => {
                                    a.value = !1
                                }
                                , 2500)))
                            }, {
                                default: En( () => [a.value ? (Tr(),
                                Ir(Nt(sm).Check, {
                                    key: 1,
                                    class: "size-5.5 text-card-foreground"
                                })) : (Tr(),
                                Ir(Nt(sm).Share, {
                                    key: 0,
                                    class: "size-5.5 text-card-foreground"
                                }))]),
                                _: 1
                            })])])]
                        }
                        ),
                        _: 1
                    })])])])])]
                }
                ),
                _: 1
            })
        }
    }
})
  , pP = {
    class: "flex flex-col border-2 border-surface p-3 rounded-lg bg-gradient-to-t from-primary/17 from-[0%] to-[35%] to-secondary cursor-pointer aspect-square"
}
  , fP = ["src", "alt"]
  , hP = {
    class: "text-sm font-semibold mb-3 overflow-hidden text-ellipsis text-nowrap w-30"
}
  , vP = {
    class: "px-1.5 py-1 bg-white text-background rounded-sm text-sm font-semibold self-start"
}
  , mP = to({
    __name: "RewardItem",
    props: {
        name: {},
        amount: {},
        image: {},
        type: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("div", pP, [Dr("img", {
            src: t.image,
            class: "size-full p-3 object-contain",
            alt: t.name
        }, null, 8, fP), Dr("h3", hP, ne(t.name), 1), Dr("div", vP, ne(Nt(hC)(t.amount)), 1)]))
    }
})
  , gP = {
    class: "flex overflow-x-auto gap-2 pb-2 xl:grid xl:grid-cols-8 xl:overflow-x-visible"
}
  , yP = to({
    __name: "ScratchRewards",
    props: {
        items: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => {
            const o = mP;
            return Tr(),
            Br(_r, null, [n[0] || (n[0] = Dr("h2", {
                class: "text-xl font-semibold mb-6"
            }, "Prmios da Raspadinha:", -1)), Dr("div", gP, [(Tr(!0),
            Br(_r, null, qo(t.items, e => (Tr(),
            Br("div", {
                key: e.name,
                class: "flex-shrink-0 w-38 xl:w-auto"
            }, [jr(o, Gr({
                ref_for: !0
            }, e), null, 16)]))), 128))])], 64)
        }
    }
})
  , bP = to({
    __name: "AlertDescription",
    props: {
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("div", {
            "data-slot": "alert-description",
            class: K(Nt(hv)("text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed", t.class))
        }, [Wo(e.$slots, "default")], 2))
    }
})
  , wP = to({
    __name: "AlertTitle",
    props: {
        class: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("div", {
            "data-slot": "alert-title",
            class: K(Nt(hv)("col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight", t.class))
        }, [Wo(e.$slots, "default")], 2))
    }
})
  , _P = Xv("relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current", {
    variants: {
        variant: {
            default: "bg-card text-card-foreground",
            destructive: "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90"
        }
    },
    defaultVariants: {
        variant: "default"
    }
})
  , xP = to({
    __name: "Alert",
    props: {
        class: {},
        variant: {}
    },
    setup(e) {
        const t = e;
        return (e, n) => (Tr(),
        Br("div", {
            "data-slot": "alert",
            class: K(Nt(hv)(Nt(_P)({
                variant: e.variant
            }), t.class)),
            role: "alert"
        }, [Wo(e.$slots, "default")], 2))
    }
})
  , kP = {
    class: "w-full aspect-[5/1] overflow-hidden"
}
  , SP = ["src"]
  , CP = to({
    __name: "ScratchBanner",
    props: {
        image: {}
    },
    setup: e => (e, t) => (Tr(),
    Br("div", kP, [Dr("img", {
        src: e.image,
        alt: "",
        class: "w-full h-full object-cover border rounded-lg"
    }, null, 8, SP)]))
})
  , EP = {
    class: "flex flex-1 flex-col gap-4"
}
  , TP = {
    class: "flex text-2xl font-medium items-center"
}
  , AP = {
    class: "pointer-events-none inline-flex h-5 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium text-muted-foreground opacity-100"
}
  , OP = {
    class: "text-xs"
}
  , MP = to({
    __name: "ScratchInfo",
    props: {
        name: {},
        amount: {},
        max_reward: {},
        slug: {},
        banner: {}
    },
    setup(e) {
        const t = It(!1)
          , n = function(e={}) {
            const {reactive: t=!1, target: n=Ff, aliasMap: o=Zf, passive: a=!0, onEventFired: r=Nf} = e
              , s = bt(new Set)
              , i = {
                toJSON: () => ({}),
                current: s
            }
              , l = t ? bt(i) : i
              , u = new Set
              , c = new Set
              , d = new Set;
            function p(e, n) {
                e in l && (t ? l[e] = n : l[e].value = n)
            }
            function f() {
                s.clear();
                for (const e of d)
                    p(e, !1)
            }
            function h(e, t) {
                var n, o;
                const a = null == (n = e.key) ? void 0 : n.toLowerCase()
                  , r = [null == (o = e.code) ? void 0 : o.toLowerCase(), a].filter(Boolean);
                a && (t ? s.add(a) : s.delete(a));
                for (const s of r)
                    d.add(s),
                    p(s, t);
                "shift" !== a || t ? "function" == typeof e.getModifierState && e.getModifierState("Shift") && t && [...s, ...r].forEach(e => c.add(e)) : (c.forEach(e => {
                    s.delete(e),
                    p(e, !1)
                }
                ),
                c.clear()),
                "meta" !== a || t ? "function" == typeof e.getModifierState && e.getModifierState("Meta") && t && [...s, ...r].forEach(e => u.add(e)) : (u.forEach(e => {
                    s.delete(e),
                    p(e, !1)
                }
                ),
                u.clear())
            }
            $f(n, "keydown", e => (h(e, !0),
            r(e)), {
                passive: a
            }),
            $f(n, "keyup", e => (h(e, !1),
            r(e)), {
                passive: a
            }),
            $f("blur", f, {
                passive: a
            }),
            $f("focus", f, {
                passive: a
            });
            const v = new Proxy(l,{
                get(e, n, a) {
                    if ("string" != typeof n)
                        return Reflect.get(e, n, a);
                    if ((n = n.toLowerCase())in o && (n = o[n]),
                    !(n in l))
                        if (/[+_-]/.test(n)) {
                            const e = n.split(/[+_-]/g).map(e => e.trim());
                            l[n] = ms( () => e.map(e => Dt(v[e])).every(Boolean))
                        } else
                            l[n] = Lt(!1);
                    const r = Reflect.get(e, n, a);
                    return t ? Dt(r) : r
                }
            });
            return v
        }();
        Qa(n["Mod+J"], e => e && (t.value = !t.value));
        const o = ms( () => /Mac|iP(hone|ad|od)/i.test(navigator.userAgent))
          , a = [{
            key: "R",
            description: "para comprar.",
            icon: ah,
            action: () => {}
        }, {
            key: "B",
            description: "para revelar.",
            icon: ah,
            action: () => {}
        }, {
            key: "B",
            description: "para revelar rpido.",
            icon: ah,
            action: () => {}
        }];
        return (e, t) => {
            const n = CP
              , r = jO
              , s = wP
              , i = bP
              , l = xP;
            return Tr(),
            Br("section", EP, [jr(n, {
                image: e.banner,
                class: "hidden sm:block"
            }, null, 8, ["image"]), jr(r, {
                class: "p-4 flex-1"
            }, {
                default: En( () => [Dr("span", TP, [jr(Nt(sm).Ticket, {
                    class: "inline size-6 mr-2"
                }), Vr(" " + ne(e.name), 1)]), (Tr(),
                Br(_r, null, qo(a, e => Dr("p", {
                    class: "text-sm text-muted-foreground",
                    key: e.key
                }, [t[0] || (t[0] = Vr(" Pressione ")), Dr("kbd", AP, [Dr("span", OP, ne(o.value ? "" : "Ctrl"), 1), Vr(ne(e.key), 1)]), Vr(" " + ne(e.description), 1)])), 64))]),
                _: 1
            }), jr(l, null, {
                default: En( () => [jr(Nt(ah), {
                    class: "!size-4"
                }), jr(s, {
                    class: "text-primary"
                }, {
                    default: En( () => t[1] || (t[1] = [Vr("Rena 3 imagens iguais e conquiste seu prmio!")])),
                    _: 1,
                    __: [1]
                }), jr(i, {
                    class: "text-sm opacity-90 sm:text-base"
                }, {
                    default: En( () => t[2] || (t[2] = [Vr(" O valor correspondente ser creditado automaticamente na sua conta. "), Dr("br", null, null, -1), Vr(" Se preferir receber o produto fsico, basta entrar em contato com o nosso suporte. ")])),
                    _: 1,
                    __: [2]
                })]),
                _: 1
            })])
        }
    }
})
  , PP = to({
    __name: "AutoSpin",
    setup: e => (e, t) => {
        const n = Qv
          , o = WA
          , a = qA
          , r = ZA;
        return Tr(),
        Ir(r, null, {
            default: En( () => [jr(o, {
                "as-child": ""
            }, {
                default: En( () => [jr(n, {
                    class: "sm:w-auto sm:flex-1 min-w-0 hover:brightness-125",
                    variant: "secondary",
                    size: "lg"
                }, {
                    default: En( () => [jr(Nt(sm).RoundArrow, {
                        class: "size-5"
                    }), t[0] || (t[0] = Dr("div", {
                        class: "font-semibold"
                    }, [Dr("span", {
                        class: "hidden sm:block"
                    }, "Rodada Automtica"), Dr("span", {
                        class: "block sm:hidden"
                    }, "Auto")], -1))]),
                    _: 1,
                    __: [0]
                })]),
                _: 1
            }), jr(a, {
                class: "w-fit min-w-[260px] max-w-[360px] px-3 pb-3 break-words",
                sideOffset: 9,
                collisionPadding: 20
            }, {
                default: En( () => t[1] || (t[1] = [Dr("span", {
                    class: "text-sm font-semibold"
                }, "Em breve...", -1)])),
                _: 1,
                __: [1]
            })]),
            _: 1
        })
    }
})
  , BP = to({
    __name: "ToggleButton",
    props: {
        modelValue: {
            type: Boolean
        }
    },
    emits: ["update:modelValue"],
    setup(e, {emit: t}) {
        const n = e
          , o = t;
        function a() {
            o("update:modelValue", !n.modelValue)
        }
        return (e, t) => {
            const n = Qv;
            return Tr(),
            Ir(n, {
                variant: e.modelValue ? "default" : "secondary",
                size: "lg",
                class: "px-1.5 border border-surface hover:brightness-125 transition-all duration-500 cursor-pointer",
                onClick: a
            }, {
                default: En( () => [Wo(e.$slots, "default")]),
                _: 3
            }, 8, ["variant"])
        }
    }
})
  , IP = Xv("inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden", {
    variants: {
        variant: {
            default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
            secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
            destructive: "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
            outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground"
        }
    },
    defaultVariants: {
        variant: "default"
    }
})
  , LP = to({
    __name: "Badge",
    props: {
        asChild: {
            type: Boolean
        },
        as: {},
        variant: {},
        class: {}
    },
    setup(e) {
        const t = e
          , n = Lf(t, "class");
        return (e, o) => (Tr(),
        Ir(Nt(yc), Gr({
            "data-slot": "badge",
            class: Nt(hv)(Nt(IP)({
                variant: e.variant
            }), t.class)
        }, Nt(n)), {
            default: En( () => [Wo(e.$slots, "default")]),
            _: 3
        }, 16, ["class"]))
    }
});
var RP = {};
!function e(t, n, o, a) {
    var r = !!(t.Worker && t.Blob && t.Promise && t.OffscreenCanvas && t.OffscreenCanvasRenderingContext2D && t.HTMLCanvasElement && t.HTMLCanvasElement.prototype.transferControlToOffscreen && t.URL && t.URL.createObjectURL)
      , s = "function" == typeof Path2D && "function" == typeof DOMMatrix;
    function i() {}
    function l(e) {
        var o = n.exports.Promise
          , a = void 0 !== o ? o : t.Promise;
        return "function" == typeof a ? new a(e) : (e(i, i),
        null)
    }
    var u, c, d, p, f, h, v = function(e, t) {
        return {
            transform: function(n) {
                if (e)
                    return n;
                if (t.has(n))
                    return t.get(n);
                var o = new OffscreenCanvas(n.width,n.height);
                return o.getContext("2d").drawImage(n, 0, 0),
                t.set(n, o),
                o
            },
            clear: function() {
                t.clear()
            }
        }
    }(function() {
        if (!t.OffscreenCanvas)
            return !1;
        var e = new OffscreenCanvas(1,1)
          , n = e.getContext("2d");
        n.fillRect(0, 0, 1, 1);
        var o = e.transferToImageBitmap();
        try {
            n.createPattern(o, "no-repeat")
        } catch (pC) {
            return !1
        }
        return !0
    }(), new Map), m = (d = Math.floor(1e3 / 60),
    p = {},
    f = 0,
    "function" == typeof requestAnimationFrame && "function" == typeof cancelAnimationFrame ? (u = function(e) {
        var t = Math.random();
        return p[t] = requestAnimationFrame(function n(o) {
            f === o || f + d - 1 < o ? (f = o,
            delete p[t],
            e()) : p[t] = requestAnimationFrame(n)
        }),
        t
    }
    ,
    c = function(e) {
        p[e] && cancelAnimationFrame(p[e])
    }
    ) : (u = function(e) {
        return setTimeout(e, d)
    }
    ,
    c = function(e) {
        return clearTimeout(e)
    }
    ),
    {
        frame: u,
        cancel: c
    }), g = function() {
        var t, n, a = {};
        return function() {
            if (t)
                return t;
            if (!o && r) {
                var s = ["var CONFETTI, SIZE = {}, module = {};", "(" + e.toString() + ")(this, module, true, SIZE);", "onmessage = function(msg) {", "  if (msg.data.options) {", "    CONFETTI(msg.data.options).then(function () {", "      if (msg.data.callback) {", "        postMessage({ callback: msg.data.callback });", "      }", "    });", "  } else if (msg.data.reset) {", "    CONFETTI && CONFETTI.reset();", "  } else if (msg.data.resize) {", "    SIZE.width = msg.data.resize.width;", "    SIZE.height = msg.data.resize.height;", "  } else if (msg.data.canvas) {", "    SIZE.width = msg.data.canvas.width;", "    SIZE.height = msg.data.canvas.height;", "    CONFETTI = module.exports.create(msg.data.canvas);", "  }", "}"].join("\n");
                try {
                    t = new Worker(URL.createObjectURL(new Blob([s])))
                } catch (pC) {
                    return void 0 !== typeof console && console.warn,
                    null
                }
                !function(e) {
                    function t(t, n) {
                        e.postMessage({
                            options: t || {},
                            callback: n
                        })
                    }
                    e.init = function(t) {
                        var n = t.transferControlToOffscreen();
                        e.postMessage({
                            canvas: n
                        }, [n])
                    }
                    ,
                    e.fire = function(o, r, s) {
                        if (n)
                            return t(o, null),
                            n;
                        var i = Math.random().toString(36).slice(2);
                        return n = l(function(r) {
                            function l(t) {
                                t.data.callback === i && (delete a[i],
                                e.removeEventListener("message", l),
                                n = null,
                                v.clear(),
                                s(),
                                r())
                            }
                            e.addEventListener("message", l),
                            t(o, i),
                            a[i] = l.bind(null, {
                                data: {
                                    callback: i
                                }
                            })
                        })
                    }
                    ,
                    e.reset = function() {
                        for (var t in e.postMessage({
                            reset: !0
                        }),
                        a)
                            a[t](),
                            delete a[t]
                    }
                }(t)
            }
            return t
        }
    }(), y = {
        particleCount: 50,
        angle: 90,
        spread: 45,
        startVelocity: 45,
        decay: .9,
        gravity: 1,
        drift: 0,
        ticks: 200,
        x: .5,
        y: .5,
        shapes: ["square", "circle"],
        zIndex: 100,
        colors: ["#26ccff", "#a25afd", "#ff5e7e", "#88ff5a", "#fcff42", "#ffa62d", "#ff36ff"],
        disableForReducedMotion: !1,
        scalar: 1
    };
    function b(e, t, n) {
        return function(e, t) {
            return t ? t(e) : e
        }(e && null != e[t] ? e[t] : y[t], n)
    }
    function w(e) {
        return e < 0 ? 0 : Math.floor(e)
    }
    function _(e, t) {
        return Math.floor(Math.random() * (t - e)) + e
    }
    function x(e) {
        return parseInt(e, 16)
    }
    function k(e) {
        return e.map(S)
    }
    function S(e) {
        var t = String(e).replace(/[^0-9a-f]/gi, "");
        return t.length < 6 && (t = t[0] + t[0] + t[1] + t[1] + t[2] + t[2]),
        {
            r: x(t.substring(0, 2)),
            g: x(t.substring(2, 4)),
            b: x(t.substring(4, 6))
        }
    }
    function C(e) {
        e.width = document.documentElement.clientWidth,
        e.height = document.documentElement.clientHeight
    }
    function E(e) {
        var t = e.getBoundingClientRect();
        e.width = t.width,
        e.height = t.height
    }
    function T(e) {
        var t = e.angle * (Math.PI / 180)
          , n = e.spread * (Math.PI / 180);
        return {
            x: e.x,
            y: e.y,
            wobble: 10 * Math.random(),
            wobbleSpeed: Math.min(.11, .1 * Math.random() + .05),
            velocity: .5 * e.startVelocity + Math.random() * e.startVelocity,
            angle2D: -t + (.5 * n - Math.random() * n),
            tiltAngle: (.5 * Math.random() + .25) * Math.PI,
            color: e.color,
            shape: e.shape,
            tick: 0,
            totalTicks: e.ticks,
            decay: e.decay,
            drift: e.drift,
            random: Math.random() + 2,
            tiltSin: 0,
            tiltCos: 0,
            wobbleX: 0,
            wobbleY: 0,
            gravity: 3 * e.gravity,
            ovalScalar: .6,
            scalar: e.scalar,
            flat: e.flat
        }
    }
    function A(e, t) {
        t.x += Math.cos(t.angle2D) * t.velocity + t.drift,
        t.y += Math.sin(t.angle2D) * t.velocity + t.gravity,
        t.velocity *= t.decay,
        t.flat ? (t.wobble = 0,
        t.wobbleX = t.x + 10 * t.scalar,
        t.wobbleY = t.y + 10 * t.scalar,
        t.tiltSin = 0,
        t.tiltCos = 0,
        t.random = 1) : (t.wobble += t.wobbleSpeed,
        t.wobbleX = t.x + 10 * t.scalar * Math.cos(t.wobble),
        t.wobbleY = t.y + 10 * t.scalar * Math.sin(t.wobble),
        t.tiltAngle += .1,
        t.tiltSin = Math.sin(t.tiltAngle),
        t.tiltCos = Math.cos(t.tiltAngle),
        t.random = Math.random() + 2);
        var n = t.tick++ / t.totalTicks
          , o = t.x + t.random * t.tiltCos
          , a = t.y + t.random * t.tiltSin
          , r = t.wobbleX + t.random * t.tiltCos
          , i = t.wobbleY + t.random * t.tiltSin;
        if (e.fillStyle = "rgba(" + t.color.r + ", " + t.color.g + ", " + t.color.b + ", " + (1 - n) + ")",
        e.beginPath(),
        s && "path" === t.shape.type && "string" == typeof t.shape.path && Array.isArray(t.shape.matrix))
            e.fill(function(e, t, n, o, a, r, s) {
                var i = new Path2D(e)
                  , l = new Path2D;
                l.addPath(i, new DOMMatrix(t));
                var u = new Path2D;
                return u.addPath(l, new DOMMatrix([Math.cos(s) * a, Math.sin(s) * a, -Math.sin(s) * r, Math.cos(s) * r, n, o])),
                u
            }(t.shape.path, t.shape.matrix, t.x, t.y, .1 * Math.abs(r - o), .1 * Math.abs(i - a), Math.PI / 10 * t.wobble));
        else if ("bitmap" === t.shape.type) {
            var l = Math.PI / 10 * t.wobble
              , u = .1 * Math.abs(r - o)
              , c = .1 * Math.abs(i - a)
              , d = t.shape.bitmap.width * t.scalar
              , p = t.shape.bitmap.height * t.scalar
              , f = new DOMMatrix([Math.cos(l) * u, Math.sin(l) * u, -Math.sin(l) * c, Math.cos(l) * c, t.x, t.y]);
            f.multiplySelf(new DOMMatrix(t.shape.matrix));
            var h = e.createPattern(v.transform(t.shape.bitmap), "no-repeat");
            h.setTransform(f),
            e.globalAlpha = 1 - n,
            e.fillStyle = h,
            e.fillRect(t.x - d / 2, t.y - p / 2, d, p),
            e.globalAlpha = 1
        } else if ("circle" === t.shape)
            e.ellipse ? e.ellipse(t.x, t.y, Math.abs(r - o) * t.ovalScalar, Math.abs(i - a) * t.ovalScalar, Math.PI / 10 * t.wobble, 0, 2 * Math.PI) : function(e, t, n, o, a, r, s, i, l) {
                e.save(),
                e.translate(t, n),
                e.rotate(r),
                e.scale(o, a),
                e.arc(0, 0, 1, s, i, l),
                e.restore()
            }(e, t.x, t.y, Math.abs(r - o) * t.ovalScalar, Math.abs(i - a) * t.ovalScalar, Math.PI / 10 * t.wobble, 0, 2 * Math.PI);
        else if ("star" === t.shape)
            for (var m = Math.PI / 2 * 3, g = 4 * t.scalar, y = 8 * t.scalar, b = t.x, w = t.y, _ = 5, x = Math.PI / _; _--; )
                b = t.x + Math.cos(m) * y,
                w = t.y + Math.sin(m) * y,
                e.lineTo(b, w),
                m += x,
                b = t.x + Math.cos(m) * g,
                w = t.y + Math.sin(m) * g,
                e.lineTo(b, w),
                m += x;
        else
            e.moveTo(Math.floor(t.x), Math.floor(t.y)),
            e.lineTo(Math.floor(t.wobbleX), Math.floor(a)),
            e.lineTo(Math.floor(r), Math.floor(i)),
            e.lineTo(Math.floor(o), Math.floor(t.wobbleY));
        return e.closePath(),
        e.fill(),
        t.tick < t.totalTicks
    }
    function O(e, n) {
        var s, i = !e, u = !!b(n || {}, "resize"), c = !1, d = b(n, "disableForReducedMotion", Boolean), p = r && !!b(n || {}, "useWorker") ? g() : null, f = i ? C : E, h = !(!e || !p) && !!e.__confetti_initialized, y = "function" == typeof matchMedia && matchMedia("(prefers-reduced-motion)").matches;
        function x(t, n, r) {
            for (var i = b(t, "particleCount", w), u = b(t, "angle", Number), c = b(t, "spread", Number), d = b(t, "startVelocity", Number), p = b(t, "decay", Number), h = b(t, "gravity", Number), g = b(t, "drift", Number), y = b(t, "colors", k), x = b(t, "ticks", Number), S = b(t, "shapes"), C = b(t, "scalar"), E = !!b(t, "flat"), O = function(e) {
                var t = b(e, "origin", Object);
                return t.x = b(t, "x", Number),
                t.y = b(t, "y", Number),
                t
            }(t), M = i, P = [], B = e.width * O.x, I = e.height * O.y; M--; )
                P.push(T({
                    x: B,
                    y: I,
                    angle: u,
                    spread: c,
                    startVelocity: d,
                    color: y[M % y.length],
                    shape: S[_(0, S.length)],
                    ticks: x,
                    decay: p,
                    gravity: h,
                    drift: g,
                    scalar: C,
                    flat: E
                }));
            return s ? s.addFettis(P) : (s = function(e, t, n, r, s) {
                var i, u, c = t.slice(), d = e.getContext("2d"), p = l(function(t) {
                    function l() {
                        i = u = null,
                        d.clearRect(0, 0, r.width, r.height),
                        v.clear(),
                        s(),
                        t()
                    }
                    i = m.frame(function t() {
                        !o || r.width === a.width && r.height === a.height || (r.width = e.width = a.width,
                        r.height = e.height = a.height),
                        r.width || r.height || (n(e),
                        r.width = e.width,
                        r.height = e.height),
                        d.clearRect(0, 0, r.width, r.height),
                        (c = c.filter(function(e) {
                            return A(d, e)
                        })).length ? i = m.frame(t) : l()
                    }),
                    u = l
                });
                return {
                    addFettis: function(e) {
                        return c = c.concat(e),
                        p
                    },
                    canvas: e,
                    promise: p,
                    reset: function() {
                        i && m.cancel(i),
                        u && u()
                    }
                }
            }(e, P, f, n, r),
            s.promise)
        }
        function S(n) {
            var o = d || b(n, "disableForReducedMotion", Boolean)
              , a = b(n, "zIndex", Number);
            if (o && y)
                return l(function(e) {
                    e()
                });
            i && s ? e = s.canvas : i && !e && (e = function(e) {
                var t = document.createElement("canvas");
                return t.style.position = "fixed",
                t.style.top = "0px",
                t.style.left = "0px",
                t.style.pointerEvents = "none",
                t.style.zIndex = e,
                t
            }(a),
            document.body.appendChild(e)),
            u && !h && f(e);
            var r = {
                width: e.width,
                height: e.height
            };
            function v() {
                if (p) {
                    var t = {
                        getBoundingClientRect: function() {
                            if (!i)
                                return e.getBoundingClientRect()
                        }
                    };
                    return f(t),
                    void p.postMessage({
                        resize: {
                            width: t.width,
                            height: t.height
                        }
                    })
                }
                r.width = r.height = null
            }
            function m() {
                s = null,
                u && (c = !1,
                t.removeEventListener("resize", v)),
                i && e && (document.body.contains(e) && document.body.removeChild(e),
                e = null,
                h = !1)
            }
            return p && !h && p.init(e),
            h = !0,
            p && (e.__confetti_initialized = !0),
            u && !c && (c = !0,
            t.addEventListener("resize", v, !1)),
            p ? p.fire(n, r, m) : x(n, r, m)
        }
        return S.reset = function() {
            p && p.reset(),
            s && s.reset()
        }
        ,
        S
    }
    function M() {
        return h || (h = O(null, {
            useWorker: !0,
            resize: !0
        })),
        h
    }
    n.exports = function() {
        return M().apply(this, arguments)
    }
    ,
    n.exports.reset = function() {
        M().reset()
    }
    ,
    n.exports.create = O,
    n.exports.shapeFromPath = function(e) {
        if (!s)
            throw new Error("path confetti are not supported in this browser");
        var t, n;
        "string" == typeof e ? t = e : (t = e.path,
        n = e.matrix);
        var o = new Path2D(t)
          , a = document.createElement("canvas").getContext("2d");
        if (!n) {
            for (var r, i, l = 1e3, u = l, c = l, d = 0, p = 0, f = 0; f < l; f += 2)
                for (var h = 0; h < l; h += 2)
                    a.isPointInPath(o, f, h, "nonzero") && (u = Math.min(u, f),
                    c = Math.min(c, h),
                    d = Math.max(d, f),
                    p = Math.max(p, h));
            r = d - u,
            i = p - c;
            var v = Math.min(10 / r, 10 / i);
            n = [v, 0, 0, v, -Math.round(r / 2 + u) * v, -Math.round(i / 2 + c) * v]
        }
        return {
            type: "path",
            path: t,
            matrix: n
        }
    }
    ,
    n.exports.shapeFromText = function(e) {
        var t, n = 1, o = "#000000", a = '"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", "EmojiOne Color", "Android Emoji", "Twemoji Mozilla", "system emoji", sans-serif';
        "string" == typeof e ? t = e : (t = e.text,
        n = "scalar"in e ? e.scalar : n,
        a = "fontFamily"in e ? e.fontFamily : a,
        o = "color"in e ? e.color : o);
        var r = 10 * n
          , s = r + "px " + a
          , i = new OffscreenCanvas(r,r)
          , l = i.getContext("2d");
        l.font = s;
        var u = l.measureText(t)
          , c = Math.ceil(u.actualBoundingBoxRight + u.actualBoundingBoxLeft)
          , d = Math.ceil(u.actualBoundingBoxAscent + u.actualBoundingBoxDescent)
          , p = u.actualBoundingBoxLeft + 2
          , f = u.actualBoundingBoxAscent + 2;
        c += 4,
        d += 4,
        (l = (i = new OffscreenCanvas(c,d)).getContext("2d")).font = s,
        l.fillStyle = o,
        l.fillText(t, p, f);
        var h = 1 / n;
        return {
            type: "bitmap",
            bitmap: i.transferToImageBitmap(),
            matrix: [h, 0, 0, h, -c * h / 2, -d * h / 2]
        }
    }
}(function() {
    return "undefined" != typeof window ? window : "undefined" != typeof self ? self : this || {}
}(), RP, !1);
const zP = RP.exports;
RP.exports.create;
const NP = {
    class: "absolute inset-0 z-40 rounded-sm flex flex-col items-center justify-center bg-primary-foreground/80 gap-4"
}
  , DP = {
    key: 0,
    class: "flex flex-col items-center px-5 py-3 gap-3 bg-white/4 border border-white/10 rounded-lg backdrop-blur-sm"
}
  , jP = ["src"]
  , FP = {
    class: "font-medium"
}
  , $P = {
    class: "text-sm text-center font-semibold"
}
  , VP = {
    class: "flex gap-2"
}
  , HP = to({
    __name: "ScratchOverlay",
    props: {
        state: {},
        amount: {},
        prize: {}
    },
    emits: ["login", "buy", "retry"],
    setup(e, {emit: t}) {
        (new Image).src = "https://ik.imagekit.io/azx3nlpdu/Notas/100%20REAIS.png?updatedAt=1752047821876";
        const n = e
          , o = t
          , a = {
            locked: sm.Lock,
            unauthenticated: sm.UserPlus,
            buy: sm.CoinVertical,
            failure: sm.Sad
        }
          , r = ["Eita, bateu a sorte! Raspa outra e segue o baile!", "Ganhou, hein? Bora de mais uma antes que a sorte esfrie!", "Voc brilhou! Agora vai na sequncia da sorte!", "Voc foi premiado! Aproveite o embalo e tente outra!", "A sorte sorriu! Raspa de novo e v no que d!"]
          , s = ["Voc chegou to perto! Raspe novamente e garanta seu prmio.", "A sorte est chamando: raspe de novo e descubra sua recompensa.", "No desista agora: mais uma raspadinha pode ser a vencedora!", "A emoo no para: raspe outra vez e surpreenda-se.", "Sua chance de ouro est aqui: raspe de novo e conquiste!", "O prmio espera por voc. Raspe outra vez e aproveite!", "Est quase l: mais uma raspadinha pode mudar tudo.", "No perca o momento: raspe de novo e sinta a emoo.", "Quase l! Tente outra raspadinha e fique mais perto do prmio.", "Uma nova chance te aguarda: raspe novamente e celebre!", "Na trave! Tenta de novo  a prxima pode ser a sua.", "No foi agora, mas a sorte gosta de quem insiste. Vai outra?"]
          , i = {
            locked: "Bloqueado no momento",
            unauthenticated: "Faa login pra jogar",
            buy: `Comprar por ${hC(n.amount ?? 0)}`,
            success: "",
            failure: "No foi dessa vez "
        }
          , l = ms( () => {
            if ("success" === n.state) {
                const e = Math.floor(Math.random() * r.length);
                return r[e]
            }
            if ("failure" === n.state) {
                const e = Math.floor(Math.random() * s.length);
                return s[e]
            }
            return i[n.state]
        }
        )
          , u = ms( () => "success" === n.state ? null : a[n.state])
          , c = It(null);
        let d = null;
        function p() {
            const e = Date.now() + 5e3
              , t = {
                startVelocity: 30,
                spread: 360,
                ticks: 60,
                zIndex: 0
            }
              , n = (e, t) => Math.random() * (t - e) + e
              , o = setInterval( () => {
                if (Date.now() > e)
                    return clearInterval(o);
                const a = (e - Date.now()) / 5e3 * 50;
                d({
                    ...t,
                    particleCount: a,
                    origin: {
                        x: n(.1, .3),
                        y: Math.random() - .2
                    }
                }),
                d({
                    ...t,
                    particleCount: a,
                    origin: {
                        x: n(.7, .9),
                        y: Math.random() - .2
                    }
                })
            }
            , 250)
        }
        return Mo( () => {
            const e = c.value;
            e && (e.removeAttribute("width"),
            e.removeAttribute("height"),
            e.style.width = "100%",
            e.style.height = "100%",
            d = zP.create(e, {
                resize: !0,
                useWorker: !1
            }),
            "success" === n.state && p())
        }
        ),
        Qa( () => n.state, e => "success" === e && d && p(), {
            immediate: !0
        }),
        (e, t) => {
            const a = LP
              , r = Qv
              , s = EM;
            return Tr(),
            Br("div", NP, [Dr("canvas", {
                ref_key: "confettiCanvas",
                ref: c,
                class: "absolute inset-0 pointer-events-none"
            }, null, 512), "success" === n.state && n.prize ? (Tr(),
            Br("div", DP, [Dr("img", {
                src: n.prize.image,
                alt: "prmio",
                class: "size-24 object-contain"
            }, null, 8, jP), jr(a, null, {
                default: En( () => [Vr(ne(n.prize.name), 1)]),
                _: 1
            }), Dr("p", FP, [t[3] || (t[3] = Dr("span", {
                class: "text-primary"
            }, "R$ ", -1)), Vr(ne(Nt(vC)(n.prize.amount)), 1)])])) : (Tr(),
            Ir(Vo(u.value), {
                key: 1,
                class: "size-24"
            })), Dr("p", $P, ne(l.value), 1), Dr("div", VP, ["unauthenticated" === n.state ? (Tr(),
            Ir(r, {
                key: 0,
                class: "cursor-pointer",
                onClick: t[0] || (t[0] = () => o("login"))
            }, {
                default: En( () => t[4] || (t[4] = [Vr("Registrar")])),
                _: 1,
                __: [4]
            })) : "locked" === n.state ? (Tr(),
            Ir(r, {
                key: 1,
                class: "cursor-pointer",
                disabled: ""
            }, {
                default: En( () => t[5] || (t[5] = [Vr("Indisponvel")])),
                _: 1,
                __: [5]
            })) : "buy" === n.state ? (Tr(),
            Ir(s, {
                key: 2,
                value: n.amount,
                onClick: t[1] || (t[1] = () => o("buy"))
            }, {
                default: En( () => t[6] || (t[6] = [Vr(" Comprar ")])),
                _: 1,
                __: [6]
            }, 8, ["value"])) : "success" === n.state || "failure" === n.state ? (Tr(),
            Ir(r, {
                key: 3,
                class: "cursor-pointer",
                onClick: t[2] || (t[2] = () => o("retry"))
            }, {
                default: En( () => [jr(Nt(sm).Joystick), t[7] || (t[7] = Vr("Jogar Novamente "))]),
                _: 1,
                __: [7]
            })) : Ur("", !0)])])
        }
    }
});
var UP, ZP = {
    exports: {}
};
var qP = (UP || (UP = 1,
window,
ZP.exports = function(e) {
    var t = {};
    function n(o) {
        if (t[o])
            return t[o].exports;
        var a = t[o] = {
            i: o,
            l: !1,
            exports: {}
        };
        return e[o].call(a.exports, a, a.exports, n),
        a.l = !0,
        a.exports
    }
    return n.m = e,
    n.c = t,
    n.d = function(e, t, o) {
        n.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: o
        })
    }
    ,
    n.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ,
    n.t = function(e, t) {
        if (1 & t && (e = n(e)),
        8 & t)
            return e;
        if (4 & t && "object" == typeof e && e && e.__esModule)
            return e;
        var o = Object.create(null);
        if (n.r(o),
        Object.defineProperty(o, "default", {
            enumerable: !0,
            value: e
        }),
        2 & t && "string" != typeof e)
            for (var a in e)
                n.d(o, a, function(t) {
                    return e[t]
                }
                .bind(null, a));
        return o
    }
    ,
    n.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return n.d(t, "a", t),
        t
    }
    ,
    n.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    n.p = "",
    n(n.s = 66)
}([function(e, t) {
    var n = e.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
    "number" == typeof __g && (__g = n)
}
, function(e, t, n) {
    var o = n(12)("wks")
      , a = n(13)
      , r = n(0).Symbol
      , s = "function" == typeof r;
    (e.exports = function(e) {
        return o[e] || (o[e] = s && r[e] || (s ? r : a)("Symbol." + e))
    }
    ).store = o
}
, function(e, t) {
    var n = e.exports = {
        version: "2.6.11"
    };
    "number" == typeof __e && (__e = n)
}
, function(e, t, n) {
    var o = n(4);
    e.exports = function(e) {
        if (!o(e))
            throw TypeError(e + " is not an object!");
        return e
    }
}
, function(e, t) {
    e.exports = function(e) {
        return "object" == typeof e ? null !== e : "function" == typeof e
    }
}
, function(e, t, n) {
    e.exports = !n(17)(function() {
        return 7 != Object.defineProperty({}, "a", {
            get: function() {
                return 7
            }
        }).a
    })
}
, function(e, t, n) {
    var o = n(7);
    e.exports = function(e, t, n) {
        if (o(e),
        void 0 === t)
            return e;
        switch (n) {
        case 1:
            return function(n) {
                return e.call(t, n)
            }
            ;
        case 2:
            return function(n, o) {
                return e.call(t, n, o)
            }
            ;
        case 3:
            return function(n, o, a) {
                return e.call(t, n, o, a)
            }
        }
        return function() {
            return e.apply(t, arguments)
        }
    }
}
, function(e, t) {
    e.exports = function(e) {
        if ("function" != typeof e)
            throw TypeError(e + " is not a function!");
        return e
    }
}
, function(e, t) {
    var n = {}.toString;
    e.exports = function(e) {
        return n.call(e).slice(8, -1)
    }
}
, function(e, t) {
    e.exports = function(e, t) {
        if (!(e instanceof t))
            throw new TypeError("Cannot call a class as a function")
    }
}
, function(e, t) {
    function n(e, t) {
        for (var n = 0; n < t.length; n++) {
            var o = t[n];
            o.enumerable = o.enumerable || !1,
            o.configurable = !0,
            "value"in o && (o.writable = !0),
            Object.defineProperty(e, o.key, o)
        }
    }
    e.exports = function(e, t, o) {
        return t && n(e.prototype, t),
        o && n(e, o),
        e
    }
}
, function(e, t, n) {
    var o = n(8)
      , a = n(1)("toStringTag")
      , r = "Arguments" == o(function() {
        return arguments
    }());
    e.exports = function(e) {
        var t, n, s;
        return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
            try {
                return e[t]
            } catch (n) {}
        }(t = Object(e), a)) ? n : r ? o(t) : "Object" == (s = o(t)) && "function" == typeof t.callee ? "Arguments" : s
    }
}
, function(e, t, n) {
    var o = n(2)
      , a = n(0)
      , r = a["__core-js_shared__"] || (a["__core-js_shared__"] = {});
    (e.exports = function(e, t) {
        return r[e] || (r[e] = void 0 !== t ? t : {})
    }
    )("versions", []).push({
        version: o.version,
        mode: n(22) ? "pure" : "global",
        copyright: " 2019 Denis Pushkarev (zloirock.ru)"
    })
}
, function(e, t) {
    var n = 0
      , o = Math.random();
    e.exports = function(e) {
        return "Symbol(".concat(void 0 === e ? "" : e, ")_", (++n + o).toString(36))
    }
}
, function(e, t, n) {
    var o = n(0)
      , a = n(2)
      , r = n(15)
      , s = n(18)
      , i = n(6)
      , l = function(e, t, n) {
        var u, c, d, p, f = e & l.F, h = e & l.G, v = e & l.S, m = e & l.P, g = e & l.B, y = h ? o : v ? o[t] || (o[t] = {}) : (o[t] || {}).prototype, b = h ? a : a[t] || (a[t] = {}), w = b.prototype || (b.prototype = {});
        for (u in h && (n = t),
        n)
            d = ((c = !f && y && void 0 !== y[u]) ? y : n)[u],
            p = g && c ? i(d, o) : m && "function" == typeof d ? i(Function.call, d) : d,
            y && s(y, u, d, e & l.U),
            b[u] != d && r(b, u, p),
            m && w[u] != d && (w[u] = d)
    };
    o.core = a,
    l.F = 1,
    l.G = 2,
    l.S = 4,
    l.P = 8,
    l.B = 16,
    l.W = 32,
    l.U = 64,
    l.R = 128,
    e.exports = l
}
, function(e, t, n) {
    var o = n(16)
      , a = n(36);
    e.exports = n(5) ? function(e, t, n) {
        return o.f(e, t, a(1, n))
    }
    : function(e, t, n) {
        return e[t] = n,
        e
    }
}
, function(e, t, n) {
    var o = n(3)
      , a = n(34)
      , r = n(35)
      , s = Object.defineProperty;
    t.f = n(5) ? Object.defineProperty : function(e, t, n) {
        if (o(e),
        t = r(t, !0),
        o(n),
        a)
            try {
                return s(e, t, n)
            } catch (i) {}
        if ("get"in n || "set"in n)
            throw TypeError("Accessors not supported!");
        return "value"in n && (e[t] = n.value),
        e
    }
}
, function(e, t) {
    e.exports = function(e) {
        try {
            return !!e()
        } catch (t) {
            return !0
        }
    }
}
, function(e, t, n) {
    var o = n(0)
      , a = n(15)
      , r = n(19)
      , s = n(13)("src")
      , i = n(37)
      , l = ("" + i).split("toString");
    n(2).inspectSource = function(e) {
        return i.call(e)
    }
    ,
    (e.exports = function(e, t, n, i) {
        var u = "function" == typeof n;
        u && (r(n, "name") || a(n, "name", t)),
        e[t] !== n && (u && (r(n, s) || a(n, s, e[t] ? "" + e[t] : l.join(String(t)))),
        e === o ? e[t] = n : i ? e[t] ? e[t] = n : a(e, t, n) : (delete e[t],
        a(e, t, n)))
    }
    )(Function.prototype, "toString", function() {
        return "function" == typeof this && this[s] || i.call(this)
    })
}
, function(e, t) {
    var n = {}.hasOwnProperty;
    e.exports = function(e, t) {
        return n.call(e, t)
    }
}
, function(e, t, n) {
    var o = n(25)
      , a = Math.min;
    e.exports = function(e) {
        return e > 0 ? a(o(e), 9007199254740991) : 0
    }
}
, function(e, t, n) {
    var o, a, r, s, i = n(22), l = n(0), u = n(6), c = n(11), d = n(14), p = n(4), f = n(7), h = n(38), v = n(39), m = n(43), g = n(26).set, y = n(46)(), b = n(27), w = n(47), _ = n(48), x = n(49), k = l.TypeError, S = l.process, C = S && S.versions, E = C && C.v8 || "", T = l.Promise, A = "process" == c(S), O = function() {}, M = a = b.f, P = !!function() {
        try {
            var e = T.resolve(1)
              , t = (e.constructor = {})[n(1)("species")] = function(e) {
                e(O, O)
            }
            ;
            return (A || "function" == typeof PromiseRejectionEvent) && e.then(O)instanceof t && 0 !== E.indexOf("6.6") && -1 === _.indexOf("Chrome/66")
        } catch (o) {}
    }(), B = function(e) {
        var t;
        return !(!p(e) || "function" != typeof (t = e.then)) && t
    }, I = function(e, t) {
        if (!e._n) {
            e._n = !0;
            var n = e._c;
            y(function() {
                for (var o = e._v, a = 1 == e._s, r = 0, s = function(t) {
                    var n, r, s, i = a ? t.ok : t.fail, l = t.resolve, u = t.reject, c = t.domain;
                    try {
                        i ? (a || (2 == e._h && z(e),
                        e._h = 1),
                        !0 === i ? n = o : (c && c.enter(),
                        n = i(o),
                        c && (c.exit(),
                        s = !0)),
                        n === t.promise ? u(k("Promise-chain cycle")) : (r = B(n)) ? r.call(n, l, u) : l(n)) : u(o)
                    } catch (d) {
                        c && !s && c.exit(),
                        u(d)
                    }
                }; n.length > r; )
                    s(n[r++]);
                e._c = [],
                e._n = !1,
                t && !e._h && L(e)
            })
        }
    }, L = function(e) {
        g.call(l, function() {
            var t, n, o, a = e._v, r = R(e);
            if (r && (t = w(function() {
                A ? S.emit("unhandledRejection", a, e) : (n = l.onunhandledrejection) ? n({
                    promise: e,
                    reason: a
                }) : (o = l.console) && o.error && o.error("Unhandled promise rejection", a)
            }),
            e._h = A || R(e) ? 2 : 1),
            e._a = void 0,
            r && t.e)
                throw t.v
        })
    }, R = function(e) {
        return 1 !== e._h && 0 === (e._a || e._c).length
    }, z = function(e) {
        g.call(l, function() {
            var t;
            A ? S.emit("rejectionHandled", e) : (t = l.onrejectionhandled) && t({
                promise: e,
                reason: e._v
            })
        })
    }, N = function(e) {
        var t = this;
        t._d || (t._d = !0,
        (t = t._w || t)._v = e,
        t._s = 2,
        t._a || (t._a = t._c.slice()),
        I(t, !0))
    }, D = function(e) {
        var t, n = this;
        if (!n._d) {
            n._d = !0,
            n = n._w || n;
            try {
                if (n === e)
                    throw k("Promise can't be resolved itself");
                (t = B(e)) ? y(function() {
                    var o = {
                        _w: n,
                        _d: !1
                    };
                    try {
                        t.call(e, u(D, o, 1), u(N, o, 1))
                    } catch (a) {
                        N.call(o, a)
                    }
                }) : (n._v = e,
                n._s = 1,
                I(n, !1))
            } catch (o) {
                N.call({
                    _w: n,
                    _d: !1
                }, o)
            }
        }
    };
    P || (T = function(e) {
        h(this, T, "Promise", "_h"),
        f(e),
        o.call(this);
        try {
            e(u(D, this, 1), u(N, this, 1))
        } catch (t) {
            N.call(this, t)
        }
    }
    ,
    (o = function(e) {
        this._c = [],
        this._a = void 0,
        this._s = 0,
        this._d = !1,
        this._v = void 0,
        this._h = 0,
        this._n = !1
    }
    ).prototype = n(50)(T.prototype, {
        then: function(e, t) {
            var n = M(m(this, T));
            return n.ok = "function" != typeof e || e,
            n.fail = "function" == typeof t && t,
            n.domain = A ? S.domain : void 0,
            this._c.push(n),
            this._a && this._a.push(n),
            this._s && I(this, !1),
            n.promise
        },
        catch: function(e) {
            return this.then(void 0, e)
        }
    }),
    r = function() {
        var e = new o;
        this.promise = e,
        this.resolve = u(D, e, 1),
        this.reject = u(N, e, 1)
    }
    ,
    b.f = M = function(e) {
        return e === T || e === s ? new r(e) : a(e)
    }
    ),
    d(d.G + d.W + d.F * !P, {
        Promise: T
    }),
    n(51)(T, "Promise"),
    n(52)("Promise"),
    s = n(2).Promise,
    d(d.S + d.F * !P, "Promise", {
        reject: function(e) {
            var t = M(this);
            return (0,
            t.reject)(e),
            t.promise
        }
    }),
    d(d.S + d.F * (i || !P), "Promise", {
        resolve: function(e) {
            return x(i && this === s ? T : this, e)
        }
    }),
    d(d.S + d.F * !(P && n(53)(function(e) {
        T.all(e).catch(O)
    })), "Promise", {
        all: function(e) {
            var t = this
              , n = M(t)
              , o = n.resolve
              , a = n.reject
              , r = w(function() {
                var n = []
                  , r = 0
                  , s = 1;
                v(e, !1, function(e) {
                    var i = r++
                      , l = !1;
                    n.push(void 0),
                    s++,
                    t.resolve(e).then(function(e) {
                        l || (l = !0,
                        n[i] = e,
                        --s || o(n))
                    }, a)
                }),
                --s || o(n)
            });
            return r.e && a(r.v),
            n.promise
        },
        race: function(e) {
            var t = this
              , n = M(t)
              , o = n.reject
              , a = w(function() {
                v(e, !1, function(e) {
                    t.resolve(e).then(n.resolve, o)
                })
            });
            return a.e && o(a.v),
            n.promise
        }
    })
}
, function(e, t) {
    e.exports = !1
}
, function(e, t, n) {
    var o = n(4)
      , a = n(0).document
      , r = o(a) && o(a.createElement);
    e.exports = function(e) {
        return r ? a.createElement(e) : {}
    }
}
, function(e, t) {
    e.exports = {}
}
, function(e, t) {
    var n = Math.ceil
      , o = Math.floor;
    e.exports = function(e) {
        return isNaN(e = +e) ? 0 : (e > 0 ? o : n)(e)
    }
}
, function(e, t, n) {
    var o, a, r, s = n(6), i = n(44), l = n(45), u = n(23), c = n(0), d = c.process, p = c.setImmediate, f = c.clearImmediate, h = c.MessageChannel, v = c.Dispatch, m = 0, g = {}, y = function() {
        var e = +this;
        if (g.hasOwnProperty(e)) {
            var t = g[e];
            delete g[e],
            t()
        }
    }, b = function(e) {
        y.call(e.data)
    };
    p && f || (p = function(e) {
        for (var t = [], n = 1; arguments.length > n; )
            t.push(arguments[n++]);
        return g[++m] = function() {
            i("function" == typeof e ? e : Function(e), t)
        }
        ,
        o(m),
        m
    }
    ,
    f = function(e) {
        delete g[e]
    }
    ,
    "process" == n(8)(d) ? o = function(e) {
        d.nextTick(s(y, e, 1))
    }
    : v && v.now ? o = function(e) {
        v.now(s(y, e, 1))
    }
    : h ? (r = (a = new h).port2,
    a.port1.onmessage = b,
    o = s(r.postMessage, r, 1)) : c.addEventListener && "function" == typeof postMessage && !c.importScripts ? (o = function(e) {
        c.postMessage(e + "", "*")
    }
    ,
    c.addEventListener("message", b, !1)) : o = "onreadystatechange"in u("script") ? function(e) {
        l.appendChild(u("script")).onreadystatechange = function() {
            l.removeChild(this),
            y.call(e)
        }
    }
    : function(e) {
        setTimeout(s(y, e, 1), 0)
    }
    ),
    e.exports = {
        set: p,
        clear: f
    }
}
, function(e, t, n) {
    var o = n(7);
    function a(e) {
        var t, n;
        this.promise = new e(function(e, o) {
            if (void 0 !== t || void 0 !== n)
                throw TypeError("Bad Promise constructor");
            t = e,
            n = o
        }
        ),
        this.resolve = o(t),
        this.reject = o(n)
    }
    e.exports.f = function(e) {
        return new a(e)
    }
}
, function(e, t, n) {
    var o = n(11)
      , a = {};
    a[n(1)("toStringTag")] = "z",
    a + "" != "[object z]" && n(18)(Object.prototype, "toString", function() {
        return "[object " + o(this) + "]"
    }, !0)
}
, function(e, t, n) {
    var o = n(30)
      , a = n(31);
    e.exports = function(e) {
        return o(a(e))
    }
}
, function(e, t, n) {
    var o = n(8);
    e.exports = Object("z").propertyIsEnumerable(0) ? Object : function(e) {
        return "String" == o(e) ? e.split("") : Object(e)
    }
}
, function(e, t) {
    e.exports = function(e) {
        if (null == e)
            throw TypeError("Can't call method on  " + e);
        return e
    }
}
, function(e, t, n) {
    var o = n(25)
      , a = Math.max
      , r = Math.min;
    e.exports = function(e, t) {
        return (e = o(e)) < 0 ? a(e + t, 0) : r(e, t)
    }
}
, function(e, t, n) {
    var o = n(31);
    e.exports = function(e) {
        return Object(o(e))
    }
}
, function(e, t, n) {
    e.exports = !n(5) && !n(17)(function() {
        return 7 != Object.defineProperty(n(23)("div"), "a", {
            get: function() {
                return 7
            }
        }).a
    })
}
, function(e, t, n) {
    var o = n(4);
    e.exports = function(e, t) {
        if (!o(e))
            return e;
        var n, a;
        if (t && "function" == typeof (n = e.toString) && !o(a = n.call(e)))
            return a;
        if ("function" == typeof (n = e.valueOf) && !o(a = n.call(e)))
            return a;
        if (!t && "function" == typeof (n = e.toString) && !o(a = n.call(e)))
            return a;
        throw TypeError("Can't convert object to primitive value")
    }
}
, function(e, t) {
    e.exports = function(e, t) {
        return {
            enumerable: !(1 & e),
            configurable: !(2 & e),
            writable: !(4 & e),
            value: t
        }
    }
}
, function(e, t, n) {
    e.exports = n(12)("native-function-to-string", Function.toString)
}
, function(e, t) {
    e.exports = function(e, t, n, o) {
        if (!(e instanceof t) || void 0 !== o && o in e)
            throw TypeError(n + ": incorrect invocation!");
        return e
    }
}
, function(e, t, n) {
    var o = n(6)
      , a = n(40)
      , r = n(41)
      , s = n(3)
      , i = n(20)
      , l = n(42)
      , u = {}
      , c = {};
    (t = e.exports = function(e, t, n, d, p) {
        var f, h, v, m, g = p ? function() {
            return e
        }
        : l(e), y = o(n, d, t ? 2 : 1), b = 0;
        if ("function" != typeof g)
            throw TypeError(e + " is not iterable!");
        if (r(g)) {
            for (f = i(e.length); f > b; b++)
                if ((m = t ? y(s(h = e[b])[0], h[1]) : y(e[b])) === u || m === c)
                    return m
        } else
            for (v = g.call(e); !(h = v.next()).done; )
                if ((m = a(v, y, h.value, t)) === u || m === c)
                    return m
    }
    ).BREAK = u,
    t.RETURN = c
}
, function(e, t, n) {
    var o = n(3);
    e.exports = function(e, t, n, a) {
        try {
            return a ? t(o(n)[0], n[1]) : t(n)
        } catch (s) {
            var r = e.return;
            throw void 0 !== r && o(r.call(e)),
            s
        }
    }
}
, function(e, t, n) {
    var o = n(24)
      , a = n(1)("iterator")
      , r = Array.prototype;
    e.exports = function(e) {
        return void 0 !== e && (o.Array === e || r[a] === e)
    }
}
, function(e, t, n) {
    var o = n(11)
      , a = n(1)("iterator")
      , r = n(24);
    e.exports = n(2).getIteratorMethod = function(e) {
        if (null != e)
            return e[a] || e["@@iterator"] || r[o(e)]
    }
}
, function(e, t, n) {
    var o = n(3)
      , a = n(7)
      , r = n(1)("species");
    e.exports = function(e, t) {
        var n, s = o(e).constructor;
        return void 0 === s || null == (n = o(s)[r]) ? t : a(n)
    }
}
, function(e, t) {
    e.exports = function(e, t, n) {
        var o = void 0 === n;
        switch (t.length) {
        case 0:
            return o ? e() : e.call(n);
        case 1:
            return o ? e(t[0]) : e.call(n, t[0]);
        case 2:
            return o ? e(t[0], t[1]) : e.call(n, t[0], t[1]);
        case 3:
            return o ? e(t[0], t[1], t[2]) : e.call(n, t[0], t[1], t[2]);
        case 4:
            return o ? e(t[0], t[1], t[2], t[3]) : e.call(n, t[0], t[1], t[2], t[3])
        }
        return e.apply(n, t)
    }
}
, function(e, t, n) {
    var o = n(0).document;
    e.exports = o && o.documentElement
}
, function(e, t, n) {
    var o = n(0)
      , a = n(26).set
      , r = o.MutationObserver || o.WebKitMutationObserver
      , s = o.process
      , i = o.Promise
      , l = "process" == n(8)(s);
    e.exports = function() {
        var e, t, n, u = function() {
            var o, a;
            for (l && (o = s.domain) && o.exit(); e; ) {
                a = e.fn,
                e = e.next;
                try {
                    a()
                } catch (r) {
                    throw e ? n() : t = void 0,
                    r
                }
            }
            t = void 0,
            o && o.enter()
        };
        if (l)
            n = function() {
                s.nextTick(u)
            }
            ;
        else if (!r || o.navigator && o.navigator.standalone)
            if (i && i.resolve) {
                var c = i.resolve(void 0);
                n = function() {
                    c.then(u)
                }
            } else
                n = function() {
                    a.call(o, u)
                }
                ;
        else {
            var d = !0
              , p = document.createTextNode("");
            new r(u).observe(p, {
                characterData: !0
            }),
            n = function() {
                p.data = d = !d
            }
        }
        return function(o) {
            var a = {
                fn: o,
                next: void 0
            };
            t && (t.next = a),
            e || (e = a,
            n()),
            t = a
        }
    }
}
, function(e, t) {
    e.exports = function(e) {
        try {
            return {
                e: !1,
                v: e()
            }
        } catch (t) {
            return {
                e: !0,
                v: t
            }
        }
    }
}
, function(e, t, n) {
    var o = n(0).navigator;
    e.exports = o && o.userAgent || ""
}
, function(e, t, n) {
    var o = n(3)
      , a = n(4)
      , r = n(27);
    e.exports = function(e, t) {
        if (o(e),
        a(t) && t.constructor === e)
            return t;
        var n = r.f(e);
        return (0,
        n.resolve)(t),
        n.promise
    }
}
, function(e, t, n) {
    var o = n(18);
    e.exports = function(e, t, n) {
        for (var a in t)
            o(e, a, t[a], n);
        return e
    }
}
, function(e, t, n) {
    var o = n(16).f
      , a = n(19)
      , r = n(1)("toStringTag");
    e.exports = function(e, t, n) {
        e && !a(e = n ? e : e.prototype, r) && o(e, r, {
            configurable: !0,
            value: t
        })
    }
}
, function(e, t, n) {
    var o = n(0)
      , a = n(16)
      , r = n(5)
      , s = n(1)("species");
    e.exports = function(e) {
        var t = o[e];
        r && t && !t[s] && a.f(t, s, {
            configurable: !0,
            get: function() {
                return this
            }
        })
    }
}
, function(e, t, n) {
    var o = n(1)("iterator")
      , a = !1;
    try {
        var r = [7][o]();
        r.return = function() {
            a = !0
        }
        ,
        Array.from(r, function() {
            throw 2
        })
    } catch (s) {}
    e.exports = function(e, t) {
        if (!t && !a)
            return !1;
        var n = !1;
        try {
            var r = [7]
              , s = r[o]();
            s.next = function() {
                return {
                    done: n = !0
                }
            }
            ,
            r[o] = function() {
                return s
            }
            ,
            e(r)
        } catch (i) {}
        return n
    }
}
, function(e, t, n) {
    var o = n(14);
    o(o.S + o.F, "Object", {
        assign: n(55)
    })
}
, function(e, t, n) {
    var o = n(5)
      , a = n(56)
      , r = n(61)
      , s = n(62)
      , i = n(33)
      , l = n(30)
      , u = Object.assign;
    e.exports = !u || n(17)(function() {
        var e = {}
          , t = {}
          , n = Symbol()
          , o = "abcdefghijklmnopqrst";
        return e[n] = 7,
        o.split("").forEach(function(e) {
            t[e] = e
        }),
        7 != u({}, e)[n] || Object.keys(u({}, t)).join("") != o
    }) ? function(e, t) {
        for (var n = i(e), u = arguments.length, c = 1, d = r.f, p = s.f; u > c; )
            for (var f, h = l(arguments[c++]), v = d ? a(h).concat(d(h)) : a(h), m = v.length, g = 0; m > g; )
                f = v[g++],
                o && !p.call(h, f) || (n[f] = h[f]);
        return n
    }
    : u
}
, function(e, t, n) {
    var o = n(57)
      , a = n(60);
    e.exports = Object.keys || function(e) {
        return o(e, a)
    }
}
, function(e, t, n) {
    var o = n(19)
      , a = n(29)
      , r = n(58)(!1)
      , s = n(59)("IE_PROTO");
    e.exports = function(e, t) {
        var n, i = a(e), l = 0, u = [];
        for (n in i)
            n != s && o(i, n) && u.push(n);
        for (; t.length > l; )
            o(i, n = t[l++]) && (~r(u, n) || u.push(n));
        return u
    }
}
, function(e, t, n) {
    var o = n(29)
      , a = n(20)
      , r = n(32);
    e.exports = function(e) {
        return function(t, n, s) {
            var i, l = o(t), u = a(l.length), c = r(s, u);
            if (e && n != n) {
                for (; u > c; )
                    if ((i = l[c++]) != i)
                        return !0
            } else
                for (; u > c; c++)
                    if ((e || c in l) && l[c] === n)
                        return e || c || 0;
            return !e && -1
        }
    }
}
, function(e, t, n) {
    var o = n(12)("keys")
      , a = n(13);
    e.exports = function(e) {
        return o[e] || (o[e] = a(e))
    }
}
, function(e, t) {
    e.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
}
, function(e, t) {
    t.f = Object.getOwnPropertySymbols
}
, function(e, t) {
    t.f = {}.propertyIsEnumerable
}
, function(e, t, n) {
    var o = n(14);
    o(o.P, "Array", {
        fill: n(64)
    }),
    n(65)("fill")
}
, function(e, t, n) {
    var o = n(33)
      , a = n(32)
      , r = n(20);
    e.exports = function(e) {
        for (var t = o(this), n = r(t.length), s = arguments.length, i = a(s > 1 ? arguments[1] : void 0, n), l = s > 2 ? arguments[2] : void 0, u = void 0 === l ? n : a(l, n); u > i; )
            t[i++] = e;
        return t
    }
}
, function(e, t, n) {
    var o = n(1)("unscopables")
      , a = Array.prototype;
    null == a[o] && n(15)(a, o, {}),
    e.exports = function(e) {
        a[o][e] = !0
    }
}
, function(e, t, n) {
    n.r(t),
    n.d(t, "ScratchCard", function() {
        return p
    }),
    n.d(t, "SCRATCH_TYPE", function() {
        return o
    }),
    n(21),
    n(28),
    n(54);
    var o, a, r = n(9), s = n.n(r), i = n(10), l = n.n(i), u = (n(63),
    function() {
        function e(t, n, o) {
            s()(this, e),
            this.ctx = t,
            this.mouseX = n,
            this.mouseY = o
        }
        return l()(e, [{
            key: "updateMousePosition",
            value: function(e, t) {
                this.mouseX = e,
                this.mouseY = t
            }
        }, {
            key: "circle",
            value: function(e) {
                this.ctx.beginPath(),
                this.ctx.arc(this.mouseX + e, this.mouseY + e, e, 0, 2 * Math.PI, !1),
                this.ctx.fillStyle = "#000000",
                this.ctx.fill(),
                this.ctx.closePath()
            }
        }, {
            key: "clearPoint",
            value: function(e) {
                var t = e
                  , n = 2 * Math.random() * t - t
                  , o = Math.sqrt(t * t - n * n)
                  , a = 2 * Math.random() * o - o;
                return n += t,
                a += t,
                [n += this.mouseX, a += this.mouseY]
            }
        }, {
            key: "spray",
            value: function(e, t, n) {
                for (var o = 0; o < n; o++) {
                    var a = this.clearPoint(e / 2);
                    this.ctx.beginPath(),
                    this.ctx.arc(a[0] + e / 2, a[1] + e / 2, t / 2, 0, 2 * Math.PI, !1),
                    this.ctx.fillStyle = "#000000",
                    this.ctx.fill(),
                    this.ctx.closePath()
                }
            }
        }, {
            key: "brush",
            value: function(e) {
                if (null !== e) {
                    var t = Math.atan2(this.mouseY, this.mouseX);
                    this.ctx.save(),
                    this.ctx.translate(this.mouseX, this.mouseY),
                    this.ctx.rotate(t),
                    this.ctx.drawImage(e, -e.width / 2, -e.height / 2)
                } else
                    new Error("argument img is not a node IMG")
            }
        }, {
            key: "startLine",
            value: function(e) {
                this.ctx.beginPath(),
                this.ctx.strokeStyle = "black",
                this.ctx.lineWidth = e,
                this.ctx.lineJoin = this.ctx.lineCap = "round",
                this.ctx.moveTo(this.mouseX + e, this.mouseY + e)
            }
        }, {
            key: "drawLine",
            value: function(e) {
                this.ctx.filter = "blur(1px)",
                this.ctx.lineTo(this.mouseX + e, this.mouseY + e),
                this.ctx.stroke()
            }
        }]),
        e
    }());
    function c(e) {
        return new Promise(function(t, n) {
            var o = new Image;
            o.crossOrigin = "Anonymous",
            o.onload = function() {
                t(o)
            }
            ,
            o.src = e,
            o.onerror = function(t) {
                var o = new Error("Image ".concat(e, " is not loaded."));
                n(o)
            }
        }
        )
    }
    function d(e, t) {
        var n, o;
        return function() {
            var a = this
              , r = +new Date
              , s = arguments;
            n && r < n + t ? (clearTimeout(o),
            o = window.setTimeout(function() {
                n = r,
                e.apply(a, s)
            }, t)) : (n = r,
            e.apply(a, s))
        }
    }
    (a = o || (o = {}))[a.BRUSH = 0] = "BRUSH",
    a[a.SPRAY = 1] = "SPRAY",
    a[a.CIRCLE = 2] = "CIRCLE",
    a[a.LINE = 3] = "LINE",
    function() {
        if ("function" == typeof window.CustomEvent)
            return !1;
        function e(e, t) {
            t = t || {
                bubbles: !1,
                cancelable: !1,
                detail: void 0
            };
            var n = document.createEvent("CustomEvent");
            return n.initCustomEvent(e, t.bubbles, t.cancelable, t.detail),
            n
        }
        e.prototype = window.Event.prototype,
        window.CustomEvent = e
    }();
    var p = function() {
        function e(t, n) {
            var a = this;
            s()(this, e);
            var r = this
              , i = {
                scratchType: o.LINE,
                containerWidth: 100,
                containerHeight: 100,
                percentToFinish: 50,
                nPoints: 0,
                pointSize: [0, 0],
                callback: function() {
                    alert("done.")
                },
                brushSrc: "",
                imageForwardSrc: "./images/scratchcard.png",
                imageBackgroundSrc: "./images/scratchcard-background.svg",
                htmlBackground: "",
                clearZoneRadius: 0,
                enabledPercentUpdate: !0
            };
            this.config = Object.assign(Object.assign({}, i), n),
            this.scratchType = this.config.scratchType,
            this.container = this.isString(t) ? document.querySelector(String(t)) : t,
            this.position = [0, 0],
            this.readyToClear = !1,
            this.percent = 0,
            this.callbackDone = !1,
            this.generateCanvas(),
            this.ctx = this.canvas.getContext("2d"),
            this.brush = new u(this.ctx,this.position[0],this.position[1]),
            this.config.scratchType === o.BRUSH && c(this.config.brushSrc).then(function(e) {
                a.brushImage = e
            });
            var l = d(function(e) {
                e.preventDefault(),
                r.dispatchEvent("scratch", "move"),
                r.position = r.mousePosition(e),
                r.brush.updateMousePosition(r.position[0], r.position[1]),
                r.scratch(),
                a.config.enabledPercentUpdate && (r.percent = r.updatePercent())
            }, 16);
            this.canvas.addEventListener("mousedown", function(e) {
                e.preventDefault(),
                r._setScratchPosition(),
                r.scratchType === o.LINE && (r.position = r.mousePosition(e),
                r.brush.updateMousePosition(r.position[0], r.position[1]),
                r.brush.startLine(r.config.clearZoneRadius)),
                r.canvas.addEventListener("mousemove", l),
                document.body.addEventListener("mouseup", function e(t) {
                    r.canvas.removeEventListener("mousemove", l),
                    r.finish(),
                    this.removeEventListener("mouseup", e)
                })
            }),
            this.canvas.addEventListener("touchstart", function(e) {
                e.preventDefault(),
                r._setScratchPosition(),
                r.scratchType === o.LINE && (r.position = r.mousePosition(e),
                r.brush.updateMousePosition(r.position[0], r.position[1]),
                r.brush.startLine(r.config.clearZoneRadius)),
                r.canvas.addEventListener("touchmove", l),
                document.body.addEventListener("touchend", function e() {
                    r.canvas.removeEventListener("touchmove", l),
                    r.finish(),
                    this.removeEventListener("touchend", e)
                })
            }),
            window.addEventListener("resize", d(function() {
                a._setScratchPosition()
            }, 100)),
            window.addEventListener("scroll", d(function() {
                a._setScratchPosition()
            }, 16))
        }
        return l()(e, [{
            key: "isString",
            value: function(e) {
                return "string" == typeof e || e instanceof String
            }
        }, {
            key: "getPercent",
            value: function() {
                return this.percent
            }
        }, {
            key: "_setScratchPosition",
            value: function() {
                this.zone = function(e) {
                    for (var t = {
                        left: 0,
                        top: 0
                    }, n = e.getBoundingClientRect(); e; )
                        t.top += e.offsetTop,
                        t.left += e.offsetLeft,
                        e = e.offsetParent;
                    var o = t.left - n.left
                      , a = t.top - n.top;
                    return {
                        left: o < 0 ? t.left + Math.abs(o) : t.left - Math.abs(o),
                        top: a < 0 ? t.top + Math.abs(a) : t.top - Math.abs(a)
                    }
                }(this.canvas)
            }
        }, {
            key: "finish",
            value: function() {
                !this.callbackDone && this.percent > this.config.percentToFinish && (this.clear(),
                this.canvas.style.pointerEvents = "none",
                void 0 !== this.config.callback && (this.callbackDone = !0,
                this.config.callback()))
            }
        }, {
            key: "dispatchEvent",
            value: function(e, t) {
                var n, o, a;
                n = this.canvas,
                o = "".concat(e, ".").concat(t),
                a = new CustomEvent(o,{
                    bubbles: !0,
                    cancelable: !0,
                    detail: {}
                }),
                n.dispatchEvent(a)
            }
        }, {
            key: "init",
            value: function() {
                var e = this;
                return new Promise(function(t, n) {
                    c(e.config.imageForwardSrc).then(function(n) {
                        e.scratchImage = n,
                        e.ctx.drawImage(e.scratchImage, 0, 0, e.canvas.width, e.canvas.height),
                        e.setBackground(),
                        t()
                    }, function(t) {
                        return n(t),
                        new TypeError("".concat(e.config.imageForwardSrc, " is not loaded."))
                    })
                }
                )
            }
        }, {
            key: "generateCanvas",
            value: function() {
                this.canvas = document.createElement("canvas"),
                this.canvas.classList.add("sc__canvas"),
                this.canvas.width = this.config.containerWidth,
                this.canvas.height = this.config.containerHeight,
                this.container.appendChild(this.canvas)
            }
        }, {
            key: "setBackground",
            value: function() {
                var e = this;
                if (0 !== this.config.htmlBackground.length)
                    !function(e, t) {
                        var n = new DOMParser
                          , o = document.createElement("div");
                        o.classList.add("sc__inner");
                        var a = n.parseFromString(e, "text/html");
                        o.innerHTML = a.body.innerHTML,
                        t.insertBefore(o, t.firstElementChild)
                    }(this.config.htmlBackground, this.container);
                else {
                    var t = document.createElement("img");
                    c(this.config.imageBackgroundSrc).then(function(n) {
                        t.src = n.src,
                        e.container.insertBefore(t, e.canvas)
                    }, function(e) {})
                }
            }
        }, {
            key: "mousePosition",
            value: function(e) {
                var t, n;
                switch (e.type) {
                case "touchmove":
                    t = e.touches[0].clientX - this.config.clearZoneRadius - this.zone.left,
                    n = e.touches[0].clientY - this.config.clearZoneRadius - this.zone.top;
                    break;
                case "mousemove":
                    t = e.clientX - this.config.clearZoneRadius - this.zone.left,
                    n = e.clientY - this.config.clearZoneRadius - this.zone.top
                }
                return [t, n]
            }
        }, {
            key: "scratch",
            value: function() {
                switch (this.position[0],
                this.position[1],
                this.ctx.globalCompositeOperation = "destination-out",
                this.ctx.save(),
                this.config.scratchType) {
                case o.BRUSH:
                    this.brush.brush(this.brushImage);
                    break;
                case o.CIRCLE:
                    this.brush.circle(this.config.clearZoneRadius);
                    break;
                case o.SPRAY:
                    this.brush.spray(this.config.clearZoneRadius, this.config.pointSize, this.config.nPoints);
                    break;
                case o.LINE:
                    this.brush.drawLine(this.config.clearZoneRadius)
                }
                this.ctx.restore()
            }
        }, {
            key: "updatePercent",
            value: function() {
                for (var e = 0, t = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height), n = t.data.length, o = 0; o < n; o += 4)
                    0 === t.data[o] && 0 === t.data[o + 1] && 0 === t.data[o + 2] && 0 === t.data[o + 3] && e++;
                return e >= 1 ? e / (this.canvas.width * this.canvas.height) * 100 : 0
            }
        }, {
            key: "clear",
            value: function() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
            }
        }]),
        e
    }();
    window.ScratchCard = p,
    window.SCRATCH_TYPE = o
}
])),
ZP.exports);
function WP(e, t={
    brushSrc: "https://ik.imagekit.io/azx3nlpdu/Ativo%202.png?updatedAt=1751704334194"
}) {
    const n = It(null);
    let o;
    function a() {
        var t, n;
        null == (n = null == (t = e.value) ? void 0 : t.querySelector("canvas")) || n.remove()
    }
    function r() {
        const r = e.value;
        a();
        const {width: s, height: i} = r.getBoundingClientRect();
        o = {
            scratchType: t.scratchType ?? qP.SCRATCH_TYPE.LINE,
            containerWidth: s,
            containerHeight: i,
            imageForwardSrc: t.imageForwardSrc ?? "",
            imageBackgroundSrc: t.imageBackgroundSrc ?? "",
            htmlBackground: t.htmlBackground ?? "",
            brushSrc: t.brushSrc ?? "",
            clearZoneRadius: t.clearZoneRadius ?? 50,
            nPoints: t.nPoints ?? 0,
            pointSize: t.pointSize ?? 0,
            percentToFinish: t.percentToFinish ?? 70,
            enabledPercentUpdate: t.enabledPercentUpdate ?? !0,
            callback: t.callback
        },
        n.value = new qP.ScratchCard(r,o),
        n.value.init().then( () => {
            n.value.canvas.addEventListener("scratch.move", () => {}
            )
        }
        ).catch(console.error)
    }
    return Mo(async () => {
        await fn(),
        r(),
        window.addEventListener("resize", r)
    }
    ),
    Io( () => {
        window.removeEventListener("resize", r),
        a()
    }
    ),
    {
        scratchAll: function(e=1) {
            n.value && function(e, t, n) {
                const o = e.canvas
                  , a = o.getContext("2d")
                  , {width: r, height: s} = o
                  , i = r / 2
                  , l = s / 2
                  , u = 6 + Math.random()
                  , c = 400 + Math.floor(80 * Math.random())
                  , d = Math.hypot(i, l) - .7 * t.clearZoneRadius
                  , p = [];
                for (let v = 0; v < c; v++) {
                    const e = v / c
                      , t = 2 * u * Math.PI * e
                      , n = e * d * (.97 + .08 * Math.random())
                      , o = 1 + .18 * Math.sin(4 * t);
                    p.push({
                        x: i + Math.cos(t) * n * o + 10 * (Math.random() - .5),
                        y: l + Math.sin(t) * n * o + 10 * (Math.random() - .5)
                    })
                }
                let f = 0;
                const h = 1.05 * t.clearZoneRadius;
                !function o() {
                    var i;
                    if (f >= p.length)
                        return a.globalCompositeOperation = "destination-out",
                        a.fillRect(0, 0, r, s),
                        e.finish(),
                        void (null == (i = t.callback) || i.call(e));
                    a.save(),
                    a.globalCompositeOperation = "destination-out",
                    a.beginPath(),
                    a.arc(p[f].x, p[f].y, h * (.92 + .15 * Math.random()), 0, 2 * Math.PI),
                    a.fill(),
                    a.restore(),
                    f > 0 && (a.save(),
                    a.globalCompositeOperation = "destination-out",
                    a.beginPath(),
                    a.moveTo(p[f - 1].x, p[f - 1].y),
                    a.lineTo(p[f].x, p[f].y),
                    a.lineWidth = 1.7 * h,
                    a.stroke(),
                    a.restore()),
                    f++;
                    const l = (7 + 3 * Math.random()) * (1 + f / c * .5) / n;
                    setTimeout(o, l)
                }()
            }(n.value, o, e)
        },
        sc: n,
        reset: function() {
            r()
        }
    }
}
var GP, KP = {};
/*!
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
var YP, XP = (GP || (GP = 1,
YP = KP,
function() {
    var e = function() {
        this.init()
    };
    e.prototype = {
        init: function() {
            var e = this || t;
            return e._counter = 1e3,
            e._html5AudioPool = [],
            e.html5PoolSize = 10,
            e._codecs = {},
            e._howls = [],
            e._muted = !1,
            e._volume = 1,
            e._canPlayEvent = "canplaythrough",
            e._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null,
            e.masterGain = null,
            e.noAudio = !1,
            e.usingWebAudio = !0,
            e.autoSuspend = !0,
            e.ctx = null,
            e.autoUnlock = !0,
            e._setup(),
            e
        },
        volume: function(e) {
            var n = this || t;
            if (e = parseFloat(e),
            n.ctx || u(),
            void 0 !== e && e >= 0 && e <= 1) {
                if (n._volume = e,
                n._muted)
                    return n;
                n.usingWebAudio && n.masterGain.gain.setValueAtTime(e, t.ctx.currentTime);
                for (var o = 0; o < n._howls.length; o++)
                    if (!n._howls[o]._webAudio)
                        for (var a = n._howls[o]._getSoundIds(), r = 0; r < a.length; r++) {
                            var s = n._howls[o]._soundById(a[r]);
                            s && s._node && (s._node.volume = s._volume * e)
                        }
                return n
            }
            return n._volume
        },
        mute: function(e) {
            var n = this || t;
            n.ctx || u(),
            n._muted = e,
            n.usingWebAudio && n.masterGain.gain.setValueAtTime(e ? 0 : n._volume, t.ctx.currentTime);
            for (var o = 0; o < n._howls.length; o++)
                if (!n._howls[o]._webAudio)
                    for (var a = n._howls[o]._getSoundIds(), r = 0; r < a.length; r++) {
                        var s = n._howls[o]._soundById(a[r]);
                        s && s._node && (s._node.muted = !!e || s._muted)
                    }
            return n
        },
        stop: function() {
            for (var e = this || t, n = 0; n < e._howls.length; n++)
                e._howls[n].stop();
            return e
        },
        unload: function() {
            for (var e = this || t, n = e._howls.length - 1; n >= 0; n--)
                e._howls[n].unload();
            return e.usingWebAudio && e.ctx && void 0 !== e.ctx.close && (e.ctx.close(),
            e.ctx = null,
            u()),
            e
        },
        codecs: function(e) {
            return (this || t)._codecs[e.replace(/^x-/, "")]
        },
        _setup: function() {
            var e = this || t;
            if (e.state = e.ctx && e.ctx.state || "suspended",
            e._autoSuspend(),
            !e.usingWebAudio)
                if ("undefined" != typeof Audio)
                    try {
                        void 0 === (new Audio).oncanplaythrough && (e._canPlayEvent = "canplay")
                    } catch (pC) {
                        e.noAudio = !0
                    }
                else
                    e.noAudio = !0;
            try {
                (new Audio).muted && (e.noAudio = !0)
            } catch (pC) {}
            return e.noAudio || e._setupCodecs(),
            e
        },
        _setupCodecs: function() {
            var e = this || t
              , n = null;
            try {
                n = "undefined" != typeof Audio ? new Audio : null
            } catch (c) {
                return e
            }
            if (!n || "function" != typeof n.canPlayType)
                return e;
            var o = n.canPlayType("audio/mpeg;").replace(/^no$/, "")
              , a = e._navigator ? e._navigator.userAgent : ""
              , r = a.match(/OPR\/(\d+)/g)
              , s = r && parseInt(r[0].split("/")[1], 10) < 33
              , i = -1 !== a.indexOf("Safari") && -1 === a.indexOf("Chrome")
              , l = a.match(/Version\/(.*?) /)
              , u = i && l && parseInt(l[1], 10) < 15;
            return e._codecs = {
                mp3: !(s || !o && !n.canPlayType("audio/mp3;").replace(/^no$/, "")),
                mpeg: !!o,
                opus: !!n.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                ogg: !!n.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                oga: !!n.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                wav: !!(n.canPlayType('audio/wav; codecs="1"') || n.canPlayType("audio/wav")).replace(/^no$/, ""),
                aac: !!n.canPlayType("audio/aac;").replace(/^no$/, ""),
                caf: !!n.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                m4a: !!(n.canPlayType("audio/x-m4a;") || n.canPlayType("audio/m4a;") || n.canPlayType("audio/aac;")).replace(/^no$/, ""),
                m4b: !!(n.canPlayType("audio/x-m4b;") || n.canPlayType("audio/m4b;") || n.canPlayType("audio/aac;")).replace(/^no$/, ""),
                mp4: !!(n.canPlayType("audio/x-mp4;") || n.canPlayType("audio/mp4;") || n.canPlayType("audio/aac;")).replace(/^no$/, ""),
                weba: !(u || !n.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                webm: !(u || !n.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                dolby: !!n.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                flac: !!(n.canPlayType("audio/x-flac;") || n.canPlayType("audio/flac;")).replace(/^no$/, "")
            },
            e
        },
        _unlockAudio: function() {
            var e = this || t;
            if (!e._audioUnlocked && e.ctx) {
                e._audioUnlocked = !1,
                e.autoUnlock = !1,
                e._mobileUnloaded || 44100 === e.ctx.sampleRate || (e._mobileUnloaded = !0,
                e.unload()),
                e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050);
                var n = function(t) {
                    for (; e._html5AudioPool.length < e.html5PoolSize; )
                        try {
                            var o = new Audio;
                            o._unlocked = !0,
                            e._releaseHtml5Audio(o)
                        } catch (u) {
                            e.noAudio = !0;
                            break
                        }
                    for (var a = 0; a < e._howls.length; a++)
                        if (!e._howls[a]._webAudio)
                            for (var r = e._howls[a]._getSoundIds(), s = 0; s < r.length; s++) {
                                var i = e._howls[a]._soundById(r[s]);
                                i && i._node && !i._node._unlocked && (i._node._unlocked = !0,
                                i._node.load())
                            }
                    e._autoResume();
                    var l = e.ctx.createBufferSource();
                    l.buffer = e._scratchBuffer,
                    l.connect(e.ctx.destination),
                    void 0 === l.start ? l.noteOn(0) : l.start(0),
                    "function" == typeof e.ctx.resume && e.ctx.resume(),
                    l.onended = function() {
                        l.disconnect(0),
                        e._audioUnlocked = !0,
                        document.removeEventListener("touchstart", n, !0),
                        document.removeEventListener("touchend", n, !0),
                        document.removeEventListener("click", n, !0),
                        document.removeEventListener("keydown", n, !0);
                        for (var t = 0; t < e._howls.length; t++)
                            e._howls[t]._emit("unlock")
                    }
                };
                return document.addEventListener("touchstart", n, !0),
                document.addEventListener("touchend", n, !0),
                document.addEventListener("click", n, !0),
                document.addEventListener("keydown", n, !0),
                e
            }
        },
        _obtainHtml5Audio: function() {
            var e = this || t;
            if (e._html5AudioPool.length)
                return e._html5AudioPool.pop();
            var n = (new Audio).play();
            return n && "undefined" != typeof Promise && (n instanceof Promise || "function" == typeof n.then) && n.catch(function() {}),
            new Audio
        },
        _releaseHtml5Audio: function(e) {
            var n = this || t;
            return e._unlocked && n._html5AudioPool.push(e),
            n
        },
        _autoSuspend: function() {
            var e = this;
            if (e.autoSuspend && e.ctx && void 0 !== e.ctx.suspend && t.usingWebAudio) {
                for (var n = 0; n < e._howls.length; n++)
                    if (e._howls[n]._webAudio)
                        for (var o = 0; o < e._howls[n]._sounds.length; o++)
                            if (!e._howls[n]._sounds[o]._paused)
                                return e;
                return e._suspendTimer && clearTimeout(e._suspendTimer),
                e._suspendTimer = setTimeout(function() {
                    if (e.autoSuspend) {
                        e._suspendTimer = null,
                        e.state = "suspending";
                        var t = function() {
                            e.state = "suspended",
                            e._resumeAfterSuspend && (delete e._resumeAfterSuspend,
                            e._autoResume())
                        };
                        e.ctx.suspend().then(t, t)
                    }
                }, 3e4),
                e
            }
        },
        _autoResume: function() {
            var e = this;
            if (e.ctx && void 0 !== e.ctx.resume && t.usingWebAudio)
                return "running" === e.state && "interrupted" !== e.ctx.state && e._suspendTimer ? (clearTimeout(e._suspendTimer),
                e._suspendTimer = null) : "suspended" === e.state || "running" === e.state && "interrupted" === e.ctx.state ? (e.ctx.resume().then(function() {
                    e.state = "running";
                    for (var t = 0; t < e._howls.length; t++)
                        e._howls[t]._emit("resume")
                }),
                e._suspendTimer && (clearTimeout(e._suspendTimer),
                e._suspendTimer = null)) : "suspending" === e.state && (e._resumeAfterSuspend = !0),
                e
        }
    };
    var t = new e
      , n = function(e) {
        e.src && 0 !== e.src.length && this.init(e)
    };
    n.prototype = {
        init: function(e) {
            var n = this;
            return t.ctx || u(),
            n._autoplay = e.autoplay || !1,
            n._format = "string" != typeof e.format ? e.format : [e.format],
            n._html5 = e.html5 || !1,
            n._muted = e.mute || !1,
            n._loop = e.loop || !1,
            n._pool = e.pool || 5,
            n._preload = "boolean" != typeof e.preload && "metadata" !== e.preload || e.preload,
            n._rate = e.rate || 1,
            n._sprite = e.sprite || {},
            n._src = "string" != typeof e.src ? e.src : [e.src],
            n._volume = void 0 !== e.volume ? e.volume : 1,
            n._xhr = {
                method: e.xhr && e.xhr.method ? e.xhr.method : "GET",
                headers: e.xhr && e.xhr.headers ? e.xhr.headers : null,
                withCredentials: !(!e.xhr || !e.xhr.withCredentials) && e.xhr.withCredentials
            },
            n._duration = 0,
            n._state = "unloaded",
            n._sounds = [],
            n._endTimers = {},
            n._queue = [],
            n._playLock = !1,
            n._onend = e.onend ? [{
                fn: e.onend
            }] : [],
            n._onfade = e.onfade ? [{
                fn: e.onfade
            }] : [],
            n._onload = e.onload ? [{
                fn: e.onload
            }] : [],
            n._onloaderror = e.onloaderror ? [{
                fn: e.onloaderror
            }] : [],
            n._onplayerror = e.onplayerror ? [{
                fn: e.onplayerror
            }] : [],
            n._onpause = e.onpause ? [{
                fn: e.onpause
            }] : [],
            n._onplay = e.onplay ? [{
                fn: e.onplay
            }] : [],
            n._onstop = e.onstop ? [{
                fn: e.onstop
            }] : [],
            n._onmute = e.onmute ? [{
                fn: e.onmute
            }] : [],
            n._onvolume = e.onvolume ? [{
                fn: e.onvolume
            }] : [],
            n._onrate = e.onrate ? [{
                fn: e.onrate
            }] : [],
            n._onseek = e.onseek ? [{
                fn: e.onseek
            }] : [],
            n._onunlock = e.onunlock ? [{
                fn: e.onunlock
            }] : [],
            n._onresume = [],
            n._webAudio = t.usingWebAudio && !n._html5,
            void 0 !== t.ctx && t.ctx && t.autoUnlock && t._unlockAudio(),
            t._howls.push(n),
            n._autoplay && n._queue.push({
                event: "play",
                action: function() {
                    n.play()
                }
            }),
            n._preload && "none" !== n._preload && n.load(),
            n
        },
        load: function() {
            var e = this
              , n = null;
            if (t.noAudio)
                e._emit("loaderror", null, "No audio support.");
            else {
                "string" == typeof e._src && (e._src = [e._src]);
                for (var a = 0; a < e._src.length; a++) {
                    var s, i;
                    if (e._format && e._format[a])
                        s = e._format[a];
                    else {
                        if ("string" != typeof (i = e._src[a])) {
                            e._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                            continue
                        }
                        (s = /^data:audio\/([^;,]+);/i.exec(i)) || (s = /\.([^.]+)$/.exec(i.split("?", 1)[0])),
                        s && (s = s[1].toLowerCase())
                    }
                    if (s && t.codecs(s)) {
                        n = e._src[a];
                        break
                    }
                }
                if (n)
                    return e._src = n,
                    e._state = "loading",
                    "https:" === window.location.protocol && "http:" === n.slice(0, 5) && (e._html5 = !0,
                    e._webAudio = !1),
                    new o(e),
                    e._webAudio && r(e),
                    e;
                e._emit("loaderror", null, "No codec support for selected audio sources.")
            }
        },
        play: function(e, n) {
            var o = this
              , a = null;
            if ("number" == typeof e)
                a = e,
                e = null;
            else {
                if ("string" == typeof e && "loaded" === o._state && !o._sprite[e])
                    return null;
                if (void 0 === e && (e = "__default",
                !o._playLock)) {
                    for (var r = 0, s = 0; s < o._sounds.length; s++)
                        o._sounds[s]._paused && !o._sounds[s]._ended && (r++,
                        a = o._sounds[s]._id);
                    1 === r ? e = null : a = null
                }
            }
            var i = a ? o._soundById(a) : o._inactiveSound();
            if (!i)
                return null;
            if (a && !e && (e = i._sprite || "__default"),
            "loaded" !== o._state) {
                i._sprite = e,
                i._ended = !1;
                var l = i._id;
                return o._queue.push({
                    event: "play",
                    action: function() {
                        o.play(l)
                    }
                }),
                l
            }
            if (a && !i._paused)
                return n || o._loadQueue("play"),
                i._id;
            o._webAudio && t._autoResume();
            var u = Math.max(0, i._seek > 0 ? i._seek : o._sprite[e][0] / 1e3)
              , c = Math.max(0, (o._sprite[e][0] + o._sprite[e][1]) / 1e3 - u)
              , d = 1e3 * c / Math.abs(i._rate)
              , p = o._sprite[e][0] / 1e3
              , f = (o._sprite[e][0] + o._sprite[e][1]) / 1e3;
            i._sprite = e,
            i._ended = !1;
            var h = function() {
                i._paused = !1,
                i._seek = u,
                i._start = p,
                i._stop = f,
                i._loop = !(!i._loop && !o._sprite[e][2])
            };
            if (!(u >= f)) {
                var v = i._node;
                if (o._webAudio) {
                    var m = function() {
                        o._playLock = !1,
                        h(),
                        o._refreshBuffer(i);
                        var e = i._muted || o._muted ? 0 : i._volume;
                        v.gain.setValueAtTime(e, t.ctx.currentTime),
                        i._playStart = t.ctx.currentTime,
                        void 0 === v.bufferSource.start ? i._loop ? v.bufferSource.noteGrainOn(0, u, 86400) : v.bufferSource.noteGrainOn(0, u, c) : i._loop ? v.bufferSource.start(0, u, 86400) : v.bufferSource.start(0, u, c),
                        d !== 1 / 0 && (o._endTimers[i._id] = setTimeout(o._ended.bind(o, i), d)),
                        n || setTimeout(function() {
                            o._emit("play", i._id),
                            o._loadQueue()
                        }, 0)
                    };
                    "running" === t.state && "interrupted" !== t.ctx.state ? m() : (o._playLock = !0,
                    o.once("resume", m),
                    o._clearTimer(i._id))
                } else {
                    var g = function() {
                        v.currentTime = u,
                        v.muted = i._muted || o._muted || t._muted || v.muted,
                        v.volume = i._volume * t.volume(),
                        v.playbackRate = i._rate;
                        try {
                            var a = v.play();
                            if (a && "undefined" != typeof Promise && (a instanceof Promise || "function" == typeof a.then) ? (o._playLock = !0,
                            h(),
                            a.then(function() {
                                o._playLock = !1,
                                v._unlocked = !0,
                                n ? o._loadQueue() : o._emit("play", i._id)
                            }).catch(function() {
                                o._playLock = !1,
                                o._emit("playerror", i._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."),
                                i._ended = !0,
                                i._paused = !0
                            })) : n || (o._playLock = !1,
                            h(),
                            o._emit("play", i._id)),
                            v.playbackRate = i._rate,
                            v.paused)
                                return void o._emit("playerror", i._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                            "__default" !== e || i._loop ? o._endTimers[i._id] = setTimeout(o._ended.bind(o, i), d) : (o._endTimers[i._id] = function() {
                                o._ended(i),
                                v.removeEventListener("ended", o._endTimers[i._id], !1)
                            }
                            ,
                            v.addEventListener("ended", o._endTimers[i._id], !1))
                        } catch (r) {
                            o._emit("playerror", i._id, r)
                        }
                    };
                    "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === v.src && (v.src = o._src,
                    v.load());
                    var y = window && window.ejecta || !v.readyState && t._navigator.isCocoonJS;
                    if (v.readyState >= 3 || y)
                        g();
                    else {
                        o._playLock = !0,
                        o._state = "loading";
                        var b = function() {
                            o._state = "loaded",
                            g(),
                            v.removeEventListener(t._canPlayEvent, b, !1)
                        };
                        v.addEventListener(t._canPlayEvent, b, !1),
                        o._clearTimer(i._id)
                    }
                }
                return i._id
            }
            o._ended(i)
        },
        pause: function(e) {
            var t = this;
            if ("loaded" !== t._state || t._playLock)
                return t._queue.push({
                    event: "pause",
                    action: function() {
                        t.pause(e)
                    }
                }),
                t;
            for (var n = t._getSoundIds(e), o = 0; o < n.length; o++) {
                t._clearTimer(n[o]);
                var a = t._soundById(n[o]);
                if (a && !a._paused && (a._seek = t.seek(n[o]),
                a._rateSeek = 0,
                a._paused = !0,
                t._stopFade(n[o]),
                a._node))
                    if (t._webAudio) {
                        if (!a._node.bufferSource)
                            continue;
                        void 0 === a._node.bufferSource.stop ? a._node.bufferSource.noteOff(0) : a._node.bufferSource.stop(0),
                        t._cleanBuffer(a._node)
                    } else
                        isNaN(a._node.duration) && a._node.duration !== 1 / 0 || a._node.pause();
                arguments[1] || t._emit("pause", a ? a._id : null)
            }
            return t
        },
        stop: function(e, t) {
            var n = this;
            if ("loaded" !== n._state || n._playLock)
                return n._queue.push({
                    event: "stop",
                    action: function() {
                        n.stop(e)
                    }
                }),
                n;
            for (var o = n._getSoundIds(e), a = 0; a < o.length; a++) {
                n._clearTimer(o[a]);
                var r = n._soundById(o[a]);
                r && (r._seek = r._start || 0,
                r._rateSeek = 0,
                r._paused = !0,
                r._ended = !0,
                n._stopFade(o[a]),
                r._node && (n._webAudio ? r._node.bufferSource && (void 0 === r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0),
                n._cleanBuffer(r._node)) : isNaN(r._node.duration) && r._node.duration !== 1 / 0 || (r._node.currentTime = r._start || 0,
                r._node.pause(),
                r._node.duration === 1 / 0 && n._clearSound(r._node))),
                t || n._emit("stop", r._id))
            }
            return n
        },
        mute: function(e, n) {
            var o = this;
            if ("loaded" !== o._state || o._playLock)
                return o._queue.push({
                    event: "mute",
                    action: function() {
                        o.mute(e, n)
                    }
                }),
                o;
            if (void 0 === n) {
                if ("boolean" != typeof e)
                    return o._muted;
                o._muted = e
            }
            for (var a = o._getSoundIds(n), r = 0; r < a.length; r++) {
                var s = o._soundById(a[r]);
                s && (s._muted = e,
                s._interval && o._stopFade(s._id),
                o._webAudio && s._node ? s._node.gain.setValueAtTime(e ? 0 : s._volume, t.ctx.currentTime) : s._node && (s._node.muted = !!t._muted || e),
                o._emit("mute", s._id))
            }
            return o
        },
        volume: function() {
            var e, n, o, a = this, r = arguments;
            if (0 === r.length)
                return a._volume;
            if (1 === r.length || 2 === r.length && void 0 === r[1] ? a._getSoundIds().indexOf(r[0]) >= 0 ? n = parseInt(r[0], 10) : e = parseFloat(r[0]) : r.length >= 2 && (e = parseFloat(r[0]),
            n = parseInt(r[1], 10)),
            !(void 0 !== e && e >= 0 && e <= 1))
                return (o = n ? a._soundById(n) : a._sounds[0]) ? o._volume : 0;
            if ("loaded" !== a._state || a._playLock)
                return a._queue.push({
                    event: "volume",
                    action: function() {
                        a.volume.apply(a, r)
                    }
                }),
                a;
            void 0 === n && (a._volume = e),
            n = a._getSoundIds(n);
            for (var s = 0; s < n.length; s++)
                (o = a._soundById(n[s])) && (o._volume = e,
                r[2] || a._stopFade(n[s]),
                a._webAudio && o._node && !o._muted ? o._node.gain.setValueAtTime(e, t.ctx.currentTime) : o._node && !o._muted && (o._node.volume = e * t.volume()),
                a._emit("volume", o._id));
            return a
        },
        fade: function(e, n, o, a) {
            var r = this;
            if ("loaded" !== r._state || r._playLock)
                return r._queue.push({
                    event: "fade",
                    action: function() {
                        r.fade(e, n, o, a)
                    }
                }),
                r;
            e = Math.min(Math.max(0, parseFloat(e)), 1),
            n = Math.min(Math.max(0, parseFloat(n)), 1),
            o = parseFloat(o),
            r.volume(e, a);
            for (var s = r._getSoundIds(a), i = 0; i < s.length; i++) {
                var l = r._soundById(s[i]);
                if (l) {
                    if (a || r._stopFade(s[i]),
                    r._webAudio && !l._muted) {
                        var u = t.ctx.currentTime
                          , c = u + o / 1e3;
                        l._volume = e,
                        l._node.gain.setValueAtTime(e, u),
                        l._node.gain.linearRampToValueAtTime(n, c)
                    }
                    r._startFadeInterval(l, e, n, o, s[i], void 0 === a)
                }
            }
            return r
        },
        _startFadeInterval: function(e, t, n, o, a, r) {
            var s = this
              , i = t
              , l = n - t
              , u = Math.abs(l / .01)
              , c = Math.max(4, u > 0 ? o / u : o)
              , d = Date.now();
            e._fadeTo = n,
            e._interval = setInterval(function() {
                var a = (Date.now() - d) / o;
                d = Date.now(),
                i += l * a,
                i = Math.round(100 * i) / 100,
                i = l < 0 ? Math.max(n, i) : Math.min(n, i),
                s._webAudio ? e._volume = i : s.volume(i, e._id, !0),
                r && (s._volume = i),
                (n < t && i <= n || n > t && i >= n) && (clearInterval(e._interval),
                e._interval = null,
                e._fadeTo = null,
                s.volume(n, e._id),
                s._emit("fade", e._id))
            }, c)
        },
        _stopFade: function(e) {
            var n = this
              , o = n._soundById(e);
            return o && o._interval && (n._webAudio && o._node.gain.cancelScheduledValues(t.ctx.currentTime),
            clearInterval(o._interval),
            o._interval = null,
            n.volume(o._fadeTo, e),
            o._fadeTo = null,
            n._emit("fade", e)),
            n
        },
        loop: function() {
            var e, t, n, o = this, a = arguments;
            if (0 === a.length)
                return o._loop;
            if (1 === a.length) {
                if ("boolean" != typeof a[0])
                    return !!(n = o._soundById(parseInt(a[0], 10))) && n._loop;
                e = a[0],
                o._loop = e
            } else
                2 === a.length && (e = a[0],
                t = parseInt(a[1], 10));
            for (var r = o._getSoundIds(t), s = 0; s < r.length; s++)
                (n = o._soundById(r[s])) && (n._loop = e,
                o._webAudio && n._node && n._node.bufferSource && (n._node.bufferSource.loop = e,
                e && (n._node.bufferSource.loopStart = n._start || 0,
                n._node.bufferSource.loopEnd = n._stop,
                o.playing(r[s]) && (o.pause(r[s], !0),
                o.play(r[s], !0)))));
            return o
        },
        rate: function() {
            var e, n, o, a = this, r = arguments;
            if (0 === r.length ? n = a._sounds[0]._id : 1 === r.length ? a._getSoundIds().indexOf(r[0]) >= 0 ? n = parseInt(r[0], 10) : e = parseFloat(r[0]) : 2 === r.length && (e = parseFloat(r[0]),
            n = parseInt(r[1], 10)),
            "number" != typeof e)
                return (o = a._soundById(n)) ? o._rate : a._rate;
            if ("loaded" !== a._state || a._playLock)
                return a._queue.push({
                    event: "rate",
                    action: function() {
                        a.rate.apply(a, r)
                    }
                }),
                a;
            void 0 === n && (a._rate = e),
            n = a._getSoundIds(n);
            for (var s = 0; s < n.length; s++)
                if (o = a._soundById(n[s])) {
                    a.playing(n[s]) && (o._rateSeek = a.seek(n[s]),
                    o._playStart = a._webAudio ? t.ctx.currentTime : o._playStart),
                    o._rate = e,
                    a._webAudio && o._node && o._node.bufferSource ? o._node.bufferSource.playbackRate.setValueAtTime(e, t.ctx.currentTime) : o._node && (o._node.playbackRate = e);
                    var i = a.seek(n[s])
                      , l = 1e3 * ((a._sprite[o._sprite][0] + a._sprite[o._sprite][1]) / 1e3 - i) / Math.abs(o._rate);
                    !a._endTimers[n[s]] && o._paused || (a._clearTimer(n[s]),
                    a._endTimers[n[s]] = setTimeout(a._ended.bind(a, o), l)),
                    a._emit("rate", o._id)
                }
            return a
        },
        seek: function() {
            var e, n, o = this, a = arguments;
            if (0 === a.length ? o._sounds.length && (n = o._sounds[0]._id) : 1 === a.length ? o._getSoundIds().indexOf(a[0]) >= 0 ? n = parseInt(a[0], 10) : o._sounds.length && (n = o._sounds[0]._id,
            e = parseFloat(a[0])) : 2 === a.length && (e = parseFloat(a[0]),
            n = parseInt(a[1], 10)),
            void 0 === n)
                return 0;
            if ("number" == typeof e && ("loaded" !== o._state || o._playLock))
                return o._queue.push({
                    event: "seek",
                    action: function() {
                        o.seek.apply(o, a)
                    }
                }),
                o;
            var r = o._soundById(n);
            if (r) {
                if (!("number" == typeof e && e >= 0)) {
                    if (o._webAudio) {
                        var s = o.playing(n) ? t.ctx.currentTime - r._playStart : 0
                          , i = r._rateSeek ? r._rateSeek - r._seek : 0;
                        return r._seek + (i + s * Math.abs(r._rate))
                    }
                    return r._node.currentTime
                }
                var l = o.playing(n);
                l && o.pause(n, !0),
                r._seek = e,
                r._ended = !1,
                o._clearTimer(n),
                o._webAudio || !r._node || isNaN(r._node.duration) || (r._node.currentTime = e);
                var u = function() {
                    l && o.play(n, !0),
                    o._emit("seek", n)
                };
                if (l && !o._webAudio) {
                    var c = function() {
                        o._playLock ? setTimeout(c, 0) : u()
                    };
                    setTimeout(c, 0)
                } else
                    u()
            }
            return o
        },
        playing: function(e) {
            var t = this;
            if ("number" == typeof e) {
                var n = t._soundById(e);
                return !!n && !n._paused
            }
            for (var o = 0; o < t._sounds.length; o++)
                if (!t._sounds[o]._paused)
                    return !0;
            return !1
        },
        duration: function(e) {
            var t = this
              , n = t._duration
              , o = t._soundById(e);
            return o && (n = t._sprite[o._sprite][1] / 1e3),
            n
        },
        state: function() {
            return this._state
        },
        unload: function() {
            for (var e = this, n = e._sounds, o = 0; o < n.length; o++)
                n[o]._paused || e.stop(n[o]._id),
                e._webAudio || (e._clearSound(n[o]._node),
                n[o]._node.removeEventListener("error", n[o]._errorFn, !1),
                n[o]._node.removeEventListener(t._canPlayEvent, n[o]._loadFn, !1),
                n[o]._node.removeEventListener("ended", n[o]._endFn, !1),
                t._releaseHtml5Audio(n[o]._node)),
                delete n[o]._node,
                e._clearTimer(n[o]._id);
            var r = t._howls.indexOf(e);
            r >= 0 && t._howls.splice(r, 1);
            var s = !0;
            for (o = 0; o < t._howls.length; o++)
                if (t._howls[o]._src === e._src || e._src.indexOf(t._howls[o]._src) >= 0) {
                    s = !1;
                    break
                }
            return a && s && delete a[e._src],
            t.noAudio = !1,
            e._state = "unloaded",
            e._sounds = [],
            e = null,
            null
        },
        on: function(e, t, n, o) {
            var a = this["_on" + e];
            return "function" == typeof t && a.push(o ? {
                id: n,
                fn: t,
                once: o
            } : {
                id: n,
                fn: t
            }),
            this
        },
        off: function(e, t, n) {
            var o = this
              , a = o["_on" + e]
              , r = 0;
            if ("number" == typeof t && (n = t,
            t = null),
            t || n)
                for (r = 0; r < a.length; r++) {
                    var s = n === a[r].id;
                    if (t === a[r].fn && s || !t && s) {
                        a.splice(r, 1);
                        break
                    }
                }
            else if (e)
                o["_on" + e] = [];
            else {
                var i = Object.keys(o);
                for (r = 0; r < i.length; r++)
                    0 === i[r].indexOf("_on") && Array.isArray(o[i[r]]) && (o[i[r]] = [])
            }
            return o
        },
        once: function(e, t, n) {
            return this.on(e, t, n, 1),
            this
        },
        _emit: function(e, t, n) {
            for (var o = this, a = o["_on" + e], r = a.length - 1; r >= 0; r--)
                a[r].id && a[r].id !== t && "load" !== e || (setTimeout(function(e) {
                    e.call(this, t, n)
                }
                .bind(o, a[r].fn), 0),
                a[r].once && o.off(e, a[r].fn, a[r].id));
            return o._loadQueue(e),
            o
        },
        _loadQueue: function(e) {
            var t = this;
            if (t._queue.length > 0) {
                var n = t._queue[0];
                n.event === e && (t._queue.shift(),
                t._loadQueue()),
                e || n.action()
            }
            return t
        },
        _ended: function(e) {
            var n = this
              , o = e._sprite;
            if (!n._webAudio && e._node && !e._node.paused && !e._node.ended && e._node.currentTime < e._stop)
                return setTimeout(n._ended.bind(n, e), 100),
                n;
            var a = !(!e._loop && !n._sprite[o][2]);
            if (n._emit("end", e._id),
            !n._webAudio && a && n.stop(e._id, !0).play(e._id),
            n._webAudio && a) {
                n._emit("play", e._id),
                e._seek = e._start || 0,
                e._rateSeek = 0,
                e._playStart = t.ctx.currentTime;
                var r = 1e3 * (e._stop - e._start) / Math.abs(e._rate);
                n._endTimers[e._id] = setTimeout(n._ended.bind(n, e), r)
            }
            return n._webAudio && !a && (e._paused = !0,
            e._ended = !0,
            e._seek = e._start || 0,
            e._rateSeek = 0,
            n._clearTimer(e._id),
            n._cleanBuffer(e._node),
            t._autoSuspend()),
            n._webAudio || a || n.stop(e._id, !0),
            n
        },
        _clearTimer: function(e) {
            var t = this;
            if (t._endTimers[e]) {
                if ("function" != typeof t._endTimers[e])
                    clearTimeout(t._endTimers[e]);
                else {
                    var n = t._soundById(e);
                    n && n._node && n._node.removeEventListener("ended", t._endTimers[e], !1)
                }
                delete t._endTimers[e]
            }
            return t
        },
        _soundById: function(e) {
            for (var t = this, n = 0; n < t._sounds.length; n++)
                if (e === t._sounds[n]._id)
                    return t._sounds[n];
            return null
        },
        _inactiveSound: function() {
            var e = this;
            e._drain();
            for (var t = 0; t < e._sounds.length; t++)
                if (e._sounds[t]._ended)
                    return e._sounds[t].reset();
            return new o(e)
        },
        _drain: function() {
            var e = this
              , t = e._pool
              , n = 0
              , o = 0;
            if (!(e._sounds.length < t)) {
                for (o = 0; o < e._sounds.length; o++)
                    e._sounds[o]._ended && n++;
                for (o = e._sounds.length - 1; o >= 0; o--) {
                    if (n <= t)
                        return;
                    e._sounds[o]._ended && (e._webAudio && e._sounds[o]._node && e._sounds[o]._node.disconnect(0),
                    e._sounds.splice(o, 1),
                    n--)
                }
            }
        },
        _getSoundIds: function(e) {
            if (void 0 === e) {
                for (var t = [], n = 0; n < this._sounds.length; n++)
                    t.push(this._sounds[n]._id);
                return t
            }
            return [e]
        },
        _refreshBuffer: function(e) {
            return e._node.bufferSource = t.ctx.createBufferSource(),
            e._node.bufferSource.buffer = a[this._src],
            e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node),
            e._node.bufferSource.loop = e._loop,
            e._loop && (e._node.bufferSource.loopStart = e._start || 0,
            e._node.bufferSource.loopEnd = e._stop || 0),
            e._node.bufferSource.playbackRate.setValueAtTime(e._rate, t.ctx.currentTime),
            this
        },
        _cleanBuffer: function(e) {
            var n = t._navigator && t._navigator.vendor.indexOf("Apple") >= 0;
            if (!e.bufferSource)
                return this;
            if (t._scratchBuffer && e.bufferSource && (e.bufferSource.onended = null,
            e.bufferSource.disconnect(0),
            n))
                try {
                    e.bufferSource.buffer = t._scratchBuffer
                } catch (pC) {}
            return e.bufferSource = null,
            this
        },
        _clearSound: function(e) {
            /MSIE |Trident\//.test(t._navigator && t._navigator.userAgent) || (e.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
        }
    };
    var o = function(e) {
        this._parent = e,
        this.init()
    };
    o.prototype = {
        init: function() {
            var e = this
              , n = e._parent;
            return e._muted = n._muted,
            e._loop = n._loop,
            e._volume = n._volume,
            e._rate = n._rate,
            e._seek = 0,
            e._paused = !0,
            e._ended = !0,
            e._sprite = "__default",
            e._id = ++t._counter,
            n._sounds.push(e),
            e.create(),
            e
        },
        create: function() {
            var e = this
              , n = e._parent
              , o = t._muted || e._muted || e._parent._muted ? 0 : e._volume;
            return n._webAudio ? (e._node = void 0 === t.ctx.createGain ? t.ctx.createGainNode() : t.ctx.createGain(),
            e._node.gain.setValueAtTime(o, t.ctx.currentTime),
            e._node.paused = !0,
            e._node.connect(t.masterGain)) : t.noAudio || (e._node = t._obtainHtml5Audio(),
            e._errorFn = e._errorListener.bind(e),
            e._node.addEventListener("error", e._errorFn, !1),
            e._loadFn = e._loadListener.bind(e),
            e._node.addEventListener(t._canPlayEvent, e._loadFn, !1),
            e._endFn = e._endListener.bind(e),
            e._node.addEventListener("ended", e._endFn, !1),
            e._node.src = n._src,
            e._node.preload = !0 === n._preload ? "auto" : n._preload,
            e._node.volume = o * t.volume(),
            e._node.load()),
            e
        },
        reset: function() {
            var e = this
              , n = e._parent;
            return e._muted = n._muted,
            e._loop = n._loop,
            e._volume = n._volume,
            e._rate = n._rate,
            e._seek = 0,
            e._rateSeek = 0,
            e._paused = !0,
            e._ended = !0,
            e._sprite = "__default",
            e._id = ++t._counter,
            e
        },
        _errorListener: function() {
            var e = this;
            e._parent._emit("loaderror", e._id, e._node.error ? e._node.error.code : 0),
            e._node.removeEventListener("error", e._errorFn, !1)
        },
        _loadListener: function() {
            var e = this
              , n = e._parent;
            n._duration = Math.ceil(10 * e._node.duration) / 10,
            0 === Object.keys(n._sprite).length && (n._sprite = {
                __default: [0, 1e3 * n._duration]
            }),
            "loaded" !== n._state && (n._state = "loaded",
            n._emit("load"),
            n._loadQueue()),
            e._node.removeEventListener(t._canPlayEvent, e._loadFn, !1)
        },
        _endListener: function() {
            var e = this
              , t = e._parent;
            t._duration === 1 / 0 && (t._duration = Math.ceil(10 * e._node.duration) / 10,
            t._sprite.__default[1] === 1 / 0 && (t._sprite.__default[1] = 1e3 * t._duration),
            t._ended(e)),
            e._node.removeEventListener("ended", e._endFn, !1)
        }
    };
    var a = {}
      , r = function(e) {
        var t = e._src;
        if (a[t])
            return e._duration = a[t].duration,
            void l(e);
        if (/^data:[^;]+;base64,/.test(t)) {
            for (var n = atob(t.split(",")[1]), o = new Uint8Array(n.length), r = 0; r < n.length; ++r)
                o[r] = n.charCodeAt(r);
            i(o.buffer, e)
        } else {
            var u = new XMLHttpRequest;
            u.open(e._xhr.method, t, !0),
            u.withCredentials = e._xhr.withCredentials,
            u.responseType = "arraybuffer",
            e._xhr.headers && Object.keys(e._xhr.headers).forEach(function(t) {
                u.setRequestHeader(t, e._xhr.headers[t])
            }),
            u.onload = function() {
                var t = (u.status + "")[0];
                "0" === t || "2" === t || "3" === t ? i(u.response, e) : e._emit("loaderror", null, "Failed loading audio file with status: " + u.status + ".")
            }
            ,
            u.onerror = function() {
                e._webAudio && (e._html5 = !0,
                e._webAudio = !1,
                e._sounds = [],
                delete a[t],
                e.load())
            }
            ,
            s(u)
        }
    }
      , s = function(e) {
        try {
            e.send()
        } catch (pC) {
            e.onerror()
        }
    }
      , i = function(e, n) {
        var o = function() {
            n._emit("loaderror", null, "Decoding audio data failed.")
        }
          , r = function(e) {
            e && n._sounds.length > 0 ? (a[n._src] = e,
            l(n, e)) : o()
        };
        "undefined" != typeof Promise && 1 === t.ctx.decodeAudioData.length ? t.ctx.decodeAudioData(e).then(r).catch(o) : t.ctx.decodeAudioData(e, r, o)
    }
      , l = function(e, t) {
        t && !e._duration && (e._duration = t.duration),
        0 === Object.keys(e._sprite).length && (e._sprite = {
            __default: [0, 1e3 * e._duration]
        }),
        "loaded" !== e._state && (e._state = "loaded",
        e._emit("load"),
        e._loadQueue())
    }
      , u = function() {
        if (t.usingWebAudio) {
            try {
                "undefined" != typeof AudioContext ? t.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? t.ctx = new webkitAudioContext : t.usingWebAudio = !1
            } catch (pC) {
                t.usingWebAudio = !1
            }
            t.ctx || (t.usingWebAudio = !1);
            var e = /iP(hone|od|ad)/.test(t._navigator && t._navigator.platform)
              , n = t._navigator && t._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)
              , o = n ? parseInt(n[1], 10) : null;
            if (e && o && o < 9) {
                var a = /safari/.test(t._navigator && t._navigator.userAgent.toLowerCase());
                t._navigator && !a && (t.usingWebAudio = !1)
            }
            t.usingWebAudio && (t.masterGain = void 0 === t.ctx.createGain ? t.ctx.createGainNode() : t.ctx.createGain(),
            t.masterGain.gain.setValueAtTime(t._muted ? 0 : t._volume, t.ctx.currentTime),
            t.masterGain.connect(t.ctx.destination)),
            t._setup()
        }
    };
    YP.Howler = t,
    YP.Howl = n,
    void 0 !== Ml ? (Ml.HowlerGlobal = e,
    Ml.Howler = t,
    Ml.Howl = n,
    Ml.Sound = o) : "undefined" != typeof window && (window.HowlerGlobal = e,
    window.Howler = t,
    window.Howl = n,
    window.Sound = o)
}(),
/*!
     *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
     *  
     *  howler.js v2.2.4
     *  howlerjs.com
     *
     *  (c) 2013-2020, James Simpson of GoldFire Studios
     *  goldfirestudios.com
     *
     *  MIT License
     */
function() {
    HowlerGlobal.prototype._pos = [0, 0, 0],
    HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0],
    HowlerGlobal.prototype.stereo = function(e) {
        var t = this;
        if (!t.ctx || !t.ctx.listener)
            return t;
        for (var n = t._howls.length - 1; n >= 0; n--)
            t._howls[n].stereo(e);
        return t
    }
    ,
    HowlerGlobal.prototype.pos = function(e, t, n) {
        var o = this;
        return o.ctx && o.ctx.listener ? (t = "number" != typeof t ? o._pos[1] : t,
        n = "number" != typeof n ? o._pos[2] : n,
        "number" != typeof e ? o._pos : (o._pos = [e, t, n],
        void 0 !== o.ctx.listener.positionX ? (o.ctx.listener.positionX.setTargetAtTime(o._pos[0], Howler.ctx.currentTime, .1),
        o.ctx.listener.positionY.setTargetAtTime(o._pos[1], Howler.ctx.currentTime, .1),
        o.ctx.listener.positionZ.setTargetAtTime(o._pos[2], Howler.ctx.currentTime, .1)) : o.ctx.listener.setPosition(o._pos[0], o._pos[1], o._pos[2]),
        o)) : o
    }
    ,
    HowlerGlobal.prototype.orientation = function(e, t, n, o, a, r) {
        var s = this;
        if (!s.ctx || !s.ctx.listener)
            return s;
        var i = s._orientation;
        return t = "number" != typeof t ? i[1] : t,
        n = "number" != typeof n ? i[2] : n,
        o = "number" != typeof o ? i[3] : o,
        a = "number" != typeof a ? i[4] : a,
        r = "number" != typeof r ? i[5] : r,
        "number" != typeof e ? i : (s._orientation = [e, t, n, o, a, r],
        void 0 !== s.ctx.listener.forwardX ? (s.ctx.listener.forwardX.setTargetAtTime(e, Howler.ctx.currentTime, .1),
        s.ctx.listener.forwardY.setTargetAtTime(t, Howler.ctx.currentTime, .1),
        s.ctx.listener.forwardZ.setTargetAtTime(n, Howler.ctx.currentTime, .1),
        s.ctx.listener.upX.setTargetAtTime(o, Howler.ctx.currentTime, .1),
        s.ctx.listener.upY.setTargetAtTime(a, Howler.ctx.currentTime, .1),
        s.ctx.listener.upZ.setTargetAtTime(r, Howler.ctx.currentTime, .1)) : s.ctx.listener.setOrientation(e, t, n, o, a, r),
        s)
    }
    ,
    Howl.prototype.init = function(e) {
        return function(t) {
            var n = this;
            return n._orientation = t.orientation || [1, 0, 0],
            n._stereo = t.stereo || null,
            n._pos = t.pos || null,
            n._pannerAttr = {
                coneInnerAngle: void 0 !== t.coneInnerAngle ? t.coneInnerAngle : 360,
                coneOuterAngle: void 0 !== t.coneOuterAngle ? t.coneOuterAngle : 360,
                coneOuterGain: void 0 !== t.coneOuterGain ? t.coneOuterGain : 0,
                distanceModel: void 0 !== t.distanceModel ? t.distanceModel : "inverse",
                maxDistance: void 0 !== t.maxDistance ? t.maxDistance : 1e4,
                panningModel: void 0 !== t.panningModel ? t.panningModel : "HRTF",
                refDistance: void 0 !== t.refDistance ? t.refDistance : 1,
                rolloffFactor: void 0 !== t.rolloffFactor ? t.rolloffFactor : 1
            },
            n._onstereo = t.onstereo ? [{
                fn: t.onstereo
            }] : [],
            n._onpos = t.onpos ? [{
                fn: t.onpos
            }] : [],
            n._onorientation = t.onorientation ? [{
                fn: t.onorientation
            }] : [],
            e.call(this, t)
        }
    }(Howl.prototype.init),
    Howl.prototype.stereo = function(t, n) {
        var o = this;
        if (!o._webAudio)
            return o;
        if ("loaded" !== o._state)
            return o._queue.push({
                event: "stereo",
                action: function() {
                    o.stereo(t, n)
                }
            }),
            o;
        var a = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
        if (void 0 === n) {
            if ("number" != typeof t)
                return o._stereo;
            o._stereo = t,
            o._pos = [t, 0, 0]
        }
        for (var r = o._getSoundIds(n), s = 0; s < r.length; s++) {
            var i = o._soundById(r[s]);
            if (i) {
                if ("number" != typeof t)
                    return i._stereo;
                i._stereo = t,
                i._pos = [t, 0, 0],
                i._node && (i._pannerAttr.panningModel = "equalpower",
                i._panner && i._panner.pan || e(i, a),
                "spatial" === a ? void 0 !== i._panner.positionX ? (i._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime),
                i._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime),
                i._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : i._panner.setPosition(t, 0, 0) : i._panner.pan.setValueAtTime(t, Howler.ctx.currentTime)),
                o._emit("stereo", i._id)
            }
        }
        return o
    }
    ,
    Howl.prototype.pos = function(t, n, o, a) {
        var r = this;
        if (!r._webAudio)
            return r;
        if ("loaded" !== r._state)
            return r._queue.push({
                event: "pos",
                action: function() {
                    r.pos(t, n, o, a)
                }
            }),
            r;
        if (n = "number" != typeof n ? 0 : n,
        o = "number" != typeof o ? -.5 : o,
        void 0 === a) {
            if ("number" != typeof t)
                return r._pos;
            r._pos = [t, n, o]
        }
        for (var s = r._getSoundIds(a), i = 0; i < s.length; i++) {
            var l = r._soundById(s[i]);
            if (l) {
                if ("number" != typeof t)
                    return l._pos;
                l._pos = [t, n, o],
                l._node && (l._panner && !l._panner.pan || e(l, "spatial"),
                void 0 !== l._panner.positionX ? (l._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime),
                l._panner.positionY.setValueAtTime(n, Howler.ctx.currentTime),
                l._panner.positionZ.setValueAtTime(o, Howler.ctx.currentTime)) : l._panner.setPosition(t, n, o)),
                r._emit("pos", l._id)
            }
        }
        return r
    }
    ,
    Howl.prototype.orientation = function(t, n, o, a) {
        var r = this;
        if (!r._webAudio)
            return r;
        if ("loaded" !== r._state)
            return r._queue.push({
                event: "orientation",
                action: function() {
                    r.orientation(t, n, o, a)
                }
            }),
            r;
        if (n = "number" != typeof n ? r._orientation[1] : n,
        o = "number" != typeof o ? r._orientation[2] : o,
        void 0 === a) {
            if ("number" != typeof t)
                return r._orientation;
            r._orientation = [t, n, o]
        }
        for (var s = r._getSoundIds(a), i = 0; i < s.length; i++) {
            var l = r._soundById(s[i]);
            if (l) {
                if ("number" != typeof t)
                    return l._orientation;
                l._orientation = [t, n, o],
                l._node && (l._panner || (l._pos || (l._pos = r._pos || [0, 0, -.5]),
                e(l, "spatial")),
                void 0 !== l._panner.orientationX ? (l._panner.orientationX.setValueAtTime(t, Howler.ctx.currentTime),
                l._panner.orientationY.setValueAtTime(n, Howler.ctx.currentTime),
                l._panner.orientationZ.setValueAtTime(o, Howler.ctx.currentTime)) : l._panner.setOrientation(t, n, o)),
                r._emit("orientation", l._id)
            }
        }
        return r
    }
    ,
    Howl.prototype.pannerAttr = function() {
        var t, n, o, a = this, r = arguments;
        if (!a._webAudio)
            return a;
        if (0 === r.length)
            return a._pannerAttr;
        if (1 === r.length) {
            if ("object" != typeof r[0])
                return (o = a._soundById(parseInt(r[0], 10))) ? o._pannerAttr : a._pannerAttr;
            t = r[0],
            void 0 === n && (t.pannerAttr || (t.pannerAttr = {
                coneInnerAngle: t.coneInnerAngle,
                coneOuterAngle: t.coneOuterAngle,
                coneOuterGain: t.coneOuterGain,
                distanceModel: t.distanceModel,
                maxDistance: t.maxDistance,
                refDistance: t.refDistance,
                rolloffFactor: t.rolloffFactor,
                panningModel: t.panningModel
            }),
            a._pannerAttr = {
                coneInnerAngle: void 0 !== t.pannerAttr.coneInnerAngle ? t.pannerAttr.coneInnerAngle : a._coneInnerAngle,
                coneOuterAngle: void 0 !== t.pannerAttr.coneOuterAngle ? t.pannerAttr.coneOuterAngle : a._coneOuterAngle,
                coneOuterGain: void 0 !== t.pannerAttr.coneOuterGain ? t.pannerAttr.coneOuterGain : a._coneOuterGain,
                distanceModel: void 0 !== t.pannerAttr.distanceModel ? t.pannerAttr.distanceModel : a._distanceModel,
                maxDistance: void 0 !== t.pannerAttr.maxDistance ? t.pannerAttr.maxDistance : a._maxDistance,
                refDistance: void 0 !== t.pannerAttr.refDistance ? t.pannerAttr.refDistance : a._refDistance,
                rolloffFactor: void 0 !== t.pannerAttr.rolloffFactor ? t.pannerAttr.rolloffFactor : a._rolloffFactor,
                panningModel: void 0 !== t.pannerAttr.panningModel ? t.pannerAttr.panningModel : a._panningModel
            })
        } else
            2 === r.length && (t = r[0],
            n = parseInt(r[1], 10));
        for (var s = a._getSoundIds(n), i = 0; i < s.length; i++)
            if (o = a._soundById(s[i])) {
                var l = o._pannerAttr;
                l = {
                    coneInnerAngle: void 0 !== t.coneInnerAngle ? t.coneInnerAngle : l.coneInnerAngle,
                    coneOuterAngle: void 0 !== t.coneOuterAngle ? t.coneOuterAngle : l.coneOuterAngle,
                    coneOuterGain: void 0 !== t.coneOuterGain ? t.coneOuterGain : l.coneOuterGain,
                    distanceModel: void 0 !== t.distanceModel ? t.distanceModel : l.distanceModel,
                    maxDistance: void 0 !== t.maxDistance ? t.maxDistance : l.maxDistance,
                    refDistance: void 0 !== t.refDistance ? t.refDistance : l.refDistance,
                    rolloffFactor: void 0 !== t.rolloffFactor ? t.rolloffFactor : l.rolloffFactor,
                    panningModel: void 0 !== t.panningModel ? t.panningModel : l.panningModel
                };
                var u = o._panner;
                u || (o._pos || (o._pos = a._pos || [0, 0, -.5]),
                e(o, "spatial"),
                u = o._panner),
                u.coneInnerAngle = l.coneInnerAngle,
                u.coneOuterAngle = l.coneOuterAngle,
                u.coneOuterGain = l.coneOuterGain,
                u.distanceModel = l.distanceModel,
                u.maxDistance = l.maxDistance,
                u.refDistance = l.refDistance,
                u.rolloffFactor = l.rolloffFactor,
                u.panningModel = l.panningModel
            }
        return a
    }
    ,
    Sound.prototype.init = function(e) {
        return function() {
            var t = this
              , n = t._parent;
            t._orientation = n._orientation,
            t._stereo = n._stereo,
            t._pos = n._pos,
            t._pannerAttr = n._pannerAttr,
            e.call(this),
            t._stereo ? n.stereo(t._stereo) : t._pos && n.pos(t._pos[0], t._pos[1], t._pos[2], t._id)
        }
    }(Sound.prototype.init),
    Sound.prototype.reset = function(e) {
        return function() {
            var t = this
              , n = t._parent;
            return t._orientation = n._orientation,
            t._stereo = n._stereo,
            t._pos = n._pos,
            t._pannerAttr = n._pannerAttr,
            t._stereo ? n.stereo(t._stereo) : t._pos ? n.pos(t._pos[0], t._pos[1], t._pos[2], t._id) : t._panner && (t._panner.disconnect(0),
            t._panner = void 0,
            n._refreshBuffer(t)),
            e.call(this)
        }
    }(Sound.prototype.reset);
    var e = function(e, t) {
        "spatial" === (t = t || "spatial") ? (e._panner = Howler.ctx.createPanner(),
        e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle,
        e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle,
        e._panner.coneOuterGain = e._pannerAttr.coneOuterGain,
        e._panner.distanceModel = e._pannerAttr.distanceModel,
        e._panner.maxDistance = e._pannerAttr.maxDistance,
        e._panner.refDistance = e._pannerAttr.refDistance,
        e._panner.rolloffFactor = e._pannerAttr.rolloffFactor,
        e._panner.panningModel = e._pannerAttr.panningModel,
        void 0 !== e._panner.positionX ? (e._panner.positionX.setValueAtTime(e._pos[0], Howler.ctx.currentTime),
        e._panner.positionY.setValueAtTime(e._pos[1], Howler.ctx.currentTime),
        e._panner.positionZ.setValueAtTime(e._pos[2], Howler.ctx.currentTime)) : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]),
        void 0 !== e._panner.orientationX ? (e._panner.orientationX.setValueAtTime(e._orientation[0], Howler.ctx.currentTime),
        e._panner.orientationY.setValueAtTime(e._orientation[1], Howler.ctx.currentTime),
        e._panner.orientationZ.setValueAtTime(e._orientation[2], Howler.ctx.currentTime)) : e._panner.setOrientation(e._orientation[0], e._orientation[1], e._orientation[2])) : (e._panner = Howler.ctx.createStereoPanner(),
        e._panner.pan.setValueAtTime(e._stereo, Howler.ctx.currentTime)),
        e._panner.connect(e._node),
        e._paused || e._parent.pause(e._id, !0).play(e._id, !0)
    }
}()),
KP);
const JP = {
    class: "flex flex-col items-center gap-4"
}
  , QP = {
    class: "grid grid-cols-3 gap-3 w-full sm:w-fit max-w-[90vw] sm:max-w-md relative bg-secondary rounded-lg border-2 border-t-0 shadow-sm p-1.5 border-surface overflow-hidden aspect-square animate-flip-horizontal-top"
}
  , eB = ["src"]
  , tB = {
    class: "flex sm:flex-row items-center gap-2 w-full sm:max-w-md overflow-x-auto sm:overflow-x-visible pb-2 sm:pb-0"
}
  , nB = to({
    __name: "ScratchCard",
    props: {
        name: {},
        amount: {},
        max_reward: {},
        slug: {},
        banner: {}
    },
    setup(e) {
        const t = new XP.Howl({
            src: ["/sons/win.mp3"]
        })
          , n = new XP.Howl({
            src: ["/sons/loss.wav"]
        })
          , o = Bk()
          , a = e
          , r = String(o.params.slug)
          , s = QC()
          , i = dm()
          , l = It(!1)
          , u = It(null)
          , c = ms( () => l.value ? 14 : 3)
          , d = It(!1)
          , p = It([])
          , f = It(null)
          , h = It(!1)
          , v = It(!1)
          , {scratchAll: m, reset: g} = WP(u, {
            imageForwardSrc: "https://ik.imagekit.io/azx3nlpdu/TELA%202.png?updatedAt=1751849389437",
            percentToFinish: 70,
            callback: () => {
                h.value = !0,
                v.value = !1,
                s.fetchWallet()
            }
        });
        function y() {
            v.value = !0,
            m(c.value)
        }
        function b() {
            d.value = !1,
            p.value = [],
            f.value = null,
            h.value = !1,
            v.value = !1,
            g()
        }
        const w = ms( () => s.authenticated ? d.value && h.value ? f.value ? "success" : "failure" : "buy" : "unauthenticated");
        async function _() {
            var e;
            if (s.authenticated) {
                if (!d.value) {
                    f.value = null,
                    h.value = !1;
                    try {
                        const {data: e} = await b_.post(`/scratch/${r}/buy`)
                          , t = e.data;
                        p.value = t.grid,
                        f.value = t.prize ?? null,
                        d.value = !0
                    } catch (t) {
                        let n = "No foi comprar a raspadinha.";
                        t instanceof o_ && t.response && (n = (null == (e = t.response.data) ? void 0 : e.message) ?? n),
                        S_.error(n)
                    }
                }
            } else
                i.open("login")
        }
        return Qa(w, e => {
            "success" === e && t.play(),
            "failure" === e && n.play()
        }
        ),
        (e, t) => {
            const n = HP
              , o = Qv
              , r = EM
              , c = BP
              , m = PP;
            return Tr(),
            Br("div", JP, [Dr("div", QP, [(Tr(),
            Br(_r, null, qo(9, e => Dr("div", {
                key: e,
                class: K(["sm:size-33 size-24 flex items-center justify-center rounded-lg shadow group border-2 border-muted-foreground/20", {
                    "border-2 !border-green-500": h.value && d.value && p.value[e - 1] && f.value && p.value[e - 1].image === f.value.image
                }])
            }, [d.value && p.value[e - 1] ? (Tr(),
            Br("img", {
                key: 0,
                src: p.value[e - 1].image,
                class: "w-full h-full p-3.5 object-contain",
                alt: "prmio"
            }, null, 8, eB)) : Ur("", !0)], 2)), 64)), !d.value || h.value ? (Tr(),
            Ir(n, {
                key: 0,
                state: w.value,
                amount: a.amount,
                prize: f.value,
                onLogin: t[0] || (t[0] = e => Nt(i).open("login")),
                onBuy: _,
                onRetry: b
            }, null, 8, ["state", "amount", "prize"])) : Ur("", !0), Dr("div", {
                ref_key: "containerRef",
                ref: u,
                class: "sc__container absolute inset-0 rounded-lg"
            }, null, 512)]), Dr("div", tB, [d.value ? Ur("", !0) : (Tr(),
            Br(_r, {
                key: 0
            }, [Nt(s).authenticated ? (Tr(),
            Ir(r, {
                key: 1,
                class: "flex-1 cursor-pointer",
                value: a.amount,
                onClick: _
            }, {
                default: En( () => [jr(Nt(sm).CoinVertical, {
                    class: "size-5"
                }), t[4] || (t[4] = Vr(" Comprar "))]),
                _: 1,
                __: [4]
            }, 8, ["value"])) : (Tr(),
            Ir(o, {
                key: 0,
                class: "flex-1 cursor-pointer",
                onClick: t[1] || (t[1] = e => Nt(i).open("login"))
            }, {
                default: En( () => [jr(Nt(sm).UserPlus, {
                    class: "size-5"
                }), t[3] || (t[3] = Vr(" Registrar "))]),
                _: 1,
                __: [3]
            }))], 64)), d.value && !h.value ? (Tr(),
            Ir(o, {
                key: 1,
                class: "flex-1 cursor-pointer",
                onClick: y,
                disabled: v.value
            }, {
                default: En( () => [jr(Nt(sm).CoinVertical, {
                    class: "size-5"
                }), t[5] || (t[5] = Vr(" Revelar Tudo "))]),
                _: 1,
                __: [5]
            }, 8, ["disabled"])) : Ur("", !0), d.value && h.value ? (Tr(),
            Ir(o, {
                key: 2,
                class: "flex-1 cursor-pointer",
                onClick: b
            }, {
                default: En( () => t[6] || (t[6] = [Vr("Jogar Novamente")])),
                _: 1,
                __: [6]
            })) : Ur("", !0), jr(c, {
                modelValue: l.value,
                "onUpdate:modelValue": t[2] || (t[2] = e => l.value = e)
            }, {
                default: En( () => [jr(Nt(sm).Thunder, {
                    class: "size-5"
                })]),
                _: 1
            }, 8, ["modelValue"]), jr(m, {
                class: "flex-1"
            })])])
        }
    }
})
  , oB = {
    class: "flex flex-col sm:flex-row sm:items-stretch justify-center gap-4 mb-8 animate-pulse"
}
  , aB = {
    class: "flex flex-col items-center gap-4"
}
  , rB = {
    class: "grid grid-cols-3 gap-3 w-full sm:w-fit max-w-[90vw] sm:max-w-md relative rounded-lg p-1.5 overflow-hidden aspect-square"
}
  , sB = {
    class: "flex sm:flex-row items-center gap-3 w-full sm:max-w-md overflow-x-auto sm:overflow-x-visible pb-2 sm:pb-0"
}
  , iB = {
    class: "flex flex-1 flex-col gap-4"
}
  , lB = {
    class: "flex overflow-x-auto gap-2 pb-2 sm:grid sm:grid-cols-8 sm:overflow-x-visible"
};
const uB = gE({}, [["render", function(e, t) {
    const n = EO;
    return Tr(),
    Br(_r, null, [Dr("div", oB, [Dr("div", aB, [Dr("section", rB, [(Tr(),
    Br(_r, null, qo(9, e => jr(n, {
        key: e,
        class: "sm:size-33 size-24 border rounded-lg flex items-center justify-center shadow group bg-secondary"
    })), 64))]), Dr("section", sB, [jr(n, {
        class: "px-2.5 h-11 flex-1 rounded-lg bg-secondary"
    }), jr(n, {
        class: "px-2.5 w-11 h-11 rounded-lg bg-secondary"
    }), jr(n, {
        class: "px-2.5 w-35 h-11 rounded-lg bg-secondary"
    })])]), Dr("div", iB, [jr(n, {
        class: "h-33 rounded-lg bg-secondary"
    }), jr(n, {
        class: "h-54 rounded-lg bg-secondary"
    }), jr(n, {
        class: "h-29 rounded-lg bg-secondary"
    })])]), jr(n, {
        class: "h-6 w-108 my-6 rounded-lg bg-secondary"
    }), Dr("div", lB, [(Tr(),
    Br(_r, null, qo(16, e => jr(n, {
        key: e,
        class: "flex-shrink-0 h-38 aspect-square w-38 rounded-lg bg-secondary"
    })), 64))])], 64)
}
]])
  , cB = {
    class: "flex flex-col sm:flex-row sm:items-stretch justify-center gap-4 mb-8"
}
  , dB = to({
    __name: "Scratch",
    setup(e) {
        const t = It(!1)
          , n = It(!1)
          , o = It()
          , a = Bk()
          , r = String(a.params.slug);
        return Mo(async function() {
            try {
                t.value = !0,
                n.value = !1;
                const {data: e} = await b_.get(`/scratch/${r}`);
                o.value = e.data
            } catch (e) {
                n.value = !0
            } finally {
                t.value = !1
            }
        }),
        (e, n) => {
            var a;
            const r = zO
              , s = nB
              , i = MP
              , l = yP;
            return t.value ? (Tr(),
            Ir(uB, {
                key: 0
            })) : (Tr(),
            Br(_r, {
                key: 1
            }, [jr(r, {
                class: "mb-4 sm:mb-8"
            }), Dr("div", cB, [jr(s, Y(Fr(o.value)), null, 16), jr(i, Y(Fr(o.value)), null, 16)]), jr(l, {
                items: null == (a = o.value) ? void 0 : a.rewards
            }, null, 8, ["items"])], 64))
        }
    }
})
  , pB = {
    class: "not-found-page py-38 pb-80 text-center"
}
  , fB = to({
    __name: "NotFound",
    setup: e => (e, t) => {
        const n = Qv
          , o = Fo("RouterLink");
        return Tr(),
        Br("div", pB, [t[1] || (t[1] = Dr("img", {
            src: "/assets/not_found-DQ9VemuE.webp",
            class: "not-found__img mx-auto mb-10 size-60 drop-shadow-xl drop-shadow-primary/7"
        }, null, -1)), t[2] || (t[2] = Dr("h1", {
            class: "not-found__heading text-2xl font-medium text-center mb-4"
        }, " Pgina no encontrada ", -1)), jr(o, {
            to: "/",
            class: "text-primary font-medium"
        }, {
            default: En( () => [jr(n, null, {
                default: En( () => [jr(Nt(sm).Home), t[0] || (t[0] = Vr(" Ir para pgina inicial"))]),
                _: 1,
                __: [0]
            })]),
            _: 1
        })])
    }
})
  , hB = function(e) {
    const t = sk(e.routes, e)
      , n = e.parseQuery || hk
      , o = e.stringifyQuery || vk
      , a = e.history
      , r = xk()
      , s = xk()
      , i = xk()
      , l = Lt(Mx);
    let u = Mx;
    J_ && e.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
    const c = tx.bind(null, e => "" + e)
      , d = tx.bind(null, _x)
      , p = tx.bind(null, xx);
    function f(e, r) {
        if (r = ex({}, r || l.value),
        "string" == typeof e) {
            const o = Sx(n, e, r.path)
              , s = t.resolve({
                path: o.path
            }, r)
              , i = a.createHref(o.fullPath);
            return ex(o, s, {
                params: p(s.params),
                hash: xx(o.hash),
                redirectedFrom: void 0,
                href: i
            })
        }
        let s;
        if (null != e.path)
            s = ex({}, e, {
                path: Sx(n, e.path, r.path).path
            });
        else {
            const t = ex({}, e.params);
            for (const e in t)
                null == t[e] && delete t[e];
            s = ex({}, e, {
                params: d(t)
            }),
            r.params = d(r.params)
        }
        const i = t.resolve(s, r)
          , u = e.hash || "";
        i.params = c(p(i.params));
        const f = function(e, t) {
            const n = t.query ? e(t.query) : "";
            return t.path + (n && "?") + n + (t.hash || "")
        }(o, ex({}, e, {
            hash: (h = u,
            yx(h).replace(hx, "{").replace(mx, "}").replace(px, "^")),
            path: i.path
        }));
        var h;
        const v = a.createHref(f);
        return ex({
            fullPath: f,
            hash: u,
            query: o === vk ? mk(e.query) : e.query || {}
        }, i, {
            redirectedFrom: void 0,
            href: v
        })
    }
    function h(e) {
        return "string" == typeof e ? Sx(n, e, l.value.path) : ex({}, e)
    }
    function v(e, t) {
        if (u !== e)
            return Kx(8, {
                from: t,
                to: e
            })
    }
    function m(e) {
        return y(e)
    }
    function g(e) {
        const t = e.matched[e.matched.length - 1];
        if (t && t.redirect) {
            const {redirect: n} = t;
            let o = "function" == typeof n ? n(e) : n;
            return "string" == typeof o && (o = o.includes("?") || o.includes("#") ? o = h(o) : {
                path: o
            },
            o.params = {}),
            ex({
                query: e.query,
                hash: e.hash,
                params: null != o.path ? {} : e.params
            }, o)
        }
    }
    function y(e, t) {
        const n = u = f(e)
          , a = l.value
          , r = e.state
          , s = e.force
          , i = !0 === e.replace
          , c = g(n);
        if (c)
            return y(ex(h(c), {
                state: "object" == typeof c ? ex({}, r, c.state) : r,
                force: s,
                replace: i
            }), t || n);
        const d = n;
        let p;
        return d.redirectedFrom = t,
        !s && function(e, t, n) {
            const o = t.matched.length - 1
              , a = n.matched.length - 1;
            return o > -1 && o === a && Ex(t.matched[o], n.matched[a]) && Tx(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash
        }(o, a, n) && (p = Kx(16, {
            to: d,
            from: a
        }),
        P(a, a, !0, !1)),
        (p ? Promise.resolve(p) : _(d, a)).catch(e => Yx(e) ? Yx(e, 2) ? e : M(e) : O(e, d, a)).then(e => {
            if (e) {
                if (Yx(e, 2))
                    return y(ex({
                        replace: i
                    }, h(e.to), {
                        state: "object" == typeof e.to ? ex({}, r, e.to.state) : r,
                        force: s
                    }), t || d)
            } else
                e = k(d, a, !0, i, r);
            return x(d, a, e),
            e
        }
        )
    }
    function b(e, t) {
        const n = v(e, t);
        return n ? Promise.reject(n) : Promise.resolve()
    }
    function w(e) {
        const t = L.values().next().value;
        return t && "function" == typeof t.runWithContext ? t.runWithContext(e) : e()
    }
    function _(e, t) {
        let n;
        const [o,a,i] = function(e, t) {
            const n = []
              , o = []
              , a = []
              , r = Math.max(t.matched.length, e.matched.length);
            for (let s = 0; s < r; s++) {
                const r = t.matched[s];
                r && (e.matched.find(e => Ex(e, r)) ? o.push(r) : n.push(r));
                const i = e.matched[s];
                i && (t.matched.find(e => Ex(e, i)) || a.push(i))
            }
            return [n, o, a]
        }(e, t);
        n = Sk(o.reverse(), "beforeRouteLeave", e, t);
        for (const r of o)
            r.leaveGuards.forEach(o => {
                n.push(kk(o, e, t))
            }
            );
        const l = b.bind(null, e, t);
        return n.push(l),
        z(n).then( () => {
            n = [];
            for (const o of r.list())
                n.push(kk(o, e, t));
            return n.push(l),
            z(n)
        }
        ).then( () => {
            n = Sk(a, "beforeRouteUpdate", e, t);
            for (const o of a)
                o.updateGuards.forEach(o => {
                    n.push(kk(o, e, t))
                }
                );
            return n.push(l),
            z(n)
        }
        ).then( () => {
            n = [];
            for (const o of i)
                if (o.beforeEnter)
                    if (ox(o.beforeEnter))
                        for (const a of o.beforeEnter)
                            n.push(kk(a, e, t));
                    else
                        n.push(kk(o.beforeEnter, e, t));
            return n.push(l),
            z(n)
        }
        ).then( () => (e.matched.forEach(e => e.enterCallbacks = {}),
        n = Sk(i, "beforeRouteEnter", e, t, w),
        n.push(l),
        z(n))).then( () => {
            n = [];
            for (const o of s.list())
                n.push(kk(o, e, t));
            return n.push(l),
            z(n)
        }
        ).catch(e => Yx(e, 8) ? e : Promise.reject(e))
    }
    function x(e, t, n) {
        i.list().forEach(o => w( () => o(e, t, n)))
    }
    function k(e, t, n, o, r) {
        const s = v(e, t);
        if (s)
            return s;
        const i = t === Mx
          , u = J_ ? history.state : {};
        n && (o || i ? a.replace(e.fullPath, ex({
            scroll: i && u && u.scroll
        }, r)) : a.push(e.fullPath, r)),
        l.value = e,
        P(e, t, n, i),
        M()
    }
    let S;
    function C() {
        S || (S = a.listen( (e, t, n) => {
            if (!R.listening)
                return;
            const o = f(e)
              , r = g(o);
            if (r)
                return void y(ex(r, {
                    replace: !0,
                    force: !0
                }), o).catch(nx);
            u = o;
            const s = l.value;
            var i, c;
            J_ && (i = Fx(s.fullPath, n.delta),
            c = Dx(),
            $x.set(i, c)),
            _(o, s).catch(e => Yx(e, 12) ? e : Yx(e, 2) ? (y(ex(h(e.to), {
                force: !0
            }), o).then(e => {
                Yx(e, 20) && !n.delta && n.type === Px.pop && a.go(-1, !1)
            }
            ).catch(nx),
            Promise.reject()) : (n.delta && a.go(-n.delta, !1),
            O(e, o, s))).then(e => {
                (e = e || k(o, s, !1)) && (n.delta && !Yx(e, 8) ? a.go(-n.delta, !1) : n.type === Px.pop && Yx(e, 20) && a.go(-1, !1)),
                x(o, s, e)
            }
            ).catch(nx)
        }
        ))
    }
    let E, T = xk(), A = xk();
    function O(e, t, n) {
        M(e);
        const o = A.list();
        return o.length && o.forEach(o => o(e, t, n)),
        Promise.reject(e)
    }
    function M(e) {
        return E || (E = !e,
        C(),
        T.list().forEach( ([t,n]) => e ? n(e) : t()),
        T.reset()),
        e
    }
    function P(t, n, o, a) {
        const {scrollBehavior: r} = e;
        if (!J_ || !r)
            return Promise.resolve();
        const s = !o && function(e) {
            const t = $x.get(e);
            return $x.delete(e),
            t
        }(Fx(t.fullPath, 0)) || (a || !o) && history.state && history.state.scroll || null;
        return fn().then( () => r(t, n, s)).then(e => e && jx(e)).catch(e => O(e, t, n))
    }
    const B = e => a.go(e);
    let I;
    const L = new Set
      , R = {
        currentRoute: l,
        listening: !0,
        addRoute: function(e, n) {
            let o, a;
            return Zx(e) ? (o = t.getRecordMatcher(e),
            a = n) : a = e,
            t.addRoute(a, o)
        },
        removeRoute: function(e) {
            const n = t.getRecordMatcher(e);
            n && t.removeRoute(n)
        },
        clearRoutes: t.clearRoutes,
        hasRoute: function(e) {
            return !!t.getRecordMatcher(e)
        },
        getRoutes: function() {
            return t.getRoutes().map(e => e.record)
        },
        resolve: f,
        options: e,
        push: m,
        replace: function(e) {
            return m(ex(h(e), {
                replace: !0
            }))
        },
        go: B,
        back: () => B(-1),
        forward: () => B(1),
        beforeEach: r.add,
        beforeResolve: s.add,
        afterEach: i.add,
        onError: A.add,
        isReady: function() {
            return E && l.value !== Mx ? Promise.resolve() : new Promise( (e, t) => {
                T.add([e, t])
            }
            )
        },
        install(e) {
            e.component("RouterLink", Ek),
            e.component("RouterView", Mk),
            e.config.globalProperties.$router = this,
            Object.defineProperty(e.config.globalProperties, "$route", {
                enumerable: !0,
                get: () => Nt(l)
            }),
            J_ && !I && l.value === Mx && (I = !0,
            m(a.location).catch(e => {}
            ));
            const t = {};
            for (const o in Mx)
                Object.defineProperty(t, o, {
                    get: () => l.value[o],
                    enumerable: !0
                });
            e.provide(bk, this),
            e.provide(wk, wt(t)),
            e.provide(_k, l);
            const n = e.unmount;
            L.add(e),
            e.unmount = function() {
                L.delete(e),
                L.size < 1 && (u = Mx,
                S && S(),
                S = null,
                l.value = Mx,
                I = !1,
                E = !1),
                n()
            }
        }
    };
    function z(e) {
        return e.reduce( (e, t) => e.then( () => w(t)), Promise.resolve())
    }
    return R
}({
    history: function(e) {
        const t = Ux(e = Rx(e))
          , n = function(e, t, n, o) {
            let a = []
              , r = []
              , s = null;
            const i = ({state: r}) => {
                const i = Vx(e, location)
                  , l = n.value
                  , u = t.value;
                let c = 0;
                if (r) {
                    if (n.value = i,
                    t.value = r,
                    s && s === l)
                        return void (s = null);
                    c = u ? r.position - u.position : 0
                } else
                    o(i);
                a.forEach(e => {
                    e(n.value, l, {
                        delta: c,
                        type: Px.pop,
                        direction: c ? c > 0 ? Ix.forward : Ix.back : Ix.unknown
                    })
                }
                )
            }
            ;
            function l() {
                const {history: e} = window;
                e.state && e.replaceState(ex({}, e.state, {
                    scroll: Dx()
                }), "")
            }
            return window.addEventListener("popstate", i),
            window.addEventListener("beforeunload", l, {
                passive: !0
            }),
            {
                pauseListeners: function() {
                    s = n.value
                },
                listen: function(e) {
                    a.push(e);
                    const t = () => {
                        const t = a.indexOf(e);
                        t > -1 && a.splice(t, 1)
                    }
                    ;
                    return r.push(t),
                    t
                },
                destroy: function() {
                    for (const e of r)
                        e();
                    r = [],
                    window.removeEventListener("popstate", i),
                    window.removeEventListener("beforeunload", l)
                }
            }
        }(e, t.state, t.location, t.replace)
          , o = ex({
            location: "",
            base: e,
            go: function(e, t=!0) {
                t || n.pauseListeners(),
                history.go(e)
            },
            createHref: Nx.bind(null, e)
        }, t, n);
        return Object.defineProperty(o, "location", {
            enumerable: !0,
            get: () => t.location.value
        }),
        Object.defineProperty(o, "state", {
            enumerable: !0,
            get: () => t.state.value
        }),
        o
    }("/"),
    routes: [{
        path: "/",
        component: aM
    }, {
        path: "/raspadinhas/:slug",
        component: dB
    }, {
        path: "/raspadinha",
        component: VM
    }, {
        path: "/indique",
        component: dP
    }, {
        path: "/perfil",
        name: "Perfil",
        component: xM,
        meta: {
            breadcrumb: "Perfil"
        },
        children: [{
            path: "conta",
            name: "PerfilConta",
            component: () => CO( () => import("./Me-r-aNqxMz.js"), []),
            meta: {
                breadcrumb: "Conta"
            }
        }, {
            path: "historico",
            name: "PerfilHistorico",
            component: () => CO( () => import("./GameHistory-nsTNtFhK.js"), __vite__mapDeps([0, 1])),
            meta: {
                breadcrumb: "Histrico"
            }
        }, {
            path: "transacoes",
            name: "PerfilTransacoes",
            component: () => CO( () => import("./Transactions-BCcXX4AG.js"), __vite__mapDeps([2, 1])),
            meta: {
                breadcrumb: "Transaes"
            }
        }, {
            path: "entregas",
            name: "PerfilEntregas",
            component: () => CO( () => import("./Deliveries-CGT7eCcn.js"), __vite__mapDeps([3, 1])),
            meta: {
                breadcrumb: "Entregas"
            }
        }, {
            path: "seguranca",
            name: "PerfilSeguranca",
            component: () => CO( () => import("./Security-BQh_u6c6.js"), []),
            meta: {
                breadcrumb: "Segurana"
            }
        }]
    }, {
        path: "/r/:code",
        redirect: e => {
            const t = e.params.code;
            return localStorage.setItem("referralCode", t),
            "/"
        }
    }, {
        path: "/:pathMatch(.*)*",
        name: "NotFound",
        component: fB
    }]
})
  , vB = rl(kO);
vB.use(function() {
    const e = le(!0)
      , t = e.run( () => It({}));
    let n = []
      , o = [];
    const a = Ot({
        install(e) {
            pl(a),
            a._a = e,
            e.provide(fl, a),
            e.config.globalProperties.$pinia = a,
            o.forEach(e => n.push(e)),
            o = []
        },
        use(e) {
            return this._a ? n.push(e) : o.push(e),
            this
        },
        _p: n,
        _a: null,
        _e: e,
        _s: new Map,
        state: t
    });
    return a
}()),
vB.directive("mask", Ll.mask),
vB.component("TheMask", Ll.TheMask),
vB.use(hB),
vB.mount("#app");
export {Ho as A, vv as B, b_ as C, S_ as D, o_ as E, Zy as F, Tr as G, vC as H, sm as I, ZA as J, WA as K, qA as L, _r as M, qo as N, Wo as O, K as P, hv as Q, Lf as R, Ud as S, gp as T, gE as U, jO as _, tE as a, eE as b, Fy as c, to as d, Br as e, Dr as f, jr as g, En as h, nE as i, YC as j, Vr as k, cm as l, Gr as m, Nt as n, Wg as o, Bt as p, Qv as q, It as r, Zg as s, Ir as t, QC as u, Vo as v, Qa as w, ne as x, um as y, Tn as z};
